<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在 Go 中处理恐慌 # 介绍 # 程序遇到的错误分为两个广泛的类别：程序员已经预料到的错误和程序员没有预料到的错误。我们在前两篇关于 错误处理 的文章中介绍过的 error 接口主要用于处理我们在编写 Go 程序时可能遇到的错误。error 接口甚至允许我们去确认在调用一个函数时发生罕见性错误的可能性，因此我们可以在这些情况下进行适当的响应。
Panics 属于第二类错误，这些错误是程序员意料之外的。这些意料之外的错误导致一个 GO 程序自发终止并退出运行。常见的错误通常是造成 panic 的原因。在本教程中，我们将研究哪些常见操作可以引起 panic ，我们还将看到避免这些 panic 的方法。我们还将使用 defer 语句与 recover 函数一起捕获 panic，以免 panic 有机会意外终止我们正在运行的 GO 程序。
了解 panics # GO 中的某些操作会自动返回 panic 并停止程序的运行。常见的操作包括索引超出 数组 的容量，执行类型的断言，空指针上的调用方法，错误地使用互斥锁以及尝试使用已经关闭的 chanel 等等。这些情况中的大多数是由于编程时犯错而导致的，再加上编译器在编译程序时没有检测到这些错误。
由于 panic 包含了有助于解决问题的细节，所以开发者通常会使用 panic 来标记在开发过程中犯了一个错误。
由于越界引发的 panic # 当你尝试访问超出切片长度或数组容量之外的索引时，GO 运行时会产生 panic。
下面的示例是尝试使用内置的 len 函数返回的切片的长度, 然后访问切片的最后一个元素时常见错误。尝试运行此代码以了解为什么这可能会引起 panic：
package main import ( &#34;fmt&#34; ) func main() { names := []string{ &#34;lobster&#34;, &#34;sea urchin&#34;, &#34;sea cucumber&#34;, } fmt."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="在 Go 中处理恐慌 # 介绍 # 程序遇到的错误分为两个广泛的类别：程序员已经预料到的错误和程序员没有预料到的错误。我们在前两篇关于 错误处理 的文章中介绍过的 error 接口主要用于处理我们在编写 Go 程序时可能遇到的错误。error 接口甚至允许我们去确认在调用一个函数时发生罕见性错误的可能性，因此我们可以在这些情况下进行适当的响应。
Panics 属于第二类错误，这些错误是程序员意料之外的。这些意料之外的错误导致一个 GO 程序自发终止并退出运行。常见的错误通常是造成 panic 的原因。在本教程中，我们将研究哪些常见操作可以引起 panic ，我们还将看到避免这些 panic 的方法。我们还将使用 defer 语句与 recover 函数一起捕获 panic，以免 panic 有机会意外终止我们正在运行的 GO 程序。
了解 panics # GO 中的某些操作会自动返回 panic 并停止程序的运行。常见的操作包括索引超出 数组 的容量，执行类型的断言，空指针上的调用方法，错误地使用互斥锁以及尝试使用已经关闭的 chanel 等等。这些情况中的大多数是由于编程时犯错而导致的，再加上编译器在编译程序时没有检测到这些错误。
由于 panic 包含了有助于解决问题的细节，所以开发者通常会使用 panic 来标记在开发过程中犯了一个错误。
由于越界引发的 panic # 当你尝试访问超出切片长度或数组容量之外的索引时，GO 运行时会产生 panic。
下面的示例是尝试使用内置的 len 函数返回的切片的长度, 然后访问切片的最后一个元素时常见错误。尝试运行此代码以了解为什么这可能会引起 panic：
package main import ( &#34;fmt&#34; ) func main() { names := []string{ &#34;lobster&#34;, &#34;sea urchin&#34;, &#34;sea cucumber&#34;, } fmt."><meta property="og:type" content="article"><meta property="og:url" content="https://gocn.github.io/How-To-Code-in-Go/docs/19-Handling_Panics_in_Go-_DigitalOcean/"><meta property="article:section" content="docs"><title>19 Handling Panics in Go Digital Ocean | How To Code in Go</title><link rel=manifest href=/How-To-Code-in-Go/manifest.json><link rel=icon href=/How-To-Code-in-Go/favicon.png type=image/x-icon><link rel=stylesheet href=/How-To-Code-in-Go/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/How-To-Code-in-Go/flexsearch.min.js></script>
<script defer src=/How-To-Code-in-Go/zh.search.min.2ccdafc211784f64f63652981924d269b4ff643413814bfc0d5743573b76ade7.js integrity="sha256-LM2vwhF4T2T2NlKYGSTSabT/ZDQTgUv8DVdDVzt2rec=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/How-To-Code-in-Go/><span>How To Code in Go</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><p><strong>开始学习</strong></p><ul><li><a href=/How-To-Code-in-Go/docs/01-How_To_Install_Go_and_Set_Up_a_Local-Programming_Environment_on_Ubuntu_18.04_DigitalOcean/>1. 如何在 Ubuntu 18.04 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/02-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_macOS_DigitalOcean/>2. 如何在 macOS 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/03-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_Windows_10_DigitalOcean/>3. 如何在 Windows 10 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/04-How_To_Write_Your_First_Program_in_Go_DigitalOcean/>4. 如何用 Go 编写你的第一个程序</a></li><li><a href=/How-To-Code-in-Go/docs/05-Understanding_the_GOPATH/>5. 理解 GOPATH</a></li><li><a href=/How-To-Code-in-Go/docs/06-How_To_Write_Comments_in_Go/>6. 如何在 Go 中写注释</a></li><li><a href=/How-To-Code-in-Go/docs/07-Understanding_Data_Types_in_Go/>7. 理解 Go 的数据类型</a></li><li><a href=/How-To-Code-in-Go/docs/08-An_Introduction_to_Working_with_Strings_in_Go/>8. Go 中处理字符串的介绍</a></li><li><a href=/How-To-Code-in-Go/docs/09-How_To_Format_Strings_in_Go/>9. 如何在 Go 中格式化字符串</a></li><li><a href=/How-To-Code-in-Go/docs/10-An_Introduction_to_the_Strings_Package_in_Go/>10. 介绍 Go 中的 Strings 包</a></li><li><a href=/How-To-Code-in-Go/docs/11-How_To_Use_Variables_and_Constants_in_Go/>11. 如何在 Go 中使用变量和常量</a></li><li><a href=/How-To-Code-in-Go/docs/12-How_To_Convert_Data_Types_in_Go/>12. 如何在 Go 中转换数据类型</a></li><li><a href=/How-To-Code-in-Go/docs/13-How_To_Do_Math_in_Go_with_Operators/>13. 如何用运算符在 Go 中做数学计算</a></li><li><a href=/How-To-Code-in-Go/docs/14-Understanding_Boolean_Logic_in_Go/>14. 理解 Go 中的布尔逻辑</a></li><li><a href=/How-To-Code-in-Go/docs/15-Understanding_Maps_in_Go/>15. 理解 Go 中的 Map</a></li><li><a href=/How-To-Code-in-Go/docs/16-Understanding_Arrays_and_Slices_in_Go/>16. 理解 Go 中的数组和切片</a></li><li><a href=/How-To-Code-in-Go/docs/17-Handling_Errors_in_Go_DigitalOcean/>17. 在 Go 中处理错误</a></li><li><a href=/How-To-Code-in-Go/docs/18-Creating_Custom_Errors_in_Go_DigitalOcean/>18. 在 Go 中创建自定义错误</a></li><li><a href=/How-To-Code-in-Go/docs/19-Handling_Panics_in_Go-_DigitalOcean/ class=active>19 在 Go 中处理恐慌</a></li><li><a href=/How-To-Code-in-Go/docs/20-Importing_Packages_in_Go_DigitalOcean/>20. 在 Go 中导入包</a></li><li><a href=/How-To-Code-in-Go/docs/21-How_To_Write_Packages_in_Go/>21. 如何在 Go 中编写包</a></li><li><a href=/How-To-Code-in-Go/docs/22-Understanding_Package_Visibility_in_Go/>22. 理解 Go 中包的可见性</a></li><li><a href=/How-To-Code-in-Go/docs/23-How_To_Write_Conditional_Statements_in_Go/>23. 如何在 Go 中编写条件语句</a></li><li><a href=/How-To-Code-in-Go/docs/24-How_To_Write_Switch_Statements_in_Go/>24. 如何在 Go 中编写 Switch 语句</a></li><li><a href=/How-To-Code-in-Go/docs/25-How_To_Construct_For_Loops_in_Go/>25. 如何在 Go 中构造 for 循环</a></li><li><a href=/How-To-Code-in-Go/docs/26-Using_Break_and_Continue_Statements_When_Working_with_Loops_in_Go/>26. 在循环中使用 Break 和 Continue</a></li><li><a href=/How-To-Code-in-Go/docs/27-How_To_Define_and_Call_Functions_in_Go/>27. 如何在 Go 中定义并调用函数</a></li><li><a href=/How-To-Code-in-Go/docs/28-How_To_Use_Variadic_Functions_in_Go/>28. 如何在 Go 中使用可变参数函数</a></li><li><a href=/How-To-Code-in-Go/docs/29-Understanding_defer_in_Go/>29. 理解 Go 中的 defer</a></li><li><a href=/How-To-Code-in-Go/docs/30-Understanding_init_in_Go/>30. 理解 Go 中的 init</a></li><li><a href=/How-To-Code-in-Go/docs/31-Customizing_Go_Binaries_with_Build_Tags/>31. 用构建标签定制 Go 二进制文件</a></li><li><a href=/How-To-Code-in-Go/docs/32-Understanding_Pointers_in_Go/>32. 理解 Go 中的指针</a></li><li><a href=/How-To-Code-in-Go/docs/33-Defining_Structs_in_Go/>33. 在 Go 中定义结构体</a></li><li><a href=/How-To-Code-in-Go/docs/34-Defining_Methods_in_Go/>34. 在 Go 中定义方法</a></li><li><a href=/How-To-Code-in-Go/docs/35-How_To_Build_and_Install_Go_Programs/>35. 如何构建和安装 Go 程序</a></li><li><a href=/How-To-Code-in-Go/docs/36-How_To_Use_Struct_Tags_in_Go/>36. 如何在 Go 中使用结构体标签</a></li><li><a href=/How-To-Code-in-Go/docs/37-How_To_Use_Interfaces_in_Go/>37. 如何在 Go 使用 interface</a></li><li><a href=/How-To-Code-in-Go/docs/38-Building_Go_Applications_for_Different_Operating_Systems_and_Architectures/>38. 在不同的操作系统和架构编译 Go 应用</a></li><li><a href=/How-To-Code-in-Go/docs/39-Using_ldflags_to_Set_Version_Information_for_Go_Applications/>39. 用 ldflags 设置 Go 应用程序的版本信息</a></li><li><a href=/How-To-Code-in-Go/docs/40-How_To_Use_the_Flag_Package_in_Go/>40. 在 Go 里面如何使用 Flag 包</a></li><li><a href=/How-To-Code-in-Go/docs/41-How_to_Use_Go_Modules/>41. 如何使用 Go 模块</a></li><li><a href=/How-To-Code-in-Go/docs/42-How_to_Distribute_Go_Modules/>42. 如何分发 Go 模块</a></li><li><a href=/How-To-Code-in-Go/docs/43-How_to_Use_a_Private_Go_Module_in_Your_Own_Project/>43. 如何在自己的项目中使用私有的Go模块</a></li></ul></li><li><p><strong>附录：资源</strong></p></li><li><p><a href=https://github.com/gocn/How-To-Code-in-Go><strong>Fork on Github</strong></a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/How-To-Code-in-Go/svg/menu.svg class=book-icon alt=Menu></label>
<strong>19 Handling Panics in Go Digital Ocean</strong>
<label for=toc-control><img src=/How-To-Code-in-Go/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#了解-panics>了解 panics</a></li><li><a href=#由于越界引发的-panic>由于越界引发的 panic</a></li><li><a href=#剖析-panic>剖析 panic</a></li><li><a href=#nil-receivers>Nil Receivers</a></li><li><a href=#nil-指针调用方法>nil 指针调用方法</a></li><li><a href=#使用内置的-panic-函数>使用内置的 <code>panic</code> 函数</a></li><li><a href=#derfer-函数>derfer 函数</a></li><li><a href=#处理-panic>处理 panic</a></li><li><a href=#使用-recover-检测-panic>使用 <code>recover</code> 检测 panic</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#总结>总结</a></li></ul></nav></aside></header><article class=markdown><h1 id=在-go-中处理恐慌>在 Go 中处理恐慌
<a class=anchor href=#%e5%9c%a8-go-%e4%b8%ad%e5%a4%84%e7%90%86%e6%81%90%e6%85%8c>#</a></h1><h2 id=介绍>介绍
<a class=anchor href=#%e4%bb%8b%e7%bb%8d>#</a></h2><p>程序遇到的错误分为两个广泛的类别：程序员已经预料到的错误和程序员没有预料到的错误。我们在前两篇关于 <a href=/How-To-Code-in-Go/docs/12-How_To_Convert_Data_Types_in_Go/>错误处理</a> 的文章中介绍过的 <code>error</code> 接口主要用于处理我们在编写 Go 程序时可能遇到的错误。<code>error</code> 接口甚至允许我们去确认在调用一个函数时发生罕见性错误的可能性，因此我们可以在这些情况下进行适当的响应。</p><p>Panics 属于第二类错误，这些错误是程序员意料之外的。这些意料之外的错误导致一个 GO 程序自发终止并退出运行。常见的错误通常是造成 panic 的原因。在本教程中，我们将研究哪些常见操作可以引起 panic ，我们还将看到避免这些 panic 的方法。我们还将使用 <a href=/How-To-Code-in-Go/docs/29-Understanding_defer_in_Go/><code>defer</code></a> 语句与 <code>recover</code> 函数一起捕获 panic，以免 panic 有机会意外终止我们正在运行的 GO 程序。</p><h2 id=了解-panics>了解 panics
<a class=anchor href=#%e4%ba%86%e8%a7%a3-panics>#</a></h2><p>GO 中的某些操作会自动返回 panic 并停止程序的运行。常见的操作包括索引超出 <a href=https://gocn.github.io/How-To-Code-in-Go/docs/16-Understanding_Arrays_and_Slices_in_Go/#%E6%95%B0%E7%BB%84>数组</a> 的容量，执行类型的断言，空指针上的调用方法，错误地使用互斥锁以及尝试使用已经关闭的 chanel 等等。这些情况中的大多数是由于编程时犯错而导致的，再加上编译器在编译程序时没有检测到这些错误。</p><p>由于 panic 包含了有助于解决问题的细节，所以开发者通常会使用 panic 来标记在开发过程中犯了一个错误。</p><h2 id=由于越界引发的-panic>由于越界引发的 panic
<a class=anchor href=#%e7%94%b1%e4%ba%8e%e8%b6%8a%e7%95%8c%e5%bc%95%e5%8f%91%e7%9a%84-panic>#</a></h2><p>当你尝试访问超出切片长度或数组容量之外的索引时，GO 运行时会产生 panic。</p><p>下面的示例是尝试使用内置的 <code>len</code> 函数返回的切片的长度, 然后访问切片的最后一个元素时常见错误。尝试运行此代码以了解为什么这可能会引起 panic：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>names</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;lobster&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;sea urchin&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;sea cucumber&#34;</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;My favorite sea creature is:&#34;</span>, <span style=color:#a6e22e>names</span>[len(<span style=color:#a6e22e>names</span>)])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这将会有有以下输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>panic: runtime error: index out of range <span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> with length <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>goroutine <span style=color:#ae81ff>1</span> <span style=color:#f92672>[</span>running<span style=color:#f92672>]</span>:
</span></span><span style=display:flex><span>main.main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 备注这一块信息可能会有不一样的输出</span>
</span></span><span style=display:flex><span>/tmp/sandbox879828148/prog.go:13 +0x20
</span></span></code></pre></div><p>panic 输出的名称提供了一个提示：<code>panic: runtime error: index out of range</code>。我们用三个海洋生物创建了一个切片。然后，我们尝试通过使用内置的 <code>len</code> 函数将切片的长度作为索引来获取切片的最后一个元素。请记住，切片和数组的第一个元素的下标都是 0; 因此，第一个元素的索引是 0，此切片中的最后一个元素在索引2。由于我们尝试在第三个索引，3 时，因此切片中没有元素要返回并且超出了切片的边界。运行时别无选择，只能终止和退出，因为我们要求它做一些不可能的事情。Go 在编译过程中也无法证明此代码将尝试执行此操作，因此编译器无法捕获到这种操作。</p><blockquote><p>还请注意，后续代码还没被执行。这是因为 panic 是一个完全阻止执行你的 GO 程序的事件。其中产生的消息中包含多个有助于诊断 panic 的原因。</p></blockquote><h2 id=剖析-panic>剖析 panic
<a class=anchor href=#%e5%89%96%e6%9e%90-panic>#</a></h2><p>panics 由指示 panic 的原因和一个 <a href=https://en.wikipedia.org/wiki/Stack_trace>堆栈跟踪</a> 信息组成，这些可帮助你在代码中找到 panic 的位置。</p><p>任何 panic 的第一部分都是消息。它始终将以字符串 <code>panic:</code> 开始, 紧接着是引发 panic 的具体原因的字符串。在上一个练习中有一个 panic 的消息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>panic: runtime error: index out of range <span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> with length <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>紧接着 <code>panic:</code> 的是 <code>runtime error:</code> 这告诉我们这个 panic 是由语言的运行时引起的。这个 panic 告诉我们, 我们尝试使用下标 <code>[3]</code>已经超出了切片的长度 <code>3</code> 了。</p><p>消息后面的是堆栈跟踪。堆栈跟踪形成一个映射，我们可以根据映射信息，以准确地定位生成 panic 时正在执行的代码所在的行，和代码的调用链关系。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goroutine <span style=color:#ae81ff>1</span> <span style=color:#f92672>[</span>running<span style=color:#f92672>]</span>:
</span></span><span style=display:flex><span>main.main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>/tmp/sandbox879828148/prog.go:13 +0x20
</span></span></code></pre></div><p>上一个示例的堆栈跟踪表示，我们的程序从 <code>/tmp/sandbox879828148/prog.go</code> 文件的第 13 行中生成了 panic。这些信息还告诉我们 panic 在 <code>main</code> 包中的 <code>main()</code> 函数产生。</p><p>堆栈跟踪分为单独的块 - 对于你程序中的每个 <a href=https://tour.golang.org/concurrency/1>goroutine</a>一个块。每个 GO 程序的执行都是通过一个或多个 goroutines 来完成的，它们可以独立并同时执行 GO 代码的一部分。每个块从标头 <code>goroutine x [state]:</code> (其中 x: 表示 goroutine 的 id, [state] 表示 goroutine 当前的状态)开头。标头给出了 goroutine 的 ID 号，以及发生 panic 时所处的状态。标头后，堆栈跟踪显示了发生 panic 时程序执行的函数，以及执行函数所在的文件名和行号。</p><p>上一个示例中的 panic 是通过对切片的越界访问而产生的。当使用空指针去调用方法时，也可以生成 panic。</p><h2 id=nil-receivers>Nil Receivers
<a class=anchor href=#nil-receivers>#</a></h2><h2 id=nil-指针调用方法>nil 指针调用方法
<a class=anchor href=#nil-%e6%8c%87%e9%92%88%e8%b0%83%e7%94%a8%e6%96%b9%e6%b3%95>#</a></h2><p>GO 编程语言在运行时具有指向计算机内存中存在的某种类型的特定实例的指针。指针可以是 <code>nil</code> 值, 这表明他们没有指向任何东西。当我们尝试在零指针上调用方法时，GO 运行时会产生 panic。同样，当调用方法时，是接口类型的变量也会产生 panic。要查看这些情况下产生的 panic，请尝试以下示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Shark</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Shark</span>) <span style=color:#a6e22e>SayHello</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hi! My name is&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Name</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Shark</span>{<span style=color:#e6db74>&#34;Sammy&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>SayHello</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The panics produced will look like this:</p><p>由此产生的 panic 将是这样的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>panic: runtime error: invalid memory address or nil pointer dereference
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>signal SIGSEGV: segmentation violation code<span style=color:#f92672>=</span>0xffffffff addr<span style=color:#f92672>=</span>0x0 pc<span style=color:#f92672>=</span>0xdfeba<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>goroutine <span style=color:#ae81ff>1</span> <span style=color:#f92672>[</span>running<span style=color:#f92672>]</span>:
</span></span><span style=display:flex><span>main.<span style=color:#f92672>(</span>*Shark<span style=color:#f92672>)</span>.SayHello<span style=color:#f92672>(</span>...<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>/tmp/sandbox160713813/prog.go:12
</span></span><span style=display:flex><span>main.main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>/tmp/sandbox160713813/prog.go:18 +0x1a
</span></span></code></pre></div><p>在此示例中，我们定义了一个称为 <code>Shark</code> 的结构体。<code>Shark</code> 在其指针接收器上定义了一个叫做 <code>Sayhello</code> 的方法，这个方法将在被调用时在标准输出中打印出问候信息。在我们的 <code>main</code> 函数主体中，我们创建了 <code>Shark</code> 结构体的新实例，并使用 <code>&</code> 操作符取变量的指针并将指针分配给 <code>S</code> 变量。然后，我们使用语句 <code>s = nil</code> 将 <code>s</code> 变量重新赋值为 <code>nil</code>。最后，我们尝试在变量 <code>s</code> 上调用 <code>SayHello</code> 方法。我们没有收到 <code>Sammy</code> 的友好消息，而是收到 panic，因为我们试图访问无效的内存地址。因为 <code>s</code> 变量为 <code>nil</code>，所以当调用 <code>SayHello</code> 函数时，它试图访问 <code>*Shark</code> 类型上的 <code>Name</code> 字段。因为这是一个指针接收者，并且在这种情况下的接收者是 <code>nil</code> 的，所以无法解引用零值指针而引起的 panic。</p><p>虽然我们在本例中显式地将 <code>s</code> 设置为<code>nil</code>，但实际上，这种情况却不明显。当你看到有关解引用 <code>nil</code> 指针而引发的 panic 时，请确保你已正确分配了你可能创建的任何指针变量。</p><blockquote><p>备注, 通过使用指针作为接收者时, 使用零值取调用时没有不会发生 panic 的, 真正发生 panic 的时, 解引用 <code>nil</code> 指针。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#75715e>// 这种定义时, 使用零值的 `* Shark` 对象去调用 SayHello 方法是没有问题的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Shark</span>) <span style=color:#a6e22e>SayHello</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hi! My name is&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Name</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>解引用 <code>nil</code> 指针和越界访问产生的 panic 是两种在运行时产生的 panic 常见的场景。也可以使用内置函数手动产生 panic。</p><h2 id=使用内置的-panic-函数>使用内置的 <code>panic</code> 函数
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%86%85%e7%bd%ae%e7%9a%84-panic-%e5%87%bd%e6%95%b0>#</a></h2><p>我们还可以使用内置的 <code>panic</code> 函数来产生自己的 panic。它使用单个字符串作为参数，这是 panic 产生的信息。一般这条消息比重写 error 代码中的消息简单得多。此外，我们可以在我们自己的软件包中使用它向开发者指出，他们在使用包装代码时可能犯了一个错误。但是，最佳实践就是尝试在我们提供的软件包中将 <code>error</code> 值返回给开发者。</p><p>运行此代码以查看从 <code>main</code> 函数调用 <code>foo</code> 函数产生的 panic：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>foo</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;oh no!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>产生的 panic 输出看起来像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>panic: oh no!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>goroutine <span style=color:#ae81ff>1</span> <span style=color:#f92672>[</span>running<span style=color:#f92672>]</span>:
</span></span><span style=display:flex><span>main.foo<span style=color:#f92672>(</span>...<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>/tmp/sandbox494710869/prog.go:8
</span></span><span style=display:flex><span>main.main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>/tmp/sandbox494710869/prog.go:4 +0x40
</span></span></code></pre></div><p>在这里，我们定义了一个 <code>foo</code> 函数，里面会使用 <code>"oh no!"</code> 这个字符串调用 <code>panic</code> 这个内置函数。<code>foo</code> 函数由我们的 <code>main</code> 函数调用。请注意输出如何输出 <code>panic: oh no!</code> 和堆栈跟踪, 在堆栈跟踪中展示一个 goroutine 和两行堆栈跟踪: 一行是 <code>main()</code> 函数，另一行是 <code>foo()</code> 函数。</p><p>我们已经看到，panic 产生时似乎终止了我们的程序的运行。当需要正确关闭的开放资源时, 这可能会产生一些问题。GO 提供了一种机制，即使在 panic 的情况下，也可以始终执行一些代码。</p><h2 id=derfer-函数>derfer 函数
<a class=anchor href=#derfer-%e5%87%bd%e6%95%b0>#</a></h2><p>你的程序即使在运行时处理 panic 也必须能够正确清理的资源。GO 允许使用 defer 来调用延迟执行函数，直到调用它的函数完成时才会执行。延迟函数即使在出现 panic 的情况下也会运行，并被用作一种安全机制，用来防范 panic 的混乱本质。通过调用普通一样调用函数, 使用关键字 <code>defer</code> 作为调用整个函数调用语句的前缀，比如像调用 <code>defer sayHello()</code> 一样。运行此示例以查看即使产生 panic 时也可以打印消息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello from the deferred function!&#34;</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;oh no!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此示例产生的输出看起来像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>hello from the deferred <span style=color:#66d9ef>function</span>!
</span></span><span style=display:flex><span>panic: oh no!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>goroutine <span style=color:#ae81ff>1</span> <span style=color:#f92672>[</span>running<span style=color:#f92672>]</span>:
</span></span><span style=display:flex><span>main.main<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>/Users/gopherguides/learn/src/github.com/gopherguides/learn//handle-panics/src/main.go:10 +0x55
</span></span></code></pre></div><p>在此示例的 <code>main()</code> 函数中，我们首先使用 <code>defer</code> 调用到打印消息 <code>"hello from the deferred function!"</code> 的匿名函数。然后，<code>main</code> 函数立即使用 <code>panic</code> 函数产生 panic。在此程序的输出中，我们首先看到执行递延函数并打印其消息。在此之后是，我们在 <code>main</code> 中产生 panic 消息。</p><p>延迟函数提供了防范 panic 的保护。在递延函数中，GO 提供另一个内置函数来阻止 panic 终止 GO 程序的机会。</p><h2 id=处理-panic>处理 panic
<a class=anchor href=#%e5%a4%84%e7%90%86-panic>#</a></h2><p>go 内置的 <code>recover</code> 函数提供了一个恢复 panic 的机制。这个函数通过拦截函数的调用栈并且阻止程序的意外退出。它具有严格的使用规则，但是在编写应用代码时非常有用。</p><p>因为 <code>recover</code> 是内置包的一部分, 所以我们可以在不导包的情况下使用这个函数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>divideByZero</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;we survived dividing by zero!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>divideByZero</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;panic occurred:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>divide</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>divide</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此示例将输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>2009/11/10 23:00:00 panic occurred: runtime error: integer divide by zero
</span></span><span style=display:flex><span>we survived dividing by zero!
</span></span></code></pre></div><p>在此示例中，我们在 <code>main</code> 函数调用了我们定义的 <code>DivideByZero</code> 函数。在 <code>DivideByZero</code> 中，我们使用 <code>defer</code> 关键字调用匿名函数。这个匿名函数负责处理在 <code>divideByZero</code> 中出现的任何 panic。在匿名函数中, 我们调用内置的 <code>recover</code> 函数并且将错误信息赋值给 <code>err</code>, 如果 <code>DivideByZero</code>感处于 panic 状态，那么 <code>err</code> 将会被设置值，否则为 <code>nil</code>。通过将 <code>err</code> 与 <code>nil</code> 进行比较，我们可以检测到是否发生了 panic，在这种情况下，我们处理 <code>panic</code> 就像处理其他错误一样, 使用 <code>log.Println</code> 函数记录了 panic。</p><p>在延迟执行匿名函数之后, 我们调用了另外一个我们定义的另一个函数, 并且尝试使用 <code>fmt.Println</code> 打印这个函数的返回值。所提供的参数将导致除法执行除数为零的操作，这将引起 panic。</p><p>在此示例的输出中，我们首先从匿名函数中恢复 panic 的日志消息，接下来是 <code>we survived dividing by zero!</code> 的消息。我们真的做到了这一点，这要归功于内置的 <code>recover</code> 函数, 它成功阻止有可能终止 GO 程序运行的灾难性 panic。</p><p>从 <code>recover()</code> 函数中返回的 <code>err</code> 值正是调用 <code>panic</code> 的值。因此，在没有发生 panic 时，确保 <code>err</code> 值仅为 <code>nil</code> 至关重要。</p><h2 id=使用-recover-检测-panic>使用 <code>recover</code> 检测 panic
<a class=anchor href=#%e4%bd%bf%e7%94%a8-recover-%e6%a3%80%e6%b5%8b-panic>#</a></h2><p><code>recover</code> 函数依赖于错误的值来确定是否发生了 panic。因为 <code>panic</code> 函数的参数是空接口，所以它可以是任何类型。任何接口类型 (包括空接口) 的零值为 <code>nil</code>。必须注意避免使用 <code>nil</code>作为 <code>panic</code> 的参数，如本示例所证明的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>divideByZero</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;we survived dividing by zero!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>divideByZero</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;panic occurred:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>divide</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>divide</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这将输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>we survived dividing by zero!
</span></span></code></pre></div><p>此示例与以前的示例相同，该示例涉及 <code>recover</code> 并进行一些小的修改。已更改了 <code>divide</code> 函数判断 <code>b</code> 是否为 <code>0</code>。如果是, 它将使用带有 <code>nil</code> 作为参数调用 <code>panic</code> 函数来产生 panic。这次的输出不包括 <code>defer</code> 调用匿名函数的日志消息，即使通过 <code>Divide</code> 创建了 panic，也会出现 panic。这种沉默行为是为什么确保调用 <code>panic</code> 的参数不是 <code>nil</code> 很重要的原因。</p><h2 id=conclusion>Conclusion
<a class=anchor href=#conclusion>#</a></h2><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><p>我们已经看到了多种可以在 GO 中造成 panic 的方法，以及如何使用恢复的内置的 <code>recover</code> 来恢复它们。虽然您不一定会自己使用 <code>panic</code>，但适当的 panic 的恢复机制是使 Go 代码达到生产级别应用程序的重要步骤。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#了解-panics>了解 panics</a></li><li><a href=#由于越界引发的-panic>由于越界引发的 panic</a></li><li><a href=#剖析-panic>剖析 panic</a></li><li><a href=#nil-receivers>Nil Receivers</a></li><li><a href=#nil-指针调用方法>nil 指针调用方法</a></li><li><a href=#使用内置的-panic-函数>使用内置的 <code>panic</code> 函数</a></li><li><a href=#derfer-函数>derfer 函数</a></li><li><a href=#处理-panic>处理 panic</a></li><li><a href=#使用-recover-检测-panic>使用 <code>recover</code> 检测 panic</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></main></body></html>