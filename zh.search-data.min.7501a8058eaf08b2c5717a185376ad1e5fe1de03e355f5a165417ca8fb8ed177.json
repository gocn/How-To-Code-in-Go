[{"id":0,"href":"/How-To-Code-in-Go/docs/01-How_To_Install_Go_and_Set_Up_a_Local-Programming_Environment_on_Ubuntu_18.04_DigitalOcean/","title":"01 How to Install Go and Set Up a Local Programming Environment on Ubuntu 18.04 Digital Ocean","section":"Docs","content":" 如何在 Ubuntu 18.04 上安装 Go 和设置本地编程环境 # Go 语言简介 # Go 是一门在 Google 备受挫折后而诞生的语言。开发者不得不频繁地在两种语言中选择，要么选择一门执行效率高但是编译时间长的语言，要么选择一种易于编程但在生产中运行效率低下的语言。 Go 被设计为同时提供所有这三个功能：快速编译、易于编程和生产中的高效执行。\n虽然 Go 是一门通用的编程语言，可用于许多不同类型的编程项目。但它特别适合网络/分布式系统项目，赢得了“云语言”的美誉。Go 语言专注于通过一组强大的工具来帮助现代程序员完成更多的工作，通过使格式成为语言规范的一部分来消除对格式的争论，以及通过编译为单个二进制文件来简化部署。 Go 易于学习，关键字非常少，这使其成为不论是初学者还是经验丰富的开发人员的不二之选。\n本教程将指导你通过命令行来安装 Go 和配置 Go 编程环境。本教程特别针对 Ubuntu 18.04 的安装过程，但是对于其他 Debian Linux 发行版也同样适用。\n安装前提 # 你需要一台安装了 Ubuntu 18.04 的电脑或者虚拟机，并且有对该计算机的管理员访问权限和网络连接。 您可以通过 Ubuntu 18.04 版本页面 下载此操作系统。\n第一步 — 安装 Go # 在这一步，你通过 Go 官方下载页面下载最新版本来安装 Go。\n为此，你需要找到最新二进制版本压缩包的 URL 。你还要注意旁边列出的 SHA256 哈希值，因为你将用它来验证下载的文件。\n你将通过命令行来完成安装和设置，这是一种与计算机交互的非图形化方式。也就是说，你输入的是文本，然后也是通过文本得到计算机的反馈，而不是点击按钮。\n命令行，也就是我们熟知的 shell 或者 终端 ，可以帮助你修改或自动化很多你每天执行在计算机上的任务，这是软件开发人员必备的工具。尽管有很多终端命令需要学习，但是这些命令可以让你做更强大的事情。有关命令行的更多信息，请查看 Linux 终端简介 教程。\n在 Ubuntu 18.04 上，你可以通过点击屏幕左上角的 Ubuntu 图标并在搜索栏中输入terminal来找到终端程序。点击终端程序图标来打开终端。或者你可以在键盘上同时按住的“CTRL”、“ALT”和“T”键来自动打开终端程序。\n终端打开之后，你可以手动安装 Go 二进制。虽然可以通过包管理工具，比如 apt-get，但是通过手动安装可以帮助你理解一个有效的 Go 工作区系统里面任何必要的配置信息的修改。\n下载 Go 之前，确保你在 home (~) 目录：\ncd ~ 根据从官方 Go 下载页面复制的压缩包 URL，使用 curl 命令拉取下载：\ncurl -LO https://dl.google.com/go/go1.12.1.linux-amd64.tar.gz 接下来，使用 sha256sum 命令来校验压缩包：\nsha256sum go1.12.1.linux-amd64.tar.gz 运行上面命令显示的哈希值应该和下载页面的哈希值一致，如果不一致的话，那么这个压缩包就不是一个有效文件，需要重新下载。\nOutput 2a3fdabf665496a0db5f41ec6af7a9b15a49fbe71a85a50ca38b1f13a103aeec go1.12.1.linux-amd64.tar.gz 接下来，解压下载的文件并将其安装到系统所需位置。一般都是放在 /usr/local 目录下面：\nsudo tar -xvf go1.12.1.linux-amd64.tar.gz -C /usr/local 那么在 /usr/local 目录下面有一个 go 目录。\n注意：尽管 /usr/local/go 是官方推荐的位置，但有些用户可能更喜欢或需要不同的路径。\n在这一步中，你在 Ubuntu 18.04 机器上下载并安装了 Go 。接下来你将配置 Go 的工作区。\n第二步 — 创建你的 Go 工作区 # 安装完 Go 之后，你可以创建你的编码工作区。Go 语言的工作区在其根目录下包含两个目录：\nsrc: 该目录包含 Go 的源文件。所谓源文件就是你用 Go 编程语言写的文件。源文件被 Go 编译器构建成可执行的二进制文件。 bin: 该目录包含了 Go 工具构建和安装的可执行文件。可执行文件就是运行在你系统上并执行任务的二进制文件。通常是你的源码或者是其他下载的 Go 源代码编译的程序。 src 子目录可能包含多个版本控制仓库（例如 Git, Mercurial 和 Bazaar）。这允许你在你的项目中规范导入代码。 规范导入就是引用完全限定包的导入，例如 github.com/digitalocean/godo 。\n当你引入第三方库的时候，你可以看到类似 github.com, golang.org 或其他目录，如果你使用的是 github.com 之类的代码仓库，你还将把项目和源文件放在该目录下。 我们将在此步骤的后面部分探讨这个概念。\n下面是典型的工作区目录结构：\n. ├── bin │ ├── buffalo # command executable │ ├── dlv # command executable │ └── packr # command executable └── src └── github.com └── digitalocean └── godo ├── .git # Git repository metadata ├── account.go # package source ├── account_test.go # test source ├── ... ├── timestamp.go ├── timestamp_test.go └── util ├── droplet.go └── droplet_test.go 从 1.8 开始，Go 工作区的默认目录是用户的 home 目录，并带有 go 子目录，或者是 $HOME/go 目录。 如果你使用的是早于 1.8 的 Go 版本，目前认为最佳做法是为你的工作区使用 $HOME/go 位置。\n使用下面命令为你的 Go 工作区创建目录结构：\nmkdir -p $HOME/go/{bin,src} -p 选项是告诉 mkdir 在目录中创建所有的上级目录，尽管他们可能不存在。使用 {bin,src} 为 mkdir 创建一组参数，并告诉它创建 bin 目录和 src 目录。\n以上命令将确保下面的目录结构各就各位：\n└── $HOME └── go ├── bin └── src 在 Go 1.8 之前，需要设置一个名为 $GOPATH 的本地环境变量。 $GOPATH 告诉编译器在哪里可以找到导入的第三方源代码，同样包括任何你写的本地源代码。 虽然不再明确要求它，但它仍然被认为是一种很好的做法，因为许多第三方工具仍然依赖于设置的这个变量。\n你可以通过将全局变量添加到你的 ~/.profile 中来设置你的 $GOPATH。 你可能想根据你的 shell 配置将其添加到 .zshrc 或 .bashrc 文件中。\n首先，使用 nano 或你喜欢的文本编辑器打开 ~/.profile：\nnano ~/.profile 通过下面的命令设置你的 $GOPATH ：\n~/.profile export GOPATH=$HOME/go 当 Go 编译和安装工具时，会将他们放在 $GOPATH/bin 目录。为方便起见，通常将工作区的 /bin 子目录添加到 ~/.profile 中的 PATH 中：\n~/.profile export PATH=$PATH:$GOPATH/bin 这将允许你在系统上的任何位置运行通过 Go 工具编译或下载的任何程序。\n最后，你需要将 go 二进制文件添加到 PATH 中。 你可以通过在行尾添加 /usr/local/go/bin 来实现：\n~/.profile export PATH=$PATH:$GOPATH/bin:/usr/local/go/bin 将 /usr/local/go/bin 添加到 $PATH 中，可以使所有 Go 工具都可以在系统上的任何位置使用。\n为了更新你的 shell 配置，请使用下面的命令来加载全局变量:\n. ~/.profile 您可以通过使用 echo 命令并检查其输出，来验证你的 $PATH 是否已更新：\necho $PATH 你将看到你的 $GOPATH/bin 显示在你的主目录中。如果你以 root 身份登录，你将在路径中看到 /root/go/bin。\nOutput /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/root/go/bin:/usr/local/go/bin 你还会看到 /usr/local/go/bin 的 Go 工具的路径：\nOutput /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/root/go/bin:/usr/local/go/bin 通过检查 Go 的当前版本来验证安装：\ngo version 我们应该得到类似下面的输出：\nOutput go version go1.12.1 linux/amd64 现在你已经创建了工作区的根目录并设置了 $GOPATH 环境变量，你可以根据以下目录结构创建你未来的项目。 此示例假设你使用 github.com 作为仓库：\n$GOPATH/src/github.com/username/project 例如，如果你正在开发 https://github.com/digitalocean/godo 项目，它将存储在以下目录中：\n$GOPATH/src/github.com/digitalocean/godo 该项目结构使项目可以通过 go get 工具使用。它也有助于以后的可读性。 你可以通过使用 go get 命令并获取 godo 库来验证这一点：\ngo get github.com/digitalocean/godo 这将下载 godo 库的内容并在你的计算机上创建 $GOPATH/src/github.com/digitalocean/godo 目录。 你可以通过列出目录来检查下看看是否成功下载了 godo包：\nll $GOPATH/src/github.com/digitalocean/godo 你应该看到类似下面这样的输出：\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; main Outputdrwxr-xr-x 4 root root 4096 Apr 5 00:43 ./ drwxr-xr-x 3 root root 4096 Apr 5 00:43 ../ drwxr-xr-x 8 root root 4096 Apr 5 00:43 .git/ -rwxr-xr-x 1 root root 8 Apr 5 00:43 .gitignore* -rw-r--r-- 1 root root 61 Apr 5 00:43 .travis.yml -rw-r--r-- 1 root root 2808 Apr 5 00:43 CHANGELOG.md -rw-r--r-- 1 root root 1851 Apr 5 00:43 CONTRIBUTING.md . . . -rw-r--r-- 1 root root 4893 Apr 5 00:43 vpcs.go -rw-r--r-- 1 root root 4091 Apr 5 00:43 vpcs_test.go 在这一步中，你创建了一个 Go 工作区并且配置了必要的环境变量。下一步你将使用一些代码来测试下工作区。\n第三步 — 创建一个简单的程序 # 现在你已经设置了工作区，来创建一个 “Hello, World!” 程序吧。这可以检验工作区配置是否正确，并且给你一个更加熟悉 Go 的机会。因为我们创建的是单个 Go 源文件，而不是实际项目，所以我们不需要在工作区中执行此操作。\n在你的 home 目录，打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在新文件里写下你的程序：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 该代码使用了 fmt 包并且使用 Hello, World! 作为参数调用了 Println 函数。这将导致短语 Hello, World! 在程序运行时打印到终端上。\n按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y，然后按 ENTER 退出。\n退出 nano 返回 shell 之后，运行程序：\ngo run hello.go hello.go 程序会使终端产生以下输出：\nOutput Hello, World! 在此步骤中，你使用了一个简单小程序来验证是否正确配置了 Go 工作区。\n总结 # 恭喜！至此，你已经在 Ubuntu 机器上设置了 Go 编程工作区，可以开始写项目了！\n"},{"id":1,"href":"/How-To-Code-in-Go/docs/02-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_macOS_DigitalOcean/","title":"02 How to Install Go and Set Up a Local Programming Environment on MAC Os Digital Ocean","section":"Docs","content":" 如何在 macOS 上安装 Go 和设置本地编程环境 # Go 语言简介 # Go 是一门在 Google 备受挫折后而诞生的语言。开发者不得不频繁地在两门语言中选择，要么选择一门执行效率高但是编译时间长的语言，要么选择一种易于编程但在生产中运行效率低下的语言。 Go 被设计为同时提供所有这三个功能：快速编译、易于编程和生产中的高效执行。\n虽然 Go 是一门通用的编程语言，可用于许多不同类型的编程项目。但它特别适合网络/分布式系统项目，赢得了“云语言”的美誉。Go 语言专注于通过一组强大的工具来帮助现代程序员完成更多的工作，通过使格式成为语言规范的一部分来消除对格式的争论，以及通过编译为单个二进制文件来简化部署。 Go 易于学习，关键字非常少，这使其成为不论是初学者还是经验丰富的开发人员的不二之选。\n本教程将指导你通过命令行来安装 Go 和配置 Go 编程环境。本教程特别针对 Ubuntu 18.04 的安装过程，但是对于其他 Debian Linux 发行版也同样适用。\n安装前提 # 你需要一台拥有管理员权限并且能够连接上网的 macOS 的电脑。\n第一步 — 打开终端 # 我们将会在终端上完成我们大部分的安装和设置，这是一种与计算机交互的非图形化方式。也就是说，你输入的是文本，然后也是通过文本得到计算机的反馈，而不是点击按钮。命令行，也就是我们熟知的 shell 或者 终端 ，可以帮助你修改或自动化很多你每天执行在计算机上的任务，这是软件开发人员必备的工具。\nmacOS 终端是一个可以访问命令行界面的应用程序。就像其他应用程序那样，你可以通过进入 Finder ，导航到 Applications 文件夹，最后进入 Utilities 文件夹找到它。然后就像打开其他应用程序一样双击终端将其打开。或者，你可以通过按住CMD 和 SPACE 键来启动 Spotlight，然后在出现的框中输入终端来查找它。\n尽管有很多终端命令需要学习，但是这些命令可以让你做更强大的事情。 文章Linux 终端简介 可以让你更好地了解 Linux 终端，它和 macOS 终端类似。\n现在你已经打开了终端，你可以下载并安装 Xcode，这是安装 Go 语言所需的开发者工具包。\n第二步 — 安装 Xcode # Xcode 是一个集成开发环境(IDE)，由 macOS 软件开发工具组成。你可以在终端窗口中输入以下命令来检查 Xcode 是否已安装。\nxcode-select -p 下面的输出表明 Xcode 已经安装了：\noutput /Library/Developer/CommandLineTools 如果收到错误信息，请在你的网络浏览器中安装来自 App Store 的 Xcode 并接受默认选项。\n安装完 Xcode 后，返回终端窗口。接下来，你需要安装 Xcode 的单独命令行工具应用，可以通过输入以下命令：\nxcode-select --install 至此，Xcode 及其命令行工具应用已安装完毕，我们准备安装包管理器 Homebrew。\n第三步 — 安装和设置 Homebrew # 尽管 macOS 终端具有 Linux 终端和其他 Unix 系统的许多功能，但它没有提供包管理器的最佳实践。 包管理器是一组软件工具集，用于安装过程的自动化，包括初始软件的安装、升级和配置，以及根据需要删除软件。 他们将安装包保存在一个中心位置，并且可以以常用格式维护系统上的所有软件包。 Homebrew 为 macOS 提供了一个免费的开源软件包管理系统，简化了 macOS 上的软件安装。\n要安装 Homebrew ，请在终端窗口输入以下命令：\n/usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; Homebrew 是用 Ruby 开发的，因此它会修改你计算机的 Ruby 路径。curl 命令从指定的 URL 中提取脚本。该脚本解释了它将要做什么，然后会暂停下来提示你确认。这给了你大量反馈，关于该脚本对你的系统将要做什么并让你有机会验证该过程。\n如果你需要输入密码，请注意你的输入内容不会显示在终端窗口中，但会被记录下来。 输入密码后，只需按 返回 键即可。 否则，当系统提示你确认安装时，按字母 y 表示“是”。\n让我们来看看与 curl 命令相关的一些标志：\nThe -f or --fail flag tells the Terminal window to give no HTML document output on server errors. -f 或者 --fail 标志告诉终端窗口在服务器错误时不提供 HTML 文档输出。 The -s or --silent flag mutes curl so that it does not show the progress meter, and combined with the -S or --show-error flag it will ensure that curl shows an error message if it fails. -s 或者 --silent 标志给curl静音使其不显示进度表，并且结合 -S 或者 --show-error 标志来确保 curl 在失败时显示错误消息。 The -L or --location flag will tell curl to redo the request to a new place if the server reports that the requested page has moved to a different location. -L 或者 --location 标志告诉 curl 如果服务器报告请求的页面已移动到不同的位置，请在新位置重试请求。 安装过程完成后，我们将把 Homebrew 目录放在 PATH 环境变量的顶部。 这将确保 Homebrew 安装命令将会被 macOS 自动选择的工具调用，这些工具可能与我们正在创建的开发环境背道而驰。\n你应该使用命令行文本编辑器 nano 使用 nano 命令创建或者打开 ~/.bash_profile 文件：\nnano ~/.bash_profile 在终端窗口中打开文件后，输入以下内容：\nexport PATH=/usr/local/bin:$PATH 要保存更改，请按住 CTRL 键和字母 o ，并在出现提示时按 RETURN 键。 现在你可以通过按住 CTRL 键和字母 x 来退出 nano。\n在终端中执行以下命令来激活这些更改：\nsource ~/.bash_profile 完成此操作后，你对 PATH 环境变量所做的更改将生效。\n可以通过输入以下命令来确保 Homebrew 已成功安装：\nbrew doctor 如果此时不需要更新，终端将输出以下内容：\noutput Your system is ready to brew. 否则，你可能会收到提示你运行另一个命令（例如 brew update）的警告，以确保你的 Homebrew 的版本是最新的。\n一旦 Homebrew 准备好了，就开始安装 Go 了。\n第四步 — 安装 Go # 你可以通过 brew search 命令来使用 Homebrew 搜索所有可用的软件包。 出于本教程的目的，你将搜索与 Go 相关的包或模块：\nbrew search golang 注意：本教程不使用 brew search go，因为它返回的结果太多。 因为 go 是一个很小的词，并且会匹配很多包，所以使用 golang 作为搜索词变得很普遍。 这也是在互联网上搜索 Go 相关文章时的常见做法。 Golang 一词源于 Go 的域，即 golang.org。\n终端会输出一个你可以安装的列表：\noutput golang golang-migrate Go 将是列表中的一项。继续安装它：\nbrew install golang 终端窗口将为你显示有关 Go 安装过程的反馈。 安装完成可能需要几分钟时间。\n要检查你安装 Go 的版本，输入以下命令：\ngo version 将会输出当前安装的 Go 语言的特定版本，默认情况下它是可用 Go 版本中的最新、最稳定的。\n以后要更新 Go，你可以运行以下命令先更新 Homebrew，然后再更新 Go。 现在不必这样做，因为你刚刚安装了最新版本：\nbrew update brew upgrade golang brew update 将更新 Homebrew 本身，确保你拥有要安装的软件包的最新信息。 brew upgrade golang 会将 golang 包更新到最新版本。\n保持 Go 一直是最新版本是一种很好的做法。\n在你的计算机上安装 Go 后，你现在可以为你的 Go 项目创建工作区。\n第五步 — 创建你的 Go 工作区 # 现在你已经安装了 Xcode、Homebrew 和 Go，可以接着创建你的编程工作区。\nGo 语言的工作区在其根目录下包含两个目录：\nsrc: 该目录包含 Go 的源文件。所谓源文件就是你用 Go 编程语言写的文件。源文件被 Go 编译器构建成可执行的二进制文件。 bin: 该目录包含了 Go 工具构建和安装的可执行文件。可执行文件就是运行在你系统上并执行任务的二进制文件。通常是你的源码或者是其他下载的 Go 源代码编译的程序。 src 子目录可能包含多个版本控制仓库（例如 Git, Mercurial 和 Bazaar）。当你引入第三方库的时候，你可以看到类似 github.com, golang.org 或其他目录，如果你使用的是 github.com 之类的代码仓库，你还将把项目和源文件放在该目录下。 我们将在此步骤的后面部分探讨这个概念。这允许你在你的项目中规范导入代码。 规范导入就是引用完全限定包的导入，例如 github.com/digitalocean/godo 。\n下面是典型的工作区目录结构：\n. ├── bin │ ├── buffalo # command executable │ ├── dlv # command executable │ └── packr # command executable └── src └── github.com └── digitalocean └── godo ├── .git # Git reposistory metadata ├── account.go # package source ├── account_test.go # test source ├── ... ├── timestamp.go ├── timestamp_test.go └── util ├── droplet.go └── droplet_test.go 从 1.8 开始，Go 工作区的默认目录是用户的 home 目录，并带有 go 子目录，或者是 $HOME/go 目录。 如果你使用的是早于 1.8 的 Go 版本，目前认为最佳做法是为你的工作区使用 $HOME/go 位置。\n使用下面命令为你的 Go 工作区创建目录结构：\nmkdir -p $HOME/go/{bin,src} -p 选项是告诉 mkdir 在目录中创建所有的上级目录，尽管他们可能不存在。使用 {bin,src} 为 mkdir 创建一组参数，并告诉它创建 bin 目录和 src 目录。\n以上命令将确保下面的目录结构各就各位：\n└── $HOME └── go ├── bin └── src 在 Go 1.8 之前，需要设置一个名为 $GOPATH 的本地环境变量。 $GOPATH 告诉编译器在哪里可以找到导入的第三方源代码，同样包括任何你写的本地源代码。 虽然不再明确要求它，但它仍然被认为是一种很好的做法，因为许多第三方工具仍然依赖于设置的这个变量。\n你可以通过将全局变量添加到你的 ~/.profile 中来设置你的 $GOPATH。 你可能想根据你的 shell 配置将其添加到 .zshrc 或 .bashrc 文件中。\n首先，使用 nano 或你喜欢的文本编辑器打开 ~/.profile：\nnano ~/.bash_profile 通过下面的命令设置你的 $GOPATH ：\n~/.bash\\_profile export GOPATH=$HOME/go 当 Go 编译和安装工具时，会将他们放在 $GOPATH/bin 目录。为方便起见，通常将工作区的 /bin 子目录添加到 ~/.profile 中的 PATH 中：\n~/.bash\\_profile export PATH=$PATH:$GOPATH/bin 现在，你的 ~/.bash_profile 中应该有以下条目：\n~/.bash\\_profile export GOPATH=$HOME/go export PATH=$PATH:$GOPATH/bin 这将允许你在系统上的任何位置运行通过 Go 工具编译或下载的任何程序。\n为了更新你的 shell 配置，请使用下面的命令来加载全局变量:\n. ~/.bash_profile 您可以通过使用 echo 命令并检查其输出，来验证你的 $PATH 是否已更新：\necho $PATH 你将看到你的 $GOPATH/bin 显示在你的主目录中。如果你以 sammy 身份登录，你将在路径中看到 /Users/sammy/go/bin。\noutput /Users/sammy/go/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin 现在你已经创建了工作区的根目录并设置了 $GOPATH 环境变量，你可以根据以下目录结构创建你未来的项目。 此示例假设你使用 github.com 作为仓库：\n$GOPATH/src/github.com/username/project 例如，如果你正在开发 https://github.com/digitalocean/godo 项目，它将存储在以下目录中：\n$GOPATH/src/github.com/digitalocean/godo 该项目结构使项目可以通过 go get 工具使用。它也有助于以后的可读性。 你可以通过使用 go get 命令并获取 godo 库来验证这一点：\ngo get github.com/digitalocean/godo We can see it successfully downloaded the godo package by listing the directory:\n你可以通过列出目录来检查下看看是否成功下载了 godo包：\nls -l $GOPATH/src/github.com/digitalocean/godo 你应该看到类似下面这样的输出：\nOutput -rw-r--r-- 1 sammy staff 2892 Apr 5 15:56 CHANGELOG.md -rw-r--r-- 1 sammy staff 1851 Apr 5 15:56 CONTRIBUTING.md . . . -rw-r--r-- 1 sammy staff 4893 Apr 5 15:56 vpcs.go -rw-r--r-- 1 sammy staff 4091 Apr 5 15:56 vpcs_test.go 在这一步中，你创建了一个 Go 工作区并且配置了必要的环境变量。下一步你将使用一些代码来测试下工作区。\n第六步 — 创建一个简单的程序 # 现在你已经设置了工作区，来创建一个 “Hello, World!” 程序吧。这可以检验工作区配置是否正确，并且给你一个更加熟悉 Go 的机会。\n因为我们创建的是单个 Go 源文件，而不是实际项目，所以我们不需要在工作区中执行此操作。\n在你的 home 目录，打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在终端中打开文本文件后，输入你的程序代码：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y就行。\n该代码使用了 fmt 包并且使用 Hello, World! 作为参数调用了 Println 函数。这将导致短语 Hello, World! 在程序运行时打印到终端上。\n退出 nano 返回 shell 后，运行程序：\ngo run hello.go hello.go 程序会使终端产生以下输出：\nOutput Hello, World! 在此步骤中，你使用了一个简单小程序来验证是否正确配置了 Go 工作区。\n总结 # 恭喜！至此，你已经在 macOS 机器上设置了 Go 编程工作区，可以开始写项目了！\n"},{"id":2,"href":"/How-To-Code-in-Go/docs/03-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_Windows_10_DigitalOcean/","title":"03 How to Install Go and Set Up a Local Programming Environment on Windows 10 Digital Ocean","section":"Docs","content":" 如何在 Windows 10 上安装 Go 和设置本地编程环境 # Go 语言简介 # Go 是一门在 Google 备受挫折后而诞生的语言。开发者不得不频繁地在两门语言中选择，要么选择一门执行效率高但是编译时间长的语言，要么选择一种易于编程但在生产中运行效率低下的语言。 Go 被设计为同时提供所有这三个功能：快速编译、易于编程和生产中的高效执行。\n虽然 Go 是一门通用的编程语言，可用于许多不同类型的编程项目。但它特别适合网络/分布式系统项目，赢得了“云语言”的美誉。Go 语言专注于通过一组强大的工具来帮助现代程序员完成更多的工作，通过使格式成为语言规范的一部分来消除对格式的争论，以及通过编译为单个二进制文件来简化部署。 Go 易于学习，关键字非常少，这使其成为不论是初学者还是经验丰富的开发人员的不二之选。\n本教程将指导你通过命令行来安装 Go 和配置 Go 编程环境。本教程特别针对 Ubuntu 18.04 的安装过程，但是对于其他 Debian Linux 发行版也同样适用。\n安装前提 # 你需要一台拥有管理员权限并且能够连接上网的 Windows 10 的电脑。\n第一步 — 打开并配置 PowerShell # 我们将会在终端上完成我们大部分的安装和设置，这是一种与计算机交互的非图形化方式。也就是说，你输入的是文本，然后也是通过文本得到计算机的反馈，而不是点击按钮。命令行，也就是我们熟知的 shell 或者 终端 ，可以帮助你修改或自动化很多你每天执行在计算机上的任务，这是软件开发人员必备的工具。\nPowerShell 是微软提供的一个命令行 shell 界面的程序。通过 cmdlets （发音为 command-lets ）来执行管理任务，它们是 .NET 软件框架可以执行操作的专用类。PowerShell 于 2016 年 8 月开源，现在可跨平台使用，适用于 Windows 和 UNIX 系统（包括 Mac 和 Linux）。\n如何找到 Windows PowerShell 呢，你可以右击屏幕左下角的开始按钮，弹出菜单后，点击搜索，然后在搜索栏中输入 PowerShell 。当你看到选项时，右击桌面应用程序中的 Windows PowerShell。 出于本教程的目的，选择以管理员身份运行。 当系统提示你出现一个对话框，询问是否允许此应用程序对您的 PC 进行更改？ 单击是。\n完成此操作后，你将看到一个基于文本的界面，其中包含如下所示的字符串：\n输入以下命令退出系统文件夹：\ncd ~ 然后你会进入到主目录中，比如 PS C:\\Users\\sammy\n要继续安装过程，你必须通过 PowerShell 设置权限。默认情况下以最安全的模式运行，作为管理员你可以设置以下几个级别的权限：\nRestricted 是默认执行策略。 在这种模式下，你将无法运行脚本，并且 PowerShell 只能作为交互式 shell 工作。 AllSigned 将使你能够运行由受信任的发布者签名的所有脚本和配置文件，这意味着可能让计算机面临着运行恶意脚本的风险，这脚本碰巧由受信任发布者签名。 RemoteSigned 将允许你运行由受信任的发布者签名的从 Internet 下载的脚本和配置文件，如果这些受信任的脚本实际上是恶意的，则再次使你的计算机暴露在漏洞面前。. Unrestricted 将运行从 Internet 下载的所有脚本和配置文件，只要你确认你知晓该文件是从 Internet 下载的。 在这种情况下，不需要数字签名，因此你可能会让你计算机面临运行从 Internet 下载的未签名和潜在恶意脚本的风险。 在本教程中，你将使用 RemoteSigned 执行策略来设置当前用户的权限。 这将允许 PowerShell 接受受信任的脚本，而不会使权限像 Unrestricted 权限那样广泛。 在 PowerShell 中输入以下内容：\nSet-ExecutionPolicy -Scope CurrentUser 然后 PowerShell 将提示你为你提供一个可执行策略。 输入以下内容来使用RemoteSigned 策略：\nRemoteSigned 一旦你按了回车键，系统会要求你确认对执行政策的更改。 输入字母 y 以使更改生效。 你可以通过询问机器上的当前权限来确认这是否生效：\nGet-ExecutionPolicy -List 你应该会收到如下所示的输出：\nOutput Scope ExecutionPolicy ----- --------------- MachinePolicy Undefined UserPolicy Undefined Process Undefined CurrentUser RemoteSigned LocalMachine Undefined 这表明当前用户可以运行从 Internet 下载的受信任脚本。 你现在可以继续下载设置 Go 编程环境所需的文件。\n第二步 — 安装包管理器 Chocolatey # 所谓包管理器就是一组软件工具的集合，这些工具使得安装过程自动化。这包括软件的初始安装、升级和配置，以及根据需要删除软件。 他们将软件安装保存在一个中央位置，并且可以以常用格式维护系统上的所有软件包。\nChocolatey 是一个为 Windows 构建的命令行包管理器，其工作方式与 Linux 上的 apt-get 类似。 Chocolatey 提供开源版本，可帮助你快速安装应用程序和工具。 你可以用它来下载开发环境所需的内容。\n在安装脚本之前，请阅读一下脚本并确认它对你的机器所做的更改是否令你感到满意。 为此，请使用 .NET 脚本框架下载 Chocolatey 脚本并将其显示在终端窗口中。\n首先创建一个名为 $script 的 WebClient 对象，该对象与 Internet Explorer 共享 Internet 连接设置：\n$script = New-Object Net.WebClient 通过将带有 | 的 $script 对象传递给 Get-Member 类来查看可用选项：\n$script | Get-Member 这将返回此 WebClient 对象的所有成员（属性和方法）：\n. . . [secondary_label Snippet of Output] DownloadFileAsync Method void DownloadFileAsync(uri address, string fileName), void DownloadFileAsync(ur... DownloadFileTaskAsync Method System.Threading.Tasks.Task DownloadFileTaskAsync(string address, string fileNa... DownloadString Method string DownloadString(string address), string DownloadString(uri address) #method we will use DownloadStringAsync Method void DownloadStringAsync(uri address), void DownloadStringAsync(uri address, Sy... DownloadStringTaskAsync Method System.Threading.Tasks.Task[string] DownloadStringTaskAsync(string address), Sy… . . . 查看输出内容，你可以识别出用于在 PowerShell 窗口中显示脚本和签名的 DownloadString 方法。 使用此方法检查脚本：\n$script.DownloadString(\u0026#34;https://chocolatey.org/install.ps1\u0026#34;) 检查脚本后，通过在 PowerShell 中输入以下内容来安装 Chocolatey：\niwr https://chocolatey.org/install.ps1 -UseBasicParsing | iex cmdlet iwr 或 Invoke-WebRequest 允许你从 Web 中提取数据。 然后将脚本传递给 iex 或 Invoke-Expression cmdlet，后者将执行脚本的内容并开始 Chocolatey 包管理器的安装。\n允许 PowerShell 安装 Chocolatey。 等到安装完成后，你可以使用 choco 命令开始安装其他工具。\n如果你以后需要随时升级 Chocolatey，请运行以下命令：\nchoco upgrade chocolatey 安装包管理器后，你可以安装 Go 编程环境所需的其余部分。\n第三步 — 安装文本编辑器 Nano (可选) # 在这一步中，你将安装 nano，这是一个使用命令行界面的文本编辑器。 你可以使用 nano 直接在 PowerShell 中编写程序。 这不是强制性步骤，因为你也可以使用带有图形用户界面的文本编辑器，例如 Notepad 。 本教程推荐使用 nano，因为它将帮助你习惯使用 PowerShell。\n使用 Chocolatey 安装 nano：\nchoco install -y nano -y 标志会自动确认你要运行脚本，而不会提示你确认。\n安装 nano 后，你可以使用 nano 命令创建新的文本文件。 你将在本教程后面使用它来编写你的第一个 Go 程序。\n第四步 — 安装 Go # 就像你在上一步中安装 nano 一样，你将使用 Chocolatey 安装 Go：\nchoco install -y golang 注意： 因为 go 是一个很小的词，所以使用 golang 作为安装包的术语， 这也是在互联网上搜索 Go 相关文章时的常见做法。 Golang 一词源于 Go 的域，即 golang.org\nPowerShell 安装 Go 的过程中，会在 PowerShell 中生成输出内容。 安装完成后，你应该会看到以下输出：\nOutput Environment Vars (like PATH) have changed. Close/reopen your shell to see the changes (or in powershell/cmd.exe just type `refreshenv`). The install of golang was successful. Software installed as \u0026#39;msi\u0026#39;, install location is likely default. Chocolatey installed 1/1 packages. See the log for details (C:\\ProgramData\\chocolatey\\logs\\chocolatey.log). 安装完成后，你可以确认下 Go 是否已安装。 要查看更改，请以管理员身份关闭并重新打开 PowerShell，然后检查本地计算机上可用的 Go 版本：\ngo version 你将得到类似以下内容的输出：\noutput go version go1.12.1 windows/amd643.7.0 安装 Go 后，你可以为开发项目设置工作区。\n第五步 — 创建你的 Go 工作区 # 现在你已经安装了 Chocolatey、nano 和 Go，可以接着创建你的编程工作区。\nGo 语言的工作区在其根目录下包含两个目录：\nsrc: 该目录包含 Go 的源文件。所谓源文件就是你用 Go 编程语言写的文件。源文件被 Go 编译器构建成可执行的二进制文件。 bin: 该目录包含了 Go 工具构建和安装的可执行文件。可执行文件就是运行在你系统上并执行任务的二进制文件。通常是你的源码或者是其他下载的 Go 源代码编译的程序。 src 子目录可能包含多个版本控制仓库（例如 Git, Mercurial 和 Bazaar）。当你引入第三方库的时候，你可以看到类似 github.com, golang.org 或其他目录，如果你使用的是 github.com 之类的代码仓库，你还将把项目和源文件放在该目录下。 我们将在此步骤的后面部分探讨这个概念。这允许你在你的项目中规范导入代码。 规范导入就是引用完全限定包的导入，例如 github.com/digitalocean/godo 。\n下面是典型的工作区目录结构：\n. ├── bin │ ├── buffalo # command executable │ ├── dlv # command executable │ └── packr # command executable └── src └── github.com └── digitalocean └── godo ├── .git # Git repository metadata ├── account.go # package source ├── account_test.go # test source ├── ... ├── timestamp.go ├── timestamp_test.go └── util ├── droplet.go └── droplet_test.go 从 1.8 开始，Go 工作区的默认目录是用户的 home 目录，并带有 go 子目录，或者是 $HOME/go 目录。 如果你使用的是早于 1.8 的 Go 版本，目前认为最佳做法是为你的工作区使用 $HOME/go 位置。\n使用下面命令导航到 $HOME 目录：\ncd $HOME 接下来，为你的 Go 工作区创建目录结构：\nmkdir go/bin, go/src 以上命令将确保下面的目录结构各就各位：\n└── $HOME └── go ├── bin └── src 在 Go 1.8 之前，需要设置一个名为 $GOPATH 的本地环境变量。 $GOPATH 告诉编译器在哪里可以找到导入的第三方源代码，同样包括任何你写的本地源代码。 虽然不再明确要求它，但它仍然被认为是一种很好的做法，因为许多第三方工具仍然依赖于设置的这个变量。\n由于你使用 Chocolatey 进行安装，因此应该已经设置了此环境变量。 你可以使用以下命令验证这一点：\n$env:GOPATH 你应该会看到以下输出，其中 sammy 代替了你的用户名：\noutput C:\\Users\\sammy\\go 当 Go 编译和安装工具时，会将他们放在 $GOPATH/bin 目录。为方便起见，通常将工作区的 /bin 子目录添加到 ~/.profile 中的 PATH 中。你可以使用 PowerShell 中的 setx 命令执行此操作：\nsetx PATH \u0026#34;$($env:path);$GOPATH\\bin\u0026#34; 这将允许你在系统上的任何位置运行通过 Go 工具编译或下载的任何程序。\n现在你已经创建了工作区的根目录并设置了 $GOPATH 环境变量，你可以根据以下目录结构创建你未来的项目。 此示例假设你使用 github.com 作为仓库：\n$GOPATH/src/github.com/username/project 例如，如果你正在开发 https://github.com/digitalocean/godo 项目，它将存储在以下目录中：\n$GOPATH/src/github.com/digitalocean/godo 该项目结构使项目可以通过 go get 工具使用。它也有助于以后的可读性。 你可以通过使用 go get 命令并获取 godo 库来验证这一点：\ngo get github.com/digitalocean/godo 注意： 如果你没有安装 git，Windows 会打开一个对话框询问你是否要安装它。 单击 Yes 继续并按照安装说明进行操作。\n你可以通过列出目录来检查下看看是否成功下载了 godo包：\nls $env:GOPATH/src/github.com/digitalocean/godo 你应该看到类似下面这样的输出：\noutput Directory: C:\\Users\\sammy\\go\\src\\github.com\\digitalocean\\godo Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 4/10/2019 2:59 PM util -a---- 4/10/2019 2:59 PM 9 .gitignore -a---- 4/10/2019 2:59 PM 69 .travis.yml -a---- 4/10/2019 2:59 PM 1592 account.go -a---- 4/10/2019 2:59 PM 1679 account_test.go -rw-r--r-- 1 sammy staff 2892 Apr 5 15:56 CHANGELOG.md -rw-r--r-- 1 sammy staff 1851 Apr 5 15:56 CONTRIBUTING.md . . . -a---- 4/10/2019 2:59 PM 5076 vpcs.go -a---- 4/10/2019 2:59 PM 4309 vpcs_test.go 在这一步中，你创建了一个 Go 工作区并且配置了必要的环境变量。下一步你将使用一些代码来测试下工作区。\n第六步 — 创建一个简单的程序 # 现在你已经设置了工作区，来创建一个 “Hello, World!” 程序吧。这可以检验工作区配置是否正确，并且给你一个更加熟悉 Go 的机会。因为我们创建的是单个 Go 源文件，而不是实际项目，所以我们不需要在工作区中执行此操作。\n在你的 home 目录，打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在 nano 中打开文本文件后，输入你的程序代码：\nhello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y，然后按 ENTER 退出。\n该代码使用了 fmt 包并且使用 Hello, World! 作为参数调用了 Println 函数。这将导致短语 Hello, World! 在程序运行时打印到终端上。\n退出 nano 返回 shell 之后，运行程序：\ngo run hello.go 你刚刚创建的 hello.go 程序应该会在 PowerShell 产生以下输出：\noutput Hello, World! 在此步骤中，你使用了一个简单小程序来验证是否正确配置了 Go 工作区。\n总结 # 恭喜！至此，你已经在 Ubuntu 机器上设置了 Go 编程工作区，可以开始写项目了！\n"},{"id":3,"href":"/How-To-Code-in-Go/docs/04-How_To_Write_Your_First_Program_in_Go_DigitalOcean/","title":"04 How to Write Your First Program in Go Digital Ocean","section":"Docs","content":" 如何用 Go 编写你的第一个程序 # 前言 # “Hello, World!” 程序是计算机编程中的经典且历史悠久的传统。 对于初学者来说，这是一个简单而完整的第一个程序，它是一个确保你的环境配置正确的好方法。\n本教程将引导你在 Go 中创建此程序。 但是，为了使程序更有趣，你将修改传统的 “Hello, World!” 程序，以便它可以询问用户的姓名。 然后，你将在回复中使用该姓名。 完成本教程后，你将拥有一个运行起来如下所示的程序：\noutput Please enter your name. Sammy Hello, Sammy! I\u0026#39;m Go! 安装前提 # 在开始本教程之前，你需要一个本地的 Go 开发环境。你可以按照下面其中一个教程在你的计算机上进行设置：\n如何在 macOS 上安装 Go 和设置本地编程环境 如何在 Ubuntu 18.04 上安装 Go 和设置本地编程环境 如何在 Windows 10 上安装 Go 和设置本地编程环境 第一步 — 编写最基本的 “Hello, World!” 程序 # 为了编写 Hello, World!” 程序，请打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在 nano 中打开文本文件后，输入你的程序代码：\nhello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 让我们分解下代码的各个部分。\npackage 是一个 Go 关键字，它定义了这个文件属于哪个代码包。 每个文件夹只能有一个包，并且文件夹中每个 .go 文件必须在其文件顶部声明相同的包名。 在这个例子中，代码属于 main 包。\nimport 是一个 Go 关键字，它告诉 Go 编译器你想在这个文件中使用哪些其他包。 在这里，你导入标准库附带的 fmt 包。 fmt 包提供了在开发时很有用的格式化和打印功能。\nfmt.Println 是一个 Go 函数，位于 fmt 包中，它告诉计算机将一些文本打印到屏幕上。\n在 fmt.Println 函数后面跟着一系列字符，例如 \u0026quot;Hello, World!\u0026quot;，用引号括起来。 引号内的任何字符都称为 string。 fmt.Println 函数会在程序运行时将此字符串打印到屏幕上。\n按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y，然后按 ENTER 退出。\n现在你可以试试你的程序了。\n第二步 — 运行 Go 程序 # 你的 “Hello, World!” 程序写好之后，你就可以运行程序了。你可以用 go 命令然后后面跟着你刚刚创建的文件名。\ngo run hello.go 程序执行后会显示以下输出：\noutput Hello, World! 让我们来探索下实际发生了什么。\nGo 程序在运行之前必须要先编译。当你使用文件名调用 go run 时，在本例中为 hello.go，go 命令将 编译 应用程序，然后运行生成的二进制文件。 对于用 编译型 编程语言编写的程序，编译器将获取程序的源代码并生成另一种类型的低级代码（例如机器代码）来生成可执行程序。\nGo 应用程序需要一个 main 包和一个确切的 唯一 main() 函数，作为应用程序的入口点。 main 函数不接受任何参数并且不返回任何值。 相反，它告诉 Go 编译器应该将包编译为可执行包。\n编译后，代码通过在 main 包中输入 main() 函数来执行。 它通过_调用_ fmt.Println 函数来执行fmt.Println(\u0026quot;Hello, World!\u0026quot;) 行。 Hello, World! 的字符串值被传递给函数。 在此示例中，字符串 Hello, World! 也称为 参数，因为它是传递给方法的值。\nHello, World! 两边的引号不会打印到屏幕上，因为你用它们告诉 Go 你的字符串在哪里开始和结束。\n在这一步中，你已经用 Go 编程创建了一个有效的“Hello, World！” 。 在下一步中，你将探索如何使程序更具交互性。\n第三步 — 提示用户输入 # 每次运行程序时，它都会产生相同的输出。 在此步骤中，你可以把提示用户输入他们的姓名添加到程序中。 然后，你将在输出中使用他们的名字。\n不要修改现有程序，而是使用 nano 编辑器创建一个名为 greeting.go 的新程序：\nnano greeting.go 首先，添加这段代码，提示用户输入他们的姓名：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) } 再一次，你使用 fmt.Println 函数将一些文本打印到屏幕上。\n现在添加下面高亮行代码来存储用户的输入：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) var name string } var name string 行将使用 var 关键字 创建一个新变量。 你将变量命名为 “name” ，它的类型为 “string” 。\n然后添加下面高亮行代码来捕捉用户的输入：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) var name string fmt.Scanln(\u0026amp;name) } fmt.Scanln 方法告诉计算机等待以换行符或 (\\n) 字符结尾的键盘输入。 该方法会暂停程序，允许用户输入他们想要的任何文本。 当用户按下键盘上的 ENTER 键时，程序将继续。 然后捕获所有点击，包括 ENTER ，然后将其转换为字符串。\n你想在程序中使用这些字符输出，因此你通过将这些字符 写入 到被称为 name 的字符串 变量 中来保存这些字符。 Go 将该字符串存储在计算机的内存中，直到程序完成运行。\n最后，在程序中添加以下高亮行来打印输出：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) var name string fmt.Scanln(\u0026amp;name) fmt.Printf(\u0026#34;Hi, %s! I\u0026#39;m Go!\u0026#34;, name) } 这一次，你使用的是 fmt.Printf，而不是再次使用 fmt.Println 方法。 fmt.Printf 函数接受一个字符串，并使用特殊的打印 占位符, (%s)，将 name 的值注入到字符串中。 你这样做是因为 Go 不支持 字符串插值 ，它可以让你获取分配给变量的值并将其插入在字符串中。\n按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y。\n现在运行程序。 系统将提示你输入你的姓名，因此请输入并按 ENTER。 输出可能不完全符合你的预期：\noutput Please enter your name. Sammy Hi, Sammy ! I\u0026#39;m Go! 而不是 Hi, Sammy! I'm Go!，名字后面有一个换行符。\n该程序捕获了我们 所有 的点击，包括我们按下以告诉程序继续的 ENTER 键。 在字符串中，按 ENTER 键会创建一个特殊字符，该字符会创建一个新行。 该程序的输出完全按照你的要求执行； 它正在显示你输入的文本，包括新行。 这不是你期望的输出，但你可以使用其他功能对其进行修复。\n在你的编辑器里面打开 greeting.go\nnano greeting.go 在你的程序里定位到下面这一行：\n... fmt.Scanln(\u0026amp;name) ... 在其后面增加下面一行：\nname = strings.TrimSpace(name) 上面使用了 Go 标准库 strings 包中的 TrimSpace 函数，来处理你使用 fmt.Scanln 捕获的字符串。 strings.TrimSpace 函数从字符串的开头和结尾删除任何空格字符，包括换行符。 在这种情况下，它会删除你按下 ENTER 时创建的字符串末尾的换行符。\n要使用 strings 包，你需要在程序顶部导入它。\n在你的程序找到下面这几行代码：\nimport ( \u0026#34;fmt\u0026#34; ) 增加下面几行来导入 strings 包：\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) 你的程序现在包含了以下代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) var name string fmt.Scanln(\u0026amp;name) name = strings.TrimSpace(name) fmt.Printf(\u0026#34;Hi, %s! I\u0026#39;m Go!\u0026#34;, name) } 按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y。\n再次运行程序：\ngo run greeting.go 这一次，在你输入你的名字并按 ENTER 后，你会得到预期的输出：\noutput Please enter your name. Sammy Hi, Sammy! I\u0026#39;m Go! 你现在有一个 Go 程序，它接受用户的输入并将其打印回屏幕。\n总结 # 在本教程中，你编写了 一个 “Hello, World！” 程序，可以从用户那里获取输入、处理结果并显示输出。 既然你有一个基本程序可以使用，请尝试进一步扩展你的程序。 例如，询问用户最喜欢的颜色，让程序说它最喜欢的颜色是红色。 你甚至可以尝试使用相同的技术来创建一个简单的 Mad-Lib 程序。\n"},{"id":4,"href":"/How-To-Code-in-Go/docs/05-Understanding_the_GOPATH/","title":"05 Understanding the Gopath","section":"Docs","content":" 理解 GOPATH # 介绍 # 本文将带领你了解什么是 GOPATH，它是如何工作的，以及如何设置它。这是设置 Go 开发环境以及理解 Go 如何查找、安装和构建源文件的关键步骤。在本文中，我们将使用 GOPATH 来指代我们将要讨论的文件夹结构的概念。我们将使用 $GOPATH 来指代 Go 用来查找文件夹结构的环境变量。\nGo 工作区 是 Go 管理源码文件、编译的二进制文件和用于后续更快编译的缓存对象。虽然可能有多个空间，但只有一个 Go 工作区是典型的，也是被建议的使用方式。GOPATH 充当工作区的根文件夹。\n设置 $GOPATH 环境变量 # $GOPATH 环境变量列出了 Go 用来寻找 Go 工作区的地方。\n默认情况下，Go 假设 GOPATH 位于 $HOME/go，其中 $HOME 是电脑上上我们帐户的根目录。我们可以通过设置 $GOPATH 环境变量来修改它。为了进一步的研究，请参考在 Linux 中阅读和设置环境变量的教程。\n想要了解更多关于设置 $GOPATH 变量的信息，可以参考 Go 文档。\n此外，本系列教程 简单介绍了安装 Go 和设置 Go 开发环境的方法。\n$GOPATH 不是 $GOROOT # $GOROOT 是 Go 的代码、编译器和工具所在的地方ーー这不是我们的源代码。$GOROOT 通常类似于 /usr/local/go。我们的 $GOPATH 通常类似于 $HOME/go。\n虽然我们不再需要专门设置 $GOROOT 变量，但它仍然在旧材料中被引用。\n现在，让我们讨论一下 Go Workspace 的结构。\nGo 工作区剖析 # 在一个 Go Workspace 或者 GOPATH 中，有三个目录: bin、 pkg 和 src。这些目录中的每一个对于 Go 工具链都有特殊的意义。\n. ├── bin ├── pkg └── src └── github.com/foo/bar └── bar.go 让我们来看看每个目录。\n$GOPATH/bin 目录是 Go 放置 go install 编译的二进制文件的地方。我们的操作系统使用 $PATH 环境变量在没有完整路径的情况下找到二进制应用程序并执行。建议将此目录添加到全局 $PATH 变量中。\n例如，如果我们不在 $PATH 中添加 $GOPATH/bin 来执行一个程序，我们需要运行:\n$GOPATH/bin/myapp 当 $GOPATH/bin 被添加到 $PATH 时，我们可以像这样进行同样的调用:\n$ myapp $GOPATH/pkg 目录是 Go 存储预编译目标文件的地方，以加速程序的后续编译。通常，大多数开发人员不需要访问这个目录。如果遇到编译问题，可以安全地删除该目录，然后 Go 将重新生成该目录。\n在 src 目录是我们放置所有的 .go 文件，或源代码的地方。这不应与 Go 工具使用的源代码混淆，后者位于 $GOROOT 中。在编写 Go 应用程序、包和库时，我们将把这些文件放在 $GOPATH/src/path/to/code 下。\n什么是包 # Go 代码是以包的形式组织的。包表示磁盘上单个目录中的所有文件。一个目录只能包含来自同一包的某些文件。包与所有用户编写的 Go 源文件一起存储在 $GOPATH/src 目录下。我们可以通过导入不同的软件包来理解软件包解析。\n如果我们的代码是 $GOPATH/src/blue/red，那么它的包名应该是 red。\nimport \u0026#34;blue/red\u0026#34; red 包的导入声明如下:\n存储在源代码仓库中的软件包，如 GitHub 和 BitBucket，将仓库的完整位置作为导入路径的一部分。\n例如，我们可以使用下面的导入路径来导入 https://github.com/gobuffalo/buffalo 的源代码:\nimport \u0026#34;github.com/gobuffalo/buffalo\u0026#34; 因此，这个源代码应该位于磁盘上的下列位置:\n$GOPATH/src/github.com/gobuffalo/buffalo 结论 # 在这篇文章中，我们讨论了 GOPATH 作为一个文件夹的集合，Go 期望我们的源代码保存在里面，以及这些文件夹是什么，它们包含什么。我们讨论了如何通过设置 $GOPATH 环境变量，将默认的 $HOME/go 位置改为用户选择的位置。最后，我们讨论了 Go 如何在该文件夹结构中搜索包。\n在 Go 1.11 中引入的 Go Modules旨在取代 Go Workspaces 和 GOPATH。虽然建议开始使用模块，但是有些环境(如公司环境)，可能还没有准备好使用模块。\nGOPATH 是 Go 设置中比较棘手的一个方面，但是一旦设置好了，我们通常会忘记它。\n"},{"id":5,"href":"/How-To-Code-in-Go/docs/06-How_To_Write_Comments_in_Go/","title":"06 How to Write Comments in Go","section":"Docs","content":" 如何在 Go 中写注释 # 介绍 # 注释是存在于计算机程序中，被编译器和解释器忽略的代码行。在程序中包含注释使得代码对于人类来说更具可读性，因为它提供了一些关于程序的每个部分正在做什么的信息或解释。\n根据你程序的目的，注释可以作为你自己的笔记或者提醒，或者它们可以是为了其他程序员能够理解你的代码在做什么而写的。\n一般来说，在写或者更新程序的时候写评论是个不错的主意，因为以后很容易忘记你的思维过程，而且以后写的评论长期来看可能没那么有用。\n注释语法 # Go 中的注释以一组向前斜杠（//）开始，一直到行尾。在前向斜杠集合之后有一个空白符号是惯用的方式。\n一般来说，评论看起来是这样的:\n// This is a comment 注释不会执行，因此在运行程序时没有注释的指示。注释在源代码中供人阅读，而不是供计算机执行。\n在一个 “Hello, World!” 的程序中，注释可能如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { // Print “Hello, World!” to console fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 在一个迭代切片的 for 循环时，注释可能如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { // Define sharks variable as a slice of strings sharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;} // For loop that iterates over sharks list and prints each string item for _, shark := range sharks { fmt.Println(shark) } } 注释应该与注释代码的缩进相同。也就是说，一个没有缩进的函数定义将有一个没有缩进的注释，并且下面的每个缩进级别中，注释与所注释的代码对齐。\n比如，下面是 main 函数如何注释，以及各个缩进级别的代码和注释：\npackage main import \u0026#34;fmt\u0026#34; const favColor string = \u0026#34;blue\u0026#34; func main() { var guess string // Create an input loop for { // Ask the user to guess my favorite color fmt.Println(\u0026#34;Guess my favorite color:\u0026#34;) // Try to read a line of input from the user. Print out the error 0 if _, err := fmt.Scanln(\u0026amp;guess); err != nil { fmt.Printf(\u0026#34;%s\\n\u0026#34;, err) return } // Did they guess the correct color? if favColor == guess { // They guessed it! fmt.Printf(\u0026#34;%q is my favorite color!\\n\u0026#34;, favColor) return } // Wrong! Have them guess again. fmt.Printf(\u0026#34;Sorry, %q is not my favorite color. Guess again.\\n\u0026#34;, guess) } } 编写注释是为了帮助程序员，无论是最初的程序员还是在项目中使用或合作的其他人。如果注释不能与代码库一起适当地维护和更新，那么对于编写与代码相矛盾或将与将来的代码相矛盾的注释，不如不包含注释。\n在给代码注释时，你应该回答代码背后的 原因，而不是 什么 或 怎么 回事。除非代码特别复杂，否则查看代码通常可以回答是 什么 或者 怎么 的问题，这就是为什么注释通常是围绕 为什么 的原因。\n注释块 # 注释块可以用来解释更复杂的代码或那些读者可能并不熟悉的代码。\n你可以用两种方式在 Go 中创建注释块。第一种方法是使用一组双向前斜杠，并在每行中重复它们。\n// First line of a block comment // Second line of a block comment 第二种是使用开始标记（/*）和结束标记（*/）。为了记录代码，惯例方式是使用 // 语法。你只能使用 /* ... */ 语法进行调试，我们将在本文后面讨论这个问题。\n/* Everything here will be considered a block comment */ 在这个例子中，注释块定义了 MustGet() 函数中发生的事情：\n// MustGet will retrieve a url and return the body of the page. // If Get encounters any errors, it will panic. func MustGet(url string) string { resp, err := http.Get(url) if err != nil { panic(err) } // don\u0026#39;t forget to close the body defer resp.Body.Close() var body []byte if body, err = ioutil.ReadAll(resp.Body); err != nil { panic(err) } return string(body) } 在 Go 中导出函数的开头经常会看到注释块; 这些注释也是生成代码文档的元素。当操作不那么直观，而需要完全解释时，也会使用注释块。除了记录函数之外，你应该尽量避免对代码进行过度注释，并相信其他程序员能够理解 Go，除非你是为特定的用户编写代码。\n内联注释 # 内联注释出现在语句的同一行，位于代码本身之后。像其他注释一样，它们以一组向前斜杠开始。同样，不需要在前向斜杠后面加空格，但是惯例是这样做的。\n一般来说，内联注释是这样的:\n[code] // Inline comment about the code 内联注释应该谨慎使用，但是对于解释代码中棘手或不明显的部分来说可能是有效的。如果你认为自己将来可能不记得正在编写的代码中的某一行，或者你正在与一个你认识的人合作，而这个人可能并不熟悉代码的所有方面，那么它们也会很有用。\n例如，如果你在你的 Go 程序中没有使用大量的数学，你或者你的合作者可能不知道下面的代码创建了一个复杂的数字，所以你可能需要包含一个关于这个的内联注释:\nz := x % 2 // Get the modulus of x 你也可以使用行内注释来解释做某事背后的原因，或者提供一些额外的信息，比如:\nx := 8 // Initialize x with an arbitrary number 你应该只在必要的时候，并且当它们可以为阅读程序的人提供有用的指导时，使用内联注释。\n注释测试代码 # 除了使用注释作为记录代码的方式之外，还可以使用开始标记（/*）和结束标记（*/）来创建块注释。这允许你在测试或调试当前正在创建的程序时注释掉不想执行的代码。也就是说，当你在实现新代码后遇到错误时，你可能希望对其中的一些代码行进行注释，以查看是否能够解决这个确切的问题。\nUsing the /* and */ tags can also allow you to try alternatives while you’re determining how to set up your code. You can also use block comments to comment out code that is failing while you continue to work on other parts of your code. 在决定如何设置代码时，使用 /* 和 */ 标记还可以让你尝试其他选择。你也可以使用注释块来注释失败的代码，同时继续处理代码的其他部分。\n// Function to add two numbers func addTwoNumbers(x, y int) int { sum := x + y return sum } // Function to multiply two numbers func multiplyTwoNumbers(x, y int) int { product := x * y return product } func main() { /* In this example, we\u0026#39;re commenting out the addTwoNumbers function because it is failing, therefore preventing it from executing. Only the multiplyTwoNumbers function will run a := addTwoNumbers(3, 5) fmt.Println(a) */ m := multiplyTwoNumbers(5, 9) fmt.Println(m) } 注意: 注释掉代码只能用于测试目的。不要在最终的程序中保留注释掉的代码片段。\n使用 /* 和 */ 标记注释代码可以让你尝试不同的编程方法，并通过系统地注释和运行程序的各个部分来帮助你找到错误的源代码。\n结论 # 在你的 Go 程序中使用注释有助于使你的程序对于人类来说更具可读性，包括未来的你自己。添加适当相关和有用的注释可以使其他人更容易地与你合作编程项目，并使代码的价值更加明显。\n在 Go 中正确注释代码还可以让你用到 Godoc 工具。Godoc 是一个从代码中提取注释并为 Go 程序生成文档的工具。\n"},{"id":6,"href":"/How-To-Code-in-Go/docs/07-Understanding_Data_Types_in_Go/","title":"07 Understanding Data Types in Go","section":"Docs","content":" 理解 Go 的数据类型 # 介绍 # 数据类型是指在编写程序时特定变量存储的值的类型。数据类型还决定对数据可以执行哪些操作。\n在本文中，我们将介绍 Go 本身的重要数据类型。本文并不是对数据类型的详尽调查，但将帮助你熟悉 Go 中可用的选项。理解一些基本数据类型将可以让你能够编写更清晰的代码，从而更有效地执行。\n背景 # 了解数据类型的一种方法是考虑我们在现实世界中使用的不同类型的数据。现实世界中数据的一个例子是数字: 例如，我们可以使用无符号整数（0，1，2，\u0026hellip;）、有符号整数（\u0026hellip; ，-1，0，1，\u0026hellip;）和无理数（π）。\n通常，在数学中，我们可以把不同类型的数字组合起来，来得到某个答案。例如，我们可以把 5 加到 π 上:\n5 + π 我们可以把这个方程式作为答案因为存在无理数，也可以把 π 近似舍入到十进制的缩写数字，再把这些数字相加:\n5 + π = 5 + 3.14 = 8.14 但是，如果我们开始尝试用另一种数据类型，比如单词来计算数字，就变得不那么有意义了。我们如何解下面的公式呢？\nshark + 8 对于计算机来说，每种数据类型区别很大，就像文字和数字一样。因此，对于不同的数据类型的赋值和修改操作，我们必须谨慎。\n整数 # 和数学一样，计算机编程中的 整数 可以是正数、负数或者 0（\u0026hellip; -1,0,1，\u0026hellip;）。在 Go 中，整数被称为 int。与其他编程语言一样，不应该在四位数或更多的数字中使用逗号，所以在程序中写入 1,000 时，请写为 1000。\n我们可以简单向下面这种方式打印一个整数：\nfmt.Println(-459) output -459 或者，我们可以声明一个变量，在这个例子中是我们用来表示和操作数字的符号，如：\nvar absoluteZero int = -459 fmt.Println(absoluteZero) output -459 我们也可以在 Go 中对整数进行计算。在下面的代码块中，我们将使用 := 分配符来声明和实例化变量 sum：\nsum := 116 - 68 fmt.Println(sum) output 48 如输出所示，数学算子 - 从 116 中减去整数 68，得到 48。你将在声明变量的数据类型部分了解有关变量声明的更多信息。\n在 Go 程序中，有多种方式可以使用整数。随着你继续学习 Go，你将有很多机会使用整数并在此数据类型的知识基础上进行构建。\n浮点数 # 浮点数 或 float 用于表示不能表示为整数的实数。实数包括所有的有理数和无理数，因此，浮点数可以包含小数部分，比如 9.0 或 -116.42。Go 程序中的浮点数，可以认为是一个包含小数点的数字。\n就像我们处理整数一样，我们可以用这样一种简单的方式打印出一个浮点数:\nfmt.Println(-459.67) output -459.67 我们也可以声明一个变量表示浮点数，如：\nabsoluteZero := -459.67 fmt.Println(absoluteZero) output -459.67 和整数类似，我们也可以在 Go 中计算浮点数：\nvar sum = 564.0 + 365.24 fmt.Println(sum) output 929.24 对于整数和浮点数，记住 3 ≠ 3.0 很重要，因为 3 表示的是一个整数，而 3.0 表示的是一个浮点数。\n数字类型的大小 # 除了整数和浮点数之间的区别之外，Go 还有两种类型的数值数据，这两种数值数据通过其大小的静态或动态特性进行区分。第一种类型是与_体系结构无关_的类型，这意味着无论代码运行在哪台机器上，以位为单位的数据的大小都不会改变。\n今天的大多数系统架构都是32位或64位的。例如，你可能正在一台现代的 Windows 笔记本电脑上开发，其操作系统运行在 Windows 64位架构上。然而，如果你正在为一个像健身手表这样的设备开发应用时，你可能正在使用一个32位的架构。如果你使用像 int32 这样独立于体系架构的类型，那么无论你为何种体系架构编译，该类型都将具有一个固定的大小。\n第二种是_实现专用_的类型。在这种类型中，位大小可以根据程序所在的体系架构的不同而变化。例如，如果我们使用 int 类型，当 Go 为 32 位架构编译时，数据类型的大小将为 32 位。如果程序是为 64 位架构编译的，那么变量的大小是 64 位。\n除了数据类型大小不同外，类似整数的类型还有两种基本类型: 有符号_和_无符号。int8 是一个有符号整数，可以取 -128 到 127 之间的值。uint8 是一个无符号整数，只能取 0 到 255 之间的正数值。\n取值范围与位的大小有关。对于二进制数据，8 位可以表示总共 256 个不同的值。因为 int 类型需要同时支持正值和负值，所以 8 位整数（int8）的范围是 -128 到 127，总共有 256 个不同的值。\nGo 具有以下与架构无关的整数类型:\nuint8 unsigned 8-bit integers (0 to 255) uint16 unsigned 16-bit integers (0 to 65535) uint32 unsigned 32-bit integers (0 to 4294967295) uint64 unsigned 64-bit integers (0 to 18446744073709551615) int8 signed 8-bit integers (-128 to 127) int16 signed 16-bit integers (-32768 to 32767) int32 signed 32-bit integers (-2147483648 to 2147483647) int64 signed 64-bit integers (-9223372036854775808 to 9223372036854775807) 浮点数和复数的大小也是变化的：\nfloat32 IEEE-754 32-bit floating-point numbers float64 IEEE-754 64-bit floating-point numbers complex64 complex numbers with float32 real and imaginary parts complex128 complex numbers with float64 real and imaginary parts 还有一些数字类型的别名，通过分配有用的名称来表示特定的数据类型：\nbyte alias for uint8 rune alias for int32 byte 别名的目的是清楚地表明程序何时使用字节作为字符串元素的常用计算度量，而不是与字节数据度量无关的小整数。尽管程序编译后 byte 和 uint8 是相同的，但 byte 通常用于表示数字形式的字符数据，而 uint8 则用于表示程序中的数字。\nrune 别名有点不同。如果 byte 和 uint8 是完全相同的数据，那么 rune 可以是一个字节或四个字节，这个范围由 int32 决定。rune 用来表示 Unicode 字符，而只有 ASCII 字符可以由 int32 数据类型单独表示。\n此外，Go 还有以下特定实现的类型:\nuint unsigned, either 32 or 64 bits int signed, either 32 or 64 bits uintptr unsigned integer large enough to store the uninterpreted bits of a pointer value 特定实现的类型大小将由程序编译的架构决定。\n选择数值数据类型 # 选择正确的大小通常更多地取决于编程所针对的目标架构的性能，而不是所处理的数据的大小。但是，无需知道性能对程序的具体影响，你可以在动手前遵循一些基本指导原则。\n正如本文前面所讨论的，有与架构无关的类型和特定实现的类型。对于整数数据，Go 中通常使用 int 或 uint 等实现类型，而不是 int64 或 uint64。这通常会为你的目标架构带来最快的处理速度。例如，如果使用 int64 并将其编译为 32 位架构上的应用，那么处理这些值所需的时间至少多花一倍，因为在该架构下移动数据需要额外的 CPU 周期。如果使用 int，程序会将其定义为 32 位体系结构的 32 位大小，并且处理起来会快得多。\n如果你知道你不会超过特定的大小范围，那么选择与体系结构无关的类型既可以提高速度，又可以减少内存使用。例如，如果你知道你的数据不会超过 100，而且只是一个正数，那么选择 uint8 会使你的程序更有效率，因为它需要更少的内存。\n既然我们已经了解了数值数据类型的一些可能范围，接下来让我们看看如果在程序中超过这些范围会发生什么。\n溢出 vs. 折叠 # 当你试图存储一个比设计存储的数据类型更大的值时，Go 有可能会_溢出_和_折叠_一个数字，这取决于这个值是在编译时还是在运行时计算的。当程序在尝试构建程序时发现错误时，就会发生编译时错误。程序编译完成后，在实际执行过程中会发生的是运行时错误。\n在下面的例子中，我们将 maxUint32 设置为它的最大值:\npackage main import \u0026#34;fmt\u0026#34; func main() { var maxUint32 uint32 = 4294967295 // Max uint32 size fmt.Println(maxUint32) } 编译后的运行结果如下：\noutput 4294967295 如果我们在运行时对该值加 1，它将会被折叠为 0：\noutput 0 另一方面，我们修改程序，在分配值且编译前加 1：\npackage main import \u0026#34;fmt\u0026#34; func main() { var maxUint32 uint32 = 4294967295 + 1 fmt.Println(maxUint32) } 在编译时，如果编译器可以确定一个值将太大而无法保存在指定的数据类型中时，它将抛出 overflow 溢出错误。这意味着计算的值对于指定的数据类型来说太大了。\n因为编译器可以确定它会溢出值，它现在会抛出一个错误:\noutputprog.go:6:36: constant 4294967296 overflows uint32 理解数据的边界将帮助你避免将来程序中可能出现的错误。\n现在我们已经介绍了数值类型，让我们来看看如何存储布尔值。\n布尔值 # boolean 数据类型可以从两个值中取值，即 true 或 false，在声明为数据类型时定义为 bool。布尔值用于表示与数学逻辑分支相关的真值，它为计算机科学中的算法提供信息。\n值 true 和 false 将始终分别使用小写的 t 和 f，因为它们是 Go 中预先声明的标识符。\n许多数学运算给出的答案要么是真要么是假：\n大于 500 \u0026gt; 100 true 1 \u0026gt; 5 false 小于 200 \u0026lt; 400 true 4 \u0026lt; 2 false 等于 5 = 5 true 500 = 400 false 与数字相似，我们可以用变量保存布尔值：\nmyBool := 5 \u0026gt; 8 接下来我们可以调用 fmt.Println() 函数来打印布尔值：\nfmt.Println(myBool) 因为 5 小于 8， 我们将会得到下面的输出结果：\noutput false 随着你在 Go 中编写越来越多的程序，你会越来越熟悉布尔值是如何工作的，以及不同的函数和操作计算为 true 或 false 会如何改变程序的进程。\n字符串 # 字符串是由一个或多个字符（字母、数字、符号）组成的序列，这些字符可以是常量，也可以是变量。字符串存在于 Go 中的反引号 ``` 或 \u0026quot; 中，并且根据使用的引号具有不同的特征。\n如果使用反引号，就是创建了一个_原始_字符串。如果使用双引号，就是创建了一个_解释_字符串。\n原始字符串 # 原始字符串文字是反引号之间的字符序列，通常称为反引号。在引号中，除了引号字符本身之外，反引号之间的任何字符都会显示。\na := `Say \u0026#34;hello\u0026#34; to Go!` fmt.Println(a) output Say \u0026#34;hello\u0026#34; to Go! 通常，反斜杠用于表示字符串中的特殊字符。例如，在解释字符串中，\\n 表示字符串中的新行。但是，反斜杠在原始字符串中没有特殊含义:\na := `Say \u0026#34;hello\u0026#34; to Go!\\n` fmt.Println(a) 因为反斜杠在字符串文字中没有特殊含义，它实际上会打印出 \\n 的值，而不是创建一个新的行:\noutput Say \u0026#34;hello\u0026#34; to Go!\\n 原始字符串也可以用来创建多行字符串：\na := `This string is on multiple lines within a single back quote on either side.` fmt.Println(a) output This string is on multiple lines within a single back quote on either side. 在前面的代码块中，新行会按字面意思从输入传递到输出。\n解释字符串 # 解释字符串是双引号之间的字符序列，如 \u0026quot;bar\u0026quot; 中所示。在引号中，除了换行符和非转义双引号外，任何字符都可以出现。要在解释字符串中显示双引号，可以使用反斜杠作为转义字符，如下所示:\na := \u0026#34;Say \\\u0026#34;hello\\\u0026#34; to Go!\u0026#34; fmt.Println(a) output Say \u0026#34;hello\u0026#34; to Go! 你几乎总会使用解释字符串，因为它们允许在其中使用转义字符。想要了解更多关于字符串使用的信息，请查看Go 中使用字符串的简介。\nUTF-8 字符的字符串 # UTF-8 是一种编码方案，用于将可变宽度字符编码为一到四个字节。Go 支持开箱即用的 UTF-8 字符，不需要任何特殊设置、库或包。像字母 A 这样的罗马字符可以用像数字65这样的 ASCII 值表示。但是，如果使用特殊字符，例如世这样的国际字符，则需要 UTF-8。Go 对 UTF-8 数据使用 rune 别名类型。\na := \u0026#34;Hello, 世界\u0026#34; 你可以在 for 循环中使用 range 关键字来索引 Go 中的任何字符串，甚至是 UTF-8 字符串。for 循环和 range 将在本系列后面更深入地讨论; 现在，重要的是知道我们可以使用它来计算给定字符串中的字节数：\npackage main import \u0026#34;fmt\u0026#34; func main() { a := \u0026#34;Hello, 世界\u0026#34; for i, c := range a { fmt.Printf(\u0026#34;%d: %s\\n\u0026#34;, i, string(c)) } fmt.Println(\u0026#34;length of \u0026#39;Hello, 世界\u0026#39;: \u0026#34;, len(a)) } 在上面的代码块中，我们声明了变量 a，并为其赋值 Hello，世界。分配的文本中包含 UTF-8 字符。\n然后我们使用了一个标准的 for 循环以及 range 关键字。在 Go 中，range 关键字将通过字符串索引，每次返回一个字符，以及字符位于字符串中的字节索引。\n使用 fmt.Printf 函数中，我们提供了一个格式字符串 %d:%s\\n。%d 是数字的打印动词（在本例中是整数），%s 是字符串的打印动词。然后我们提供了 i 的值，它是 for 循环的当前索引，c 是 for 循环中的当前字符。\n最后，我们使用内建的 len 函数打印了变量 a 的整个长度。\n在前面，我们提到了 rune 是 int32 的别名，可以由一到四个字节组成。世 字符需要三个字节来定义，当通过 UTF-8 字符串进行循环时，索引也会相应地移动。这就是当它被打印出来时 i 不是顺序的原因。\noutput0: H 1: e 2: l 3: l 4: o 5: , 6: 7: 世 10: 界 length of \u0026#39;Hello, 世界\u0026#39;: 13 如你所见，字符串的长度比它循环迭代的次数大。\n你不会总使用 UTF-8 字符串，但当使用时，你将会理解为什么他们叫做 rune 而不是单个 int32。\n声明变量的数据类型 # 既然你已经了解了不同的基本数据类型，接下来我们将讨论如何在 Go 中将这些类型分配给变量。\n在 Go 中，我们可以使用关键字 var ，后面跟着变量名和所需的数据类型来定义一个变量。\n在下面的示例中，我们将声明一个类型为 float64 的变量 pi。\n关键字 var 是首先声明的:\n`var` pi float64 后面是我们的变量名，pi：\nvar `pi` float64 最后是数据类型 float64：\nvar pi `float64` 我们也有指定初始值的选项，比如 3.14：\nvar pi float64 = `3.14` Go 是一种_静态类型_语言。静态类型意味着在编译时检查程序中的每个语句。它还意味着数据类型绑定到变量，而在动态链接的语言中是数据类型绑定到值。\n例如，在 Go 中，当声明一个变量时，类型被声明:\nvar pi float64 = 3.14 var week int = 7 如果以不同的方式声明这些变量，它们中的每一个都可能是不同的数据类型。\n这与 PHP 语言不同，它的数据类型与值相关联:\n$s = \u0026#34;sammy\u0026#34;; // $s is automatically a string $s = 123; // $s is automatically an integer 在前面的代码块中，第一个 $s 是一个字符串，因为它被赋值为 \u0026quot;sammy\u0026quot;，第二个是一个整数，因为它的值为 123。\n接下来，让我们看看更复杂的数据类型，比如数组。\n数组 # _数组_是元素的有序序列。数组的容量在创建时定义。一旦数组分配了它的大小，它的大小就不能再改变了。因为数组的大小是静态的，这意味着它只分配一次内存。这使得数组有些僵硬，但是增加了程序的性能。因此，数组通常用于优化程序。接下来介绍的_切片_更加灵活，它与你在其他语言中认识的数组更相似。\n数组是通过声明数组的大小来定义的，然后是数据类型和定义在花括号 { }之间的值。\n字符串数组如下所示：\n[3]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;} 我们可以把数组保存在变量中并打印出来：\ncoral := [3]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;} fmt.Println(coral) output [blue coral staghorn coral pillar coral] 上面提到过，切片和数组类似，但更加的灵活。让我们看下这个可变的数据类型。\n切片 # 一个_切片_是一个可以改变长度的有序元素序列。切片可以动态地增加它们的大小。当你向一个切片添加新元素时，如果该切片没有足够的内存来存储新元素，那么它将根据需要从系统中申请更多的内存。由于可以根据需要扩展切片以添加更多的元素，因此它们比数组更常用。\n切片的定义是通过声明前面有开方括号和闭方括号 [] 的数据类型，并且在花括号 {} 之间有值。\n整数切片如下所示：\n[]int{-3, -2, -1, 0, 1, 2, 3} 浮点数的切片如下所示：\n[]float64{3.14, 9.23, 111.11, 312.12, 1.05} 字符串的切片如下所示：\n[]string{\u0026#34;shark\u0026#34;, \u0026#34;cuttlefish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;} 我们定义一个字符切片叫做 seaCreatures：\nseaCreatures := []string{\u0026#34;shark\u0026#34;, \u0026#34;cuttlefish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;} 我们可以通过调用变量打印出来：\nfmt.Println(seaCreatures) 输出将和我们创建的列表完全一样：\noutput [shark cuttlefish squid mantis shrimp] We can use the append keyword to add an item to our slice. The following command will add the string value of seahorse to the slice: 我们可以使用 append 关键字，在切片中添加一个元素。下面的命令将在切片中增加字符串值 seahorse：\nseaCreatures = append(seaCreatures, \u0026#34;seahorse\u0026#34;) 你可以通过打印来验证确实添加了这个元素：\nfmt.Println(seaCreatures) output [shark cuttlefish squid mantis shrimp seahorse] 如你所见，若你需要管理一个未知长度的元素，切片将比数据更加适合。\nMaps # _map_是 Go 内建的哈希或字典类型。 Map 使用 键 _值_对来存储数据。在编程中快速通过索引或在 Go 中通过键来查找值时非常有用。比如，你可能会用 map 按用户 ID 为索引来保存用户。键可以是用户 ID，用户对象可以是值。map 可以用 map 关键字，接着把键的数据类型放在 [] 中括号里，后面是值的数据类型，且键值对放在大括号中。\nmap[key]value{} 一般用于保存相关的数据，比如包含 ID 的信息，map 如下所示：\nmap[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} 你将注意到，除了大括号之外，整个 map 中还有冒号。冒号左边的字是键。键可以是 Go 中的任何_可比较的_类型。可比较的类型是一些基本类型，如 strings、ints 等。基本类型是由语言定义的，而不是通过组合任何其他类型构建的。虽然它们可以是用户定义的类型，但为了避免编程错误，保持它们简单被认为是最佳实践。上面字典中的键是: name、animal、color 和 location。\n冒号右边的单词是值。值可以由任何数据类型组成。上面字典中的值是: Sammy，shark，blue 和 ocean。\n让我们把 map 存储在一个变量中，然后打印出来:\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} fmt.Println(sammy) output map[animal:shark color:blue location:ocean name:Sammy] 如果我们只想打印 Sammy 的颜色，可以通过调用 sammy[\u0026quot;color\u0026quot;] 的方式完成。我们把它打印出来：\nfmt.Println(sammy[\u0026#34;color\u0026#34;]) output blue 因为 map 提供了以键-值的方式来存储值，在你的 Go 程序中它们会是重要的元素。\n结论 # 此时，你应该对 Go 中可用的一些主要数据类型有了更好的理解。当你使用 Go 语言开发编程项目时，这些数据类型中的每一种都将变得非常重要。\n一旦掌握了 Go 中可用的数据类型，就可以学习如何转换数据类型，以便根据具体情况更改数据类型。\n"},{"id":7,"href":"/How-To-Code-in-Go/docs/08-An_Introduction_to_Working_with_Strings_in_Go/","title":"08 an Introduction to Working With Strings in Go","section":"Docs","content":" Go 中处理字符串的介绍 # _字符串_是由一个或多个字符(字母、数字、符号)组成的序列，这些字符可以是常量，也可以是变量。字符串由 Unicode 组成，是不可变的序列，这意味着它们是不变的。\n因为文本是我们日常生活中使用的常见数据形式，所以字符串数据类型是编程中一个非常重要的基石。\n本 Go 教程将介绍如何创建和打印字符串，如何连接和复制字符串，以及如何在变量中存储字符串。\n字符串文字 # 在 Go 中，字符串存在于反引号 `（有时叫做反勾号）或双引号 \u0026quot; 中。根据使用的引号不同，字符串将具有不同的特征。\n使用反引号，如 ` bar `，将创建一个_原始_字符串。在原始字符串中，除了反引号之外，任何字符都可以出现在引号之间。下面是一个原始字符串的例子:\n`Say \u0026#34;hello\u0026#34; to Go!` 反斜杠在原始字符串中没有特殊含义。例如，\\n 表示的是实际字符，以反斜杠 \\ 和字母 n 的形式出现。不像解释的字符串文字，\\n 会插入一个实际的新行。\n原始字符串也可用于创建多行字符串:\n`Go is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multi-core and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It\u0026#39;s a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language.` 解释字符串是双引号之间的字符序列，如 \u0026quot;bar\u0026quot; 中所示。在引号中，除了换行符和非转义双引号之外，可以出现任何字符。\n\u0026#34;Say \\\u0026#34;hello\\\u0026#34; to Go!\u0026#34; 您几乎总是使用解释字符串，因为它们允许使用转义字符。\n现在你已经了解了 Go 中字符串是如何格式化的，接下来让我们看看如何在程序中打印字符串。\n打印字符串 # 你可以使用系统库中的 fmt 包并调用 Println() 函数来打印字符串：\nfmt.Println(\u0026#34;Let\u0026#39;s print out this string.\u0026#34;) output Let\u0026#39;s print out this string. 当你使用系统库时需要 import 它们，因此一个简单打印字符串的程序如下所示：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Let\u0026#39;s print out this string.\u0026#34;) } 字符串拼接 # _拼接_意味着把字符串收尾连接起来，创建一个新的字符串。你可以使用 + 号连接字符串。注意当你处理数字时，+ 将是一个加和的操作符，但在用于字符串时是一个连接符。\n让我们通过一个 fmt.Println() 声明语句把 \u0026quot;Sammy\u0026quot; 和 \u0026quot;Shark\u0026quot; 字符串连接到一起：\nfmt.Println(\u0026#34;Sammy\u0026#34; + \u0026#34;Shark\u0026#34;) output SammyShark 如果希望两个字符串之间有空格，只需在字符串中包含空格即可。在这个例子中，在 Sammy 之后的引号中添加空格:\nfmt.Println(\u0026#34;Sammy \u0026#34; + \u0026#34;Shark\u0026#34;) output Sammy Shark 不能在两种不同的数据类型之间使用 + 运算符。例如，你不能将字符串和整数连接在一起。如果你试着写下面的代码:\nfmt.Println(\u0026#34;Sammy\u0026#34; + 27) 你将会收到下面的错误：\noutput cannot convert \u0026#34;Sammy\u0026#34; (type untyped string) to type int invalid operation: \u0026#34;Sammy\u0026#34; + 27 (mismatched types string and int) 如果希望创建字符串 \u0026quot;Sammy27\u0026quot;，可以将数字 27 放在引号中（\u0026quot;27\u0026quot;）中 ，这样它就不再是一个整数，而是一个字符串。在处理邮政编码或电话号码时，将数字转换为字符串以进行连接非常有用。例如，你不希望在国家代码和地区代码之间执行添加操作，但是您希望它们可以放在一起。\n当通过连接将两个或多个字符串组合在一起时，就创建了一个可以在整个程序中使用的新字符串。\n在变量中保存字符串 # **变量**是在程序中可以用来保存数据的符号。你可以将它们看作是一个可以在其中填充一些数据或值的空盒子。字符串是数据，因此你可以使用它们来填充变量。将字符串声明为变量可以使得在 Go 程序中处理字符串更加容易。\n要在变量中存储字符串，只需将一个变量分配给字符串。在下面的例子中，s 被声明为变量:\ns := \u0026#34;Sammy likes declaring strings.\u0026#34; 注意: 如果你熟悉其他的编程语言，你可以把变量写成 sammy。但是，Go 倾向于使用较短的变量名。在这种情况下，选择 s 作为变量名被认为更适合编写 Go 的样式。\n现在你有了设置为特定字符串的变量 s，你可以像下面的代码一样打印变量：\nfmt.Println(s) 你将获得下面的输出：\noutput Sammy likes declaring strings. 通过使用变量来替代字符串，你不必每次都要重新键入字符串，从而使您在程序中处理和操作字符串更加简单。\n结论 # 本教程介绍了使用 Go 编程语言处理字符串数据类型的基本知识。创建并打印字符串、连接和复制字符串以及将字符串存储在变量中，它们将为你提供在 Go 程序中使用字符串的基础知识。\n"},{"id":8,"href":"/How-To-Code-in-Go/docs/09-How_To_Format_Strings_in_Go/","title":"09 How to Format Strings in Go","section":"Docs","content":" 如何在 Go 中格式化字符串 # 由于字符串通常由书面文本组成，因此在许多情况下，我们可能希望更好的定制字符串的展示形式，以便通过定时、换行和缩进使其更易于阅读。\n在本教程中，我们将介绍一些使用 Go 字符串的方法，以确保所有输出文本的格式正确。\n字符串文字 # 我们先来看看 字符串文字 和 字符串值 的区别。 字符串文字是我们在计算机程序的源代码中看到的，包括引号。 当我们调用 fmt.Println 函数并运行程序时，我们会看到一个字符串值。\n在“Hello, World!” 程序中，字符串文字是 \u0026quot;Hello, World!\u0026quot; 而字符串值是 Hello, World! 不带引号。 字符串值是我们在运行 Go 程序时在终端窗口中看到的输出。\n但是某些字符串值可能需要包含引号，例如当我们引用某个资源时。由于字符串文字和字符串值不等价，因此通常需要为字符串文字添加额外的转换格式，以确保字符串值按照我们想要的方式显示。\n引号 # 因为我们可以在 Go 中使用反引号 (`` ) 或双引号 (\u0026quot;`)，所以我们很容易在反引号里使用双引号来括住字符串：\n`Sammy says, \u0026#34;Hello!\u0026#34;` 或者，要使用反引号，你可以将字符串括在双引号中：\n\u0026#34;Sammy likes the `fmt` package for formatting strings..\u0026#34; 在组合反引号和双引号的方式中，我们可以控制字符串中引号和反引号的显示方式。\n这里有个重点，在 Go 中使用反引号会创建一个 raw 字符串文字，而使用双引号会创建一个 interpreted 字符串文字。要了解有关差异的更多信息，请阅读 Go 中处理字符串的介绍 教程。\n转义字符 # 格式化字符串的另一种方法是使用转义字符。转义字符用于告诉代码后面的字符具有特殊含义。转义字符都以反斜杠 (\\) 开头，并结合字符串中的另一个字符以某种方式格式化给定的字符串。\n以下是几个常见转义字符的列表：\n转义字符 如何格式化 \\ 反斜杠 \u0026quot; 双引号 \\n 换行 \\t 制表符（水平缩进） 让我们使用转义字符将引号添加到上面的引号示例中，但这次将使用双引号来表示字符串：\nfmt.Println(\u0026#34;Sammy says, \\\u0026#34;Hello!\\\u0026#34;\u0026#34;) output Sammy says, \u0026#34;Hello!\u0026#34; 我们可以通过转义字符 \\\u0026quot; 来转义掉双引号，从而实现双引号中还能嵌套使用双引号。\n我们可以使用 \\n 转义字符来换行，而无需使用 enter 或 return ：\nfmt.Println(\u0026#34;This string\\nspans multiple\\nlines.\u0026#34;) output This string spans multiple lines. 我们也可以组合转义字符。 打印一个多行字符串且每行包含一个制表符，例如：\nfmt.Println(\u0026#34;1.\\tShark\\n2.\\tShrimp\\n10.\\tSquid\u0026#34;) Output 1. Shark 2. Shrimp 10. Squid \\t 转义字符提供的水平缩进确保在前面示例中的第二列内对齐，使输出结果非常易读。\n转义字符用于向可能难以或不可能实现的字符串添加额外的格式。 如果没有转义字符，你将无法构造字符串 Sammy says, \u0026quot;I like to use the fmt package\u0026quot;。\n多行 # 在多行上打印字符串可以使文本更具可读性。 通过多行，可以将字符串分组为干净有序的文本，格式化为字母，或用于维护诗歌或歌曲歌词的换行符。\n要创建跨越多行的字符串，使用反引号将字符串括起来。 请记住，虽然这么写会保留换行，但它也创建了一个 raw 字符串文字。\n` This string is on multiple lines within three single quotes on either side. ` 如果你打印这个，你会注意到有一个前空行和后空行：\nOutput This string is on multiple lines within three single quotes on either side. 为避免这种情况，您需要将第一行紧跟在反引号之后，并以反引号结束最后一行。\n`This string is on multiple lines within three single quotes on either side.` 如果你需要创建解释字符串文字，可以使用双引号和 + 运算符来完成，但你需要插入自己的换行符。\n\u0026#34;This string is on\\n\u0026#34; + \u0026#34;multiple lines\\n\u0026#34; + \u0026#34;within three single\\n\u0026#34; + \u0026#34;quotes on either side.\u0026#34; 虽然反引号可以更轻松地打印和阅读冗长的文本，但如果你需要解释字符串文字，则需要使用双引号。\n原始字符串文字 # 如果我们不想在字符串中使用特殊格式怎么办？ 例如，我们可能需要比较或评估故意使用反斜杠的计算机代码字符串，因此我们不希望 Go 将其用作转义字符。\nraw 字符串文字告诉 Go 忽略字符串中的所有格式，包括转义字符。\n我们通过在字符串周围使用反引号来创建一个原始字符串：\nfmt.Println(`Sammy says,\\\u0026#34;The balloon\\\u0026#39;s color is red.\\\u0026#34;`) Output Sammy says,\\\u0026#34;The balloon\\\u0026#39;s color is red.\\\u0026#34; 通过在给定字符串周围使用反引号来构造原始字符串，我们可以保留反斜杠和其他用作转义字符的字符。\n结论 # 本教程通过使用字符串介绍了几种在 Go 中格式化文本的方法。 通过使用转义字符或原始字符串等技术，我们能够确保程序的字符串正确的呈现在屏幕上，以便用户最终能够轻松阅读所有输出文本。\n"},{"id":9,"href":"/How-To-Code-in-Go/docs/10-An_Introduction_to_the_Strings_Package_in_Go/","title":"10 an Introduction to the Strings Package in Go","section":"Docs","content":" 介绍 Go 中的 Strings 包 # 介绍 # Go 的 strings 包有几个函数可用于 string 数据类型。这些函数可以轻松地修改和操作字符串。我们可以将函数视为对代码元素执行的操作。内置函数是那些在 Go 编程语言中定义并且可供我们随时使用的函数。\n在本教程中，我们将回顾几个可用于在 Go 中处理字符串的不同函数。\n字符串大写和小写 # 函数 strings.ToUpper 和 strings.ToLower 将返回一个字符串，其中原始字符串的所有字母都转换为大写或小写字母。 因为字符串是不可变的数据类型，所以返回的字符串将是一个新字符串。 字符串中的任何非字母字符都不会更改。\n要将字符串 \u0026quot;Sammy Shark\u0026quot; 转换为全大写，你可以使用 strings.ToUpper 函数：\nss := \u0026#34;Sammy Shark\u0026#34; fmt.Println(strings.ToUpper(ss)) Output SAMMY SHARK 要转换为小写：\nfmt.Println(strings.ToLower(ss)) Output sammy shark 由于你使用的是 strings 包，因此首先需要将其导入程序中。 要将字符串转换为大写和小写，整个程序如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { ss := \u0026#34;Sammy Shark\u0026#34; fmt.Println(strings.ToUpper(ss)) fmt.Println(strings.ToLower(ss)) } strings.ToUpper 和 strings.ToLower 函数使大小写始终保持一致，更容易评估和比较字符串。 例如，如果用户的姓名全小写，我们仍然可以通过检查全大写版本来确定他们的姓名是否在我们的数据库中。\n字符串搜索函数 # strings 包有许多函数可以帮助确定字符串是否包含特定的字符。\n函数 用法 strings.HasPrefix 从头开始搜索字符串 strings.HasSuffix 从末尾开始搜索字符串 strings.Contains 搜索字符串中的任何位置 strings.Count 计算字符串出现的次数 strings.HasPrefix 和 strings.HasSuffix 允许你检查字符串是否以特定字符集开头或结尾。\n例如，要检查字符串 \u0026quot;Sammy Shark\u0026quot; 是否以 Sammy 开头并以 Shark 结尾：\nss := \u0026#34;Sammy Shark\u0026#34; fmt.Println(strings.HasPrefix(ss, \u0026#34;Sammy\u0026#34;)) fmt.Println(strings.HasSuffix(ss, \u0026#34;Shark\u0026#34;)) Output true true 你将使用 strings.Contains 函数来检查 \u0026quot;Sammy Shark\u0026quot; 是否包含字符 Sh：\nfmt.Println(strings.Contains(ss, \u0026#34;Sh\u0026#34;)) Output true 最后，看看 “Sammy Shark” 这个字符串中出现了多少次字母 “S”：\nfmt.Println(strings.Count(ss, \u0026#34;S\u0026#34;)) Output 2 注意： Go 中的所有字符串都区分大小写。 这意味着 Sammy 与 sammy 不同。\n计算小写的 s 在 Sammy Shark 中出现的次数与使用大写的 S 计算结果并不同：\nfmt.Println(strings.Count(ss, \u0026#34;s\u0026#34;)) Output 0 因为 S 与 s 不同，所以返回的计数将为 0。\n当你想在程序中比较或搜索字符串时，字符串函数很有用。\n确定字符串长度 # 内置函数 len() 返回字符串中的字符数。 当你需要强制最小或最大密码长度，或将较大的字符串截断以在特定限制内用作缩写时，此功能很有用。\n为了演示这个功能，下面我们将得到一个长字符串的长度：\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { openSource := \u0026#34;Sammy contributes to open source.\u0026#34; fmt.Println(len(openSource)) } Output 33 我们将变量 openSource 设置为字符串 \u0026quot;Sammy contributes to open source.\u0026quot;，然后使用 len(openSource) 将该变量传递给 len() 函数。 最后，我们将函数传递给 fmt.Println() 函数，以便我们可以在屏幕上看到程序的输出。\n请记住，len() 函数将计算由双引号绑定的任何字符——包括字母、数字、空白字符和符号。\n字符串操作函数 # strings.Join、strings.Split 和 strings.ReplaceAll 函数是在 Go 中操作字符串的一些额外方法。\nstrings.Join 函数用于将一组字符串组合成一个新的字符串。\n要从字符串切片创建逗号分隔的字符串，我们将按以下方式使用此函数：\nfmt.Println(strings.Join([]string{\u0026#34;sharks\u0026#34;, \u0026#34;crustaceans\u0026#34;, \u0026#34;plankton\u0026#34;}, \u0026#34;,\u0026#34;)) Output sharks,crustaceans,plankton 如果我们想在我们的新字符串中的字符串值之间添加一个逗号和一个空格，我们可以简单地用逗号后的空格重写我们的表达式：strings.Join([]string{\u0026quot;sharks\u0026quot;, \u0026quot;crustaceans\u0026quot;, \u0026quot;plankton \u0026quot;}, \u0026quot;, \u0026quot;)。\n就像我们可以将字符串连接在一起一样，我们也可以拆分字符串。 为此，我们可以使用 strings.Split 函数并拆分空格：\nballoon := \u0026#34;Sammy has a balloon.\u0026#34; s := strings.Split(balloon, \u0026#34; \u0026#34;) fmt.Println(s) Output [Sammy has a balloon] 输出是一段字符串。 由于使用了strings.Println，因此很难通过肉眼来判断输出的是什么类型。 要查看它确实是一段字符串，请使用 fmt.Printf 函数和 %q 来格式化输出字符串：\nfmt.Printf(\u0026#34;%q\u0026#34;, s) Output [\u0026#34;Sammy\u0026#34; \u0026#34;has\u0026#34; \u0026#34;a\u0026#34; \u0026#34;balloon.\u0026#34;] 除了 strings.Split 之外，另一个有用的函数是 strings.Fields。 不同之处在于 strings.Fields 将忽略所有空格，并且只会在字符串中拆分出实际的 fields：\ndata := \u0026#34; username password email date\u0026#34; fields := strings.Fields(data) fmt.Printf(\u0026#34;%q\u0026#34;, fields) Output [\u0026#34;username\u0026#34; \u0026#34;password\u0026#34; \u0026#34;email\u0026#34; \u0026#34;date\u0026#34;] strings.ReplaceAll 函数可以将原始字符串进行一些替换，并返回更新后的字符串。\n假设 Sammy 的气球丢失了。 由于 Sammy 不再有这个气球，我们将在新字符串中将子字符串 \u0026quot;has\u0026quot; 从原始字符串中更改为 \u0026quot;had\u0026quot;：\nfmt.Println(strings.ReplaceAll(balloon, \u0026#34;has\u0026#34;, \u0026#34;had\u0026#34;)) 上面的函数参数，首先是 balloon ，用于存储原始字符串的变量； 第二个子字符串“has”是我们要替换的，第三个子字符串“had”是我们要替换第二个子字符串的。 当我们将其合并到程序中时，我们的输出将如下所示：\nOutput Sammy had a balloon. 使用字符串函数 strings.Join、strings.Split 和 strings.ReplaceAll 将为你在 Go 中操作字符串提供更好的帮助。\n结论 # 本教程介绍了一些用于字符串数据类型的常见字符串包函数，你可以使用这些函数在 Go 程序中处理和操作字符串。\n你可以在 理解 Go 的数据类型 中了解有关其他数据类型的更多信息，并在 Go 中处理字符串的介绍 了解更多有关字符串的信息。\n"},{"id":10,"href":"/How-To-Code-in-Go/docs/11-How_To_Use_Variables_and_Constants_in_Go/","title":"11 How to Use Variables and Constants in Go","section":"Docs","content":" 如何在 Go 中使用变量和常量 # 变量 是一个需要掌握的重要编程概念。它们是代表你在程序中使用的值的符号。\n本教程将介绍一些变量基础知识和在你创建的 Go 程序中使用它们的最佳实践。\n理解变量 # 用术语来说，变量将存储位置分配给与符号名称或标识符相关的值。我们使用变量名来引用计算机程序中存储的值。\n我们可以将变量视为带有名称的标签，您可以将其绑定到值上。\n假设我们有一个整数 1032049348 ，我们希望将它存储在一个变量中，而不是一遍又一遍地不断地重新输入长数字。为了达到这个目的，我们可以使用一个容易记住的名字，比如变量 i。要将值存储在变量中，我们使用以下语法：\ni := 1032049348 我们可以把这个变量想象成一个与值绑定的标签。\n标签上写有变量名 i ，并与整数值 1032049348 相关联。\ni := 1032049348 是一个声明和赋值语句，由几个部分组成：\n变量名 (i) 变量声明赋值 (:=) 与变量名绑定的值（1032049348） Go 推断的数据类型 (int) 稍后我们将在下一节中看到如何显式设置类型。\n这些部分共同构成了将变量 i 设置为整数 1032049348 的值的语句。\n一旦我们设置一个等于某个值的变量，变量就会被初始化或创建出来。一旦我们这样做了，我们就可以使用变量而不是值了。\n一旦我们将 i 设置为 1032049348 ，我们可以使用 i 代替整数，所以让我们打印出来：\npackage main import \u0026#34;fmt\u0026#34; func main() { i := 1032049348 fmt.Println(i) } Output 1032049348 我们还可以通过使用变量快速轻松地进行数学运算。使用i := 1032049348，我们可以使用以下语法减去整数值813：\nfmt.Println(i - 813) Output 1032048535 在这个例子中，Go 为我们做数学运算，从变量 i 中减去 813 以返回总和 1032048535。\n说到数学，变量可以设置为某个数学方程的结果。你还可以将两个数字相加并将总和的值存储到变量 x 中：\nx := 76 + 145 你可能已经注意到这个例子看起来和代数很像。就像我们在公式和方程式中使用字母和其他符号来表示数字和数量一样，变量是表示数据类型值的符号名称。对于正确的 Go 语法，你需要确保你的变量位于任何等式的左侧。\n让我们继续打印 x：\npackage main import \u0026#34;fmt\u0026#34; func main() { x := 76 + 145 fmt.Println(x) } Output 221 Go 返回值 221 因为变量 x 被设置为等于 76 和 145 的总和。\n变量可以表示任何数据类型，而不仅仅是整数：\ns := \u0026#34;Hello, World!\u0026#34; f := 45.06 b := 5 \u0026gt; 9 // A Boolean value will return either true or false array := [4]string{\u0026#34;item_1\u0026#34;, \u0026#34;item_2\u0026#34;, \u0026#34;item_3\u0026#34;, \u0026#34;item_4\u0026#34;} slice := []string{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;} m := map[string]string{\u0026#34;letter\u0026#34;: \u0026#34;g\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;seven\u0026#34;, \u0026#34;symbol\u0026#34;: \u0026#34;\u0026amp;\u0026#34;} 如果你打印这些变量中的任何一个，Go 将返回该变量等价的内容。让我们使用 slice 数据类型的赋值语句：\npackage main import \u0026#34;fmt\u0026#34; func main() { slice := []string{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;} fmt.Println(slice) } Output [one two three] 我们将 []string{\u0026quot;one\u0026quot;, \u0026quot;two\u0026quot;, \u0026quot;three\u0026quot;} 的切片值分配给变量 slice，然后使用 fmt.Println 函数通过调用 slice 打印出该值。\n变量通过在你的计算机中开辟一小块内存区域来工作，该区域接受指定的值，然后与该空间相关联。\n声明变量 # 在 Go 中，有多种声明变量的方法，在某些情况下，声明完全相同的变量和值的方法不止一种。\n我们可以在不初始化的情况下声明一个数据类型为 int 的名为 i 的变量。这意味着我们将声明一个空间来放置一个值，但不给它一个初始值：\nvar i int 这将创建一个数据类型为 int 的 i 的变量。\n我们可以使用等于 (=) 运算符来初始化值，如下例所示：\nvar i int = 1 在 Go 中，这两种声明形式都称为长变量声明。\n我们也可以使用短变量声明：\ni := 1 在这种情况下，我们有一个名为 i 的变量和一个 int 数据类型。当我们不指定数据类型时，Go 会推断数据类型。\n对于声明变量的三种方式，Go 社区采用了以下习惯用法：\n仅在不初始化变量时使用长格式，var i int。 在声明和初始化时使用缩写形式，i := 1。 如果你不希望 Go 推断数据类型，但仍想使用短变量声明，则可以使用以下语法将值包装为所需类型： i := int64(1) 当我们初始化值时，长变量声明形式在 Go 中是不常用的：\nvar i int = 1 遵循 Go 社区关于如何声明变量的方式，以便其他人可以无缝阅读你的程序。\n零值 # 所有内置类型的默认值都为零值。任何分配的变量都是可用的，即使它从未分配过值。我们可以看到以下类型的零值：\npackage main import \u0026#34;fmt\u0026#34; func main() { var a int var b string var c float64 var d bool fmt.Printf(\u0026#34;var a %T = %+v\\n\u0026#34;, a, a) fmt.Printf(\u0026#34;var b %T = %q\\n\u0026#34;, b, b) fmt.Printf(\u0026#34;var c %T = %+v\\n\u0026#34;, c, c) fmt.Printf(\u0026#34;var d %T = %+v\\n\\n\u0026#34;, d, d) } Output var a int = 0 var b string = \u0026#34;\u0026#34; var c float64 = 0 var d bool = false 我们在 fmt.Printf 语句中使用了 %T 。这告诉函数打印变量的 数据类型 。\n在 Go 中，因为所有值都有一个 零 值，所以我们不能像其他一些语言那样有“未定义”值。例如，某些语言中的 boolean 可能是 undefined、true 或 false，它允许变量有三种状态。在 Go 中，一个布尔值的状态不能超过 两个 。\n命名变量：规则和样式 # 变量的命名相当灵活，但有一些规则需要牢记：\n变量名只能是一个单词（如没有空格）。 变量名称必须仅由字母、数字和下划线 (_) 组成。 变量名不能以数字开头。 按照这些规则，让我们看看有效和无效的变量名：\nValid 有效 Invalid 无效 无效原因 userName user-name 不允许使用连字符 name4 4name 不能以数字开头 user $user 不能使用符号 userName user name 不能超过一个单词 此外，在命名变量时请记住它们区分大小写。这些名称 userName、USERNAME、UserName 和 uSERNAME 都是完全不同的变量。最好避免在程序中使用相似的变量名称，以确保你和你的合作者（当前和未来）都能保持变量的正确性。\n虽然变量区分大小写，但变量首字母的大小写在 Go 中具有特殊含义。如果变量以大写字母开头，则该变量可以在声明它的包（或 exporter ）之外访问。如果变量以小写字母开头，则它仅在声明它的包中可用。\nvar Email string var password string Email 以大写字母开头，可以被其他包访问。password 以小写字母开头，只能在声明它的包内访问。\n在 Go 中使用非常简洁（或短）的变量名是很常见的。变量 userName 和 user 之间的选择，通常会选择 user 。\n作用域在变量名称的简洁性方面也发挥了作用。规则是变量存在的作用域越小，变量名越小：\nnames := []string{\u0026#34;Mary\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Anna\u0026#34;} for i, n := range names { fmt.Printf(\u0026#34;index: %d = %q\\n\u0026#34;, i, n) } 我们在更大的作用域内使用变量 names，因此通常给它一个更有意义的名称以帮助记住它在程序中的含义。但是，我们在下一行代码中立即使用 i 和 n 变量，然后不再使用它们……因此，它不会让阅读代码的人混淆变量的使用位置，或者它们代表的意思。\n接下来，让我们介绍一些关于变量样式的注意事项。使用 MixedCaps 或 mixedCaps 而不是下划线作为多词名称。\n常用风格 非常用风格 为什么不常用 userName user_name 下划线不常用 i index 更倾向用 i 而不是 index 因为它更短 serveHTTP serveHttp 专业词缩写应该用大写 风格最重要的是要保持一致，并且你所在的团队同意这种风格。\n重新分配变量 # 正如 变量 一词所暗示的那样，我们可以轻松地更改 Go 变量。这意味着我们可以通过重新分配将不同的值与先前分配的变量联系起来。能够重新分配变量是很有用的，因为在整个程序过程中，我们可能需要将用户生成的值赋给已经初始化的变量中。我们可能还需要将分配更改为先前定义的内容。\n在处理其他人编写的大型程序时，知道变量可以被重新分配对我们是很有帮助的，特别是当我们不清楚哪些变量已经被定义了。\n让我们将 76 的值分配给一个名为 i 的类型为 int 的变量，然后为它分配一个新的值 42：\npackage main import \u0026#34;fmt\u0026#34; func main() { i := 76 fmt.Println(i) i = 42 fmt.Println(i) } Output 76 42 这个例子表明我们可以先给变量 i 赋值一个整数，然后再重新赋值变量 i ，这次赋值为 42。\n注意：当你声明和初始化一个变量时，你可以使用:=，但是，当你想简单地改变一个已经声明的变量的值时，你只需要使用等号运算符 (=)。\n因为 Go 是一种静态强类型语言，我们不能将一种类型分配给另一种类型。例如，我们不能将值 \u0026quot;Sammy\u0026quot; 分配给 int 类型的变量：\ni := 72 i = \u0026#34;Sammy\u0026#34; 尝试相互分配不同的类型将导致编译时错误：\nOutput cannot use \u0026#34;Sammy\u0026#34; (type string) as type int in assignment Go 不允许我们多次声明相同变量名：\nvar s string var s string Output s redeclared in this block 如果我们尝试对同一个变量名多次使用短变量声明，我们也会收到编译错误。这可能会发生错误，因此了解错误消息的含义是有帮助的：\ni := 5 i := 10 Output no new variables on left side of := 与变量声明类似，考虑变量的命名将提高你和其他人在将来维护程序的可读性。\n多重赋值 # Go 还允许我们为同一行中的多个变量分配多个值。这些值中的每一个都可以是不同的数据类型：\nj, k, l := \u0026#34;shark\u0026#34;, 2.05, 15 fmt.Println(j) fmt.Println(k) fmt.Println(l) Output shark 2.05 15 在这个例子中，变量 j 被赋值给字符串 shark，变量 k 被赋值给浮点数 2.05，变量 l 被赋值给整数 15 。\n这种在一行中将多个变量分配给多个值的方法可以减少代码中的行数。但是，重要的是不要因为更少的代码行而损害可读性。\n全局和局部变量 # 在程序中使用变量时，牢记变量作用域很重要。变量的作用域是指可以从给定程序的代码中访问的特定位置。也就是说，并非所有变量都可以从给定程序的所有部分访问——有些变量是全局变量，有些变量是局部变量。\n全局变量存在于函数之外。局部变量存在于函数中。\n让我们看一下全局和局部变量的作用：\npackage main import \u0026#34;fmt\u0026#34; var g = \u0026#34;global\u0026#34; func printLocal() { l := \u0026#34;local\u0026#34; fmt.Println(l) } func main() { printLocal() fmt.Println(g) } Output local global 这里我们使用 var g = \u0026quot;global\u0026quot; 在函数外部创建一个全局变量。然后我们定义函数printLocal()。在函数内部，分配了一个名为 l 的局部变量，然后打印出来。程序先调用 printLocal() ，然后打印全局变量 g。\n因为 g 是一个全局变量，我们可以在 printLocal() 中引用它。让我们修改之前的程序来做到这一点：\npackage main import \u0026#34;fmt\u0026#34; var g = \u0026#34;global\u0026#34; func printLocal() { l := \u0026#34;local\u0026#34; fmt.Println(l) fmt.Println(g) } func main() { printLocal() fmt.Println(g) } Output local global global 我们首先声明一个全局变量 g ，var g = \u0026quot;global\u0026quot;。在 main 函数中，我们调用函数printLocal，它声明了一个局部变量l并打印出来，fmt.Println(l)。然后，printLocal 打印出全局变量g，fmt.Println(g)。即使 g 没有在 printLocal 中定义，它仍然可以被访问，因为它是在全局作用域内声明的。最后，main 函数也打印出 g。\n现在让我们尝试在函数外部调用局部变量：\npackage main import \u0026#34;fmt\u0026#34; var g = \u0026#34;global\u0026#34; func printLocal() { l := \u0026#34;local\u0026#34; fmt.Println(l) } func main() { fmt.Println(l) } Output undefined: l 我们不能在分配它的函数之外使用局部变量。如果你尝试这样做，编译时会收到 未定义 错误。\n让我们看另一个例子，我们对全局变量和局部变量使用相同的变量名：\npackage main import \u0026#34;fmt\u0026#34; var num1 = 5 func printNumbers() { num1 := 10 num2 := 7 fmt.Println(num1) fmt.Println(num2) } func main() { printNumbers() fmt.Println(num1) } Output 10 7 5 在这个程序中，我们两次声明了 num1 变量。首先，我们在全局作用域内声明了num1，var num1 = 5，然后再次在 printNumbers 函数的本地作用域内声明 num1 := 10。当我们从 main 程序中打印 num1 时，我们看到 5 的值被打印出来了。这是因为 main 只看到全局变量声明。但是，当我们从 printNumbers 函数中打印出 num1 时，它会看到本地声明，并会打印出 10 的值。尽管 printNumbers 创建了一个名为 num1 的新变量并为其分配了 10 的值，但它不会影响值为 5 的 num1 的全局实例。\n使用变量时，你还需要考虑程序的哪些部分需要访问每个变量； 相应地采用全局或局部变量。在 Go 程序中，你会发现局部变量通常更常见。\n常量 # 常量就像变量一样，除了它们一旦被声明就不能被修改。常量对于定义在程序中多次使用但不能更改的值很有用。\n例如，如果我们想声明购物车系统的税率，我们可以使用一个常数，然后在程序的不同区域计算税收。在未来的某个时候，如果税率发生变化，我们只需在程序中的一个位置更改该值。如果我们使用了一个变量，我们可能会在程序中不小心更改某个值，从而导致计算不正确。\n要声明一个常量，我们可以使用以下语法：\nconst shark = \u0026#34;Sammy\u0026#34; fmt.Println(shark) Output Sammy 如果我们在声明后尝试修改常量，我们会得到一个编译时错误：\nOutput cannot assign to shark 常量可以是 untyped 。这在处理整数类型数据等数字时很有用。如果常量是 untyped，它会被显式转换，而 typed 常量则不是。让我们看看如何使用常量：\npackage main import \u0026#34;fmt\u0026#34; const ( year = 365 leapYear = int32(366) ) func main() { hours := 24 minutes := int32(60) fmt.Println(hours * year) fmt.Println(minutes * year) fmt.Println(minutes * leapYear) } Output 8760 21900 21960 如果你用一个类型声明一个常量，它将是那个确切的类型。在这里，当我们声明常量 leapYear 时，我们将其定义为数据类型 int32。因此它是一个 typed 常量，这意味着它只能对 int32 数据类型进行操作。我们声明的 year 常量没有类型，所以它被认为是 untyped。因此，你可以将它与任何整数数据类型一起使用。\n当hours被定义时，它推断它是int类型，因为我们没有明确地给它一个类型，hours := 24。当我们声明 minutes 时，我们明确地将其声明为 int32，minutes := int32(60)。\n现在让我们来看看每个计算以及它的工作原理：\nhours * year 在这种情况下，hours 是 int，而 years 是 untyped。当程序编译时，它显式地将 years 转换为 int，这使得乘法运算成功。\nminutes * year 在这种情况下，minutes 是 int32，而 year 是 untyped。当程序编译时，它显式地将 years 转换为 int32，从而允许乘法运算成功。\nminutes * leapYear 在这种情况下，minutes 是 int32，而 leapYear 是 int32 的 typed 常量。这次编译器无需执行任何操作，因为这两个变量已经属于同一类型。\n如果我们尝试将两种类型不兼容的类型相乘，程序将无法编译：\nfmt.Println(hours * leapYear) Output invalid operation: hours * leapYear (mismatched types int and int32) 在这种情况下，hours 被推断为 int，而 leapYear 被显式声明为 int32。因为 Go 是一种强类型语言，所以 int 和 int32 不兼容数学运算。要将它们相乘，你需要 将其中一个转换为int32或int。\n结论 # 在本教程中，我们回顾了 Go 中变量的一些常见用例。变量是编程的重要组成部分，充当我们在程序中使用的数据类型的值的代表。\n"},{"id":11,"href":"/How-To-Code-in-Go/docs/12-How_To_Convert_Data_Types_in_Go/","title":"12 How to Convert Data Types in Go","section":"Docs","content":" 如何在 Go 中转换数据类型 # 介绍 # 在 Go 中，数据类型用于对一种特定类型的数据进行分类，确定可以分配给该类型的值以及可以对其执行的操作。在编程时，有时你需要在类型之间转换值以便以不同的方式操作值。例如，你可能需要将数值与字符串连接起来，或者在初始化为整数值的数字中表示小数位。用户生成的数据通常会自动分配为字符串数据类型，即使它由数字组成； 为了在此输入中执行数学运算，你必须将字符串转换为数字数据类型。\n由于 Go 是一种静态类型语言，数据类型绑定到变量 而不是值。这意味着，如果你将变量定义为 int，它只能是 int； 如果不转换变量的数据类型，就无法将一个 字符串 赋值给它。Go 中数据类型的静态特性使得学习转换它们的方法更加重要。\n本教程将指导你完成数字和字符串的转换，并提供示例以帮助你熟悉不同的用例。\n数字类型转换 # Go 有多种数字类型可供选择。它们主要分为两种类型：integers 和 floating-point numbers。\n在许多情况下，你可能希望在数字类型之间进行转换。在 不同大小的数字类型 之间进行转换有助于优化特定场景下的性能。如果你有来自代码另一部分的整数并想要对其进行除法，你可能需要将整数转换为浮点数以保持操作的精度。此外，时间相关的操作通常涉及整数转换。为了解决这些情况，Go 为大多数数字类型提供了内置的类型转换。\n整数类型之间的转换 # Go 有许多整数数据类型可供选择。何时使用另一种通常更多要考虑的是性能； 但是，有时你需要从一种整数类型转换为另一种整数类型。例如，Go 有时会自动生成数值为 int，这可能与你的输入值不匹配。如果你的输入值为 int64，则在将它们的数据类型转换为匹配之前，你将无法在同一数学表达式中使用 int 和 int64 。\n假设你有一个 int8 并且需要将其转换为 int32。你可以通过 int32() 类型转换来做到这一点：\nvar index int8 = 15 var bigIndex int32 bigIndex = int32(index) fmt.Println(bigIndex) Output 15 此代码块将 index 定义为 int8 数据类型，将 bigIndex 定义为 int32 数据类型。要将 index 的值存储在 bigIndex 中，它将数据类型转换为 int32。这是通过 int32() 包装 index 变量来完成的。\n要验证你的数据类型，你可以使用 fmt.Printf 语句和 %T ，语法如下：\nfmt.Printf(\u0026#34;index data type: %T\\n\u0026#34;, index) fmt.Printf(\u0026#34;bigIndex data type: %T\\n\u0026#34;, bigIndex) Output index data type: int8 bigIndex data type: int32 由于使用了 %T ，打印语句会输出变量的类型，而不是变量的实际值。这样，你可以确认转换后的数据类型。\n你还可以从较大整数类型转换为较小整数类型：\nvar big int64 = 64 var little int8 little = int8(big) fmt.Println(little) Output 64 Keep in mind that when converting integers you could potentially exceed the maximum value of the data type and wraparound:请记住，在转换整数时，你可能会超过数据类型的最大值和 wraparound：\nvar big int64 = 129 var little = int8(big) fmt.Println(little) Output -127 当值转换为太小而无法容纳它的数据类型时，就会发生出。在前面的示例中，8 位的数据类型 int8 没有足够的空间来容纳 64 位的变量 big 。从较大数据类型转换为较小数据类型时应始终小心，以免意外截断数据。\n将整数转换为浮点数 # 在 Go 中将整数转换为浮点数类似于将一种整数类型转换为另一种。你可以通过给要转换的整数包装 float64() 或 float32() 来使用内置类型转换：\nvar x int64 = 57 var y float64 = float64(x) fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, y) Output 57.00 这段代码声明了一个类型为 int64 的变量 x 并将其值初始化为 57 。\nvar x int64 = 57 对 x 使用 float64() 会将 57 转换为 57.00 的浮点值。\nvar y float64 = float64(x) %.2f 告诉 fmt.Printf 用两位小数格式化浮点数。\n你也可以对变量这么操作。以下代码将 f 声明为 57，然后打印出新的浮点数：\nvar f float64 = 57 fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, f) Output 57.00 通过使用 float32() 或 float64()，你可以将整数转换为浮点数。接下来，你将学习如何将浮点数转换为整数。\n将浮点数转换为整数 # Go 可以将浮点数转换为整数，但程序会丢失浮点数的精度。\n使用 int() 或其他非浮点数据类型包装浮点数，其工作方式与整数类型转换类似。你可以在括号内添加一个浮点数以将其转换为整数：\nvar f float64 = 390.8 var i int = int(f) fmt.Printf(\u0026#34;f = %.2f\\n\u0026#34;, f) fmt.Printf(\u0026#34;i = %d\\n\u0026#34;, i) Output f = 390.80 i = 390 此语法会将浮点数 390.8 转换为整数 390，去掉小数位。\n你也可以将其与变量一起使用。以下代码声明 b 等于 125.0 和 c 等于 390.8，然后将它们打印为整数。短变量声明（:=）缩短了语法：\nb := 125.0 c := 390.8 fmt.Println(int(b)) fmt.Println(int(c)) Output 125 390 当使用 int() 类型将浮点数转换为整数时，Go 会截断浮点数的小数并保留剩余数字部分来创建整数。请注意，即使你可能希望将 390.8 向上取整到 391，Go 也不会通过 int() 类型执行此操作。相反，它会去掉小数点。\n除法中的类型转换 # 在 Go 中除以整数类型时，结果也将是整数类型，去掉了 模数 或余数：\na := 5 / 2 fmt.Println(a) Output 2 在做除法操作时，如果有数字类型是浮点数的话，那么所有类型都将自动声明为浮点数：\na := 5.0 / 2 fmt.Println(a) Output 2.5 上例将浮点数 5.0 除以整数 2 ，答案 2.5 是一个保留小数精度的浮点数。\n在本节中，你已经在不同的数字数据类型之间进行了转换，包括不同大小的整数和浮点数。接下来，你将学习如何在数字和字符串之间进行转换。\n字符串转换 # 字符串 是一个或多个字符（字母、数字或符号）组成的序列。字符串是计算机程序中一种常见的数据形式，你可能需要经常将字符串转换为数字或将数字转换为字符串，尤其是在你接收用户生成的数据时。\n将数字转换为字符串 # 你可以使用 Go 标准库中 strconv 包中的 strconv.Itoa 方法将数字转换为字符串。如果将数字或变量传递给该方法，则该数字值将被转换为字符串。\n首先，让我们看看转换整数。要将整数 12 转换为字符串，可以将 12 传递给 strconv.Itoa 方法：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { a := strconv.Itoa(12) fmt.Printf(\u0026#34;%q\\n\u0026#34;, a) } 运行此程序时，你将收到以下输出：\nOutput \u0026#34;12\u0026#34; 数字 12 周围的引号表示该数字不再是整数，而是字符串。\n你使用 := 赋值运算符来声明一个名为 a 的新变量，并将 strconv.Itoa() 函数返回的值赋值给它。此时值 12 被分配给了变量。你通过在 fmt.Printf 函数中使用 %q 来告诉函数引用提供的字符串参数。\n通过使用变量，你更能了解将整数转换为字符串的实际情况。假设你想跟踪用户的日常编程进度，并输入他们一次编写的代码行数。你希望将此反馈显示给用户，并将同时打印出字符串和整数值：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { user := \u0026#34;Sammy\u0026#34; lines := 50 fmt.Println(\u0026#34;Congratulations, \u0026#34; + user + \u0026#34;! You just wrote \u0026#34; + lines + \u0026#34; lines of code.\u0026#34;) } 运行此代码时，你将收到以下错误：\nOutput invalid operation: (\u0026#34;Congratulations, \u0026#34; + user + \u0026#34;! You just wrote \u0026#34;) + lines (mismatched types string and int) 你不能在 Go 中拼接字符串和整数，所以你必须将变量 lines 转换为字符串：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { user := \u0026#34;Sammy\u0026#34; lines := 50 fmt.Println(\u0026#34;Congratulations, \u0026#34; + user + \u0026#34;! You just wrote \u0026#34; + strconv.Itoa(lines) + \u0026#34; lines of code.\u0026#34;) } 现在，当你运行代码时，你将收到以下输出，祝贺你的用户取得了进展：\nOutput Congratulations, Sammy! You just wrote 50 lines of code. 如果你希望将浮点数转换为字符串而不是将整数转换为字符串，请遵循类似的步骤和格式。当你将浮点数传递给 fmt.Sprint 方法时，从 Go 标准库中的 fmt 包中，将返回浮点数的字符串值。你可以使用浮点值本身或变量：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(fmt.Sprint(421.034)) f := 5524.53 fmt.Println(fmt.Sprint(f)) } Output 421.034 5524.53 你可以通过拼接字符串来测试以确保它是正确的：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { f := 5524.53 fmt.Println(\u0026#34;Sammy has \u0026#34; + fmt.Sprint(f) + \u0026#34; points.\u0026#34;) } Output Sammy has 5524.53 points. 你可以确定你的浮点数已正确转换为字符串，因为拼接执行时没有报错。\n将字符串转换为数字 # 可以使用 Go 标准库中的 strconv 包将字符串转换为数字。strconv 包具有转换整数和浮点数类型的功能。这是接受用户输入时非常常见的操作。例如，如果你有一个程序询问一个人的年龄，当他们输入值时，它会被捕获为 字符串 。然后，你需要将其转换为 int 以对其进行任何数学运算。\n如果你的字符串没有小数位，你很可能希望使用 strconv.Atoi 函数将其转换为整数。如果你知道你将使用数字作为浮点数，你会使用strconv.ParseFloat。\n让我们使用用户 Sammy 跟踪每天编写的代码行的示例。你可能希望使用运算符来操作这些值，以便为用户提供更有趣的反馈，但这些值当前存储在字符串中：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { lines_yesterday := \u0026#34;50\u0026#34; lines_today := \u0026#34;108\u0026#34; lines_more := lines_today - lines_yesterday fmt.Println(lines_more) } Output invalid operation: lines_today - lines_yesterday (operator - not defined on string) 因为这两个数值存储在字符串中，所以你收到报错。减法运算符 - 不能对两个字符串执行。\n修改代码来增加 strconv.Atoi() 方法，该方法能将字符串转换为整数，这将允许你对最初是字符串的值进行数学运算。因为在将字符串转换为整数时可能会失败，所以你必须检查是否有任何报错。你可以使用 if 语句来检查你的转换是否成功。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { lines_yesterday := \u0026#34;50\u0026#34; lines_today := \u0026#34;108\u0026#34; yesterday, err := strconv.Atoi(lines_yesterday) if err != nil { log.Fatal(err) } today, err := strconv.Atoi(lines_today) if err != nil { log.Fatal(err) } lines_more := today - yesterday fmt.Println(lines_more) } 因为字符串可能不是数字，所以 strconv.Atoi() 方法将返回转换后的类型以及潜在的错误。当使用 strconv.Atoi 函数从 lines_yesterday 转换时，你必须检查 err 返回值以确保该值已被转换。如果 err 不是 nil，则意味着 strconv.Atoi 无法成功将字符串值转换为整数。在这个例子中，你使用了一个 if 语句来检查错误，如果返回了一个错误，你使用了 log.Fatal 来记录错误并退出程序。\n当你运行前面的代码时，你会得到：\nOutput 58 现在尝试转换一个不是数字的字符串：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { a := \u0026#34;not a number\u0026#34; b, err := strconv.Atoi(a) fmt.Println(b) fmt.Println(err) } 你将收到以下报错：\nOutput 0 strconv.Atoi: parsing \u0026#34;not a number\u0026#34;: invalid syntax 因为声明了 b，但 strconv.Atoi 未能进行转换，所以 b 没能被赋值。请注意，b 的值为 0 。这是因为 Go 有默认值，在 Go 中称为零值。strconv.Atoi 返回了一个错误，描述了为什么它无法转换字符串。\n转换字符串和字节 # Go 中的字符串存储为字节切片。在 Go 中，你可以通过将其包装在 []byte() 和 string() 的相应转换中来在字节切片和字符串之间进行转换：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a := \u0026#34;my string\u0026#34; b := []byte(a) c := string(b) fmt.Println(a) fmt.Println(b) fmt.Println(c) } 在这里，你将字符串存储在 a 中，然后将其转换为字节切片b，然后将字节切片转换回字符串并赋值给c。最后打印出来：\nOutput my string [109 121 32 115 116 114 105 110 103] my string 输出的第一行是原始字符串 my string。打印出来的第二行是组成原始字符串的字节切片。第三行显示字节切片可以安全地转换回字符串并打印出来。\n结论 # 本 Go 教程主要演示了如何通过内置方法将几种重要的数据类型转换为其他数据类型。能够在 Go 中转换数据类型将允许你执行诸如接受用户输入和跨不同数字类型进行数学运算之类的事情。稍后，当你使用 Go 编写接受来自许多不同来源（如数据库和 API）的数据的程序时，你将使用这些转换方法来确保你可以对数据进行操作。你还可以通过将数据转换为更小的数据类型来优化存储。\n如果你想深入分析 Go 中的数据类型，请查看我们的 理解 Go 中的数据类型 文章。\n"},{"id":12,"href":"/How-To-Code-in-Go/docs/13-How_To_Do_Math_in_Go_with_Operators/","title":"13 How to Do Math in Go With Operators","section":"Docs","content":" 如何用运算符在 Go 中做数学计算 # 介绍 # 数字在编程中很常见。它们被用来表示一些东西，如：屏幕大小的尺寸、地理位置、金钱和积分、视频中经过的时间、游戏头像的位置、通过分配数字代码表示的颜色等等。\n在编程中进行数学运算是一项重要的技能，因为你会经常与数字打交道。尽管对数学的理解肯定能帮助你成为一个更好的程序员，但它不是一个先决条件。如果你没有数学背景，试着把数学看作是完成你想实现的目标的工具，并作为提高你的逻辑思维能力的一种方式。\n我们将使用 Go 中最常用的两种数字数据类型，整数和浮点数。\n整数是可以是正数、负数或 0 的整数（\u0026hellip;，-1，0，1，\u0026hellip;）。 浮点数是包含小数点的实数，如 9.0 或 2.25 \u0026hellip; 本教程将回顾我们在 Go 中对数字数据类型可以使用的运算符。\n运算符 # 运算符是一个表示运算的符号或函数。例如，在数学中，加号或 + 是表示加法的运算符。\n在 Go 中，我们将看到一些熟悉的运算符，这些运算符是从数学中带来的。然而，我们将使用的其他运算符是计算机编程中特有的。\n下面是 Go 中与数学有关的运算符的快速参考表。在本教程中，我们将涵盖以下所有的运算。\n预算符的返回\nx + y 是 x 和 y 的总和\nx - y 是 x 和 y 之差\n-x 表示 x 为负数特性\n+x' 表示 x\u0026rsquo; 为正数特性\nx * y 是 x 和 y 的积\nx / y 是 x 和 y 的商\nx % y 是 x / y 的余\n我们还将讨论复合赋值运算符，包括 += 和 *=，它们将算术运算符和 = 运算符结合起来。\n加法和减法 # 在 Go 中，加法和减法运算符的表现与数学中一样。事实上，你可以把 Go 编程语言当作计算器来使用。\n让我们看看一些例子，从整数开始：\nfmt.Println(1 + 5) Output 6 我们可以通过使用下面的语法来初始化变量以代表整数值，而不是直接将整数传入fmt.Println 语句：\na := 88 b := 103 fmt.Println(a + b) Output 191 因为整数既可以是正数也可以是负数（也可以是 0），所以我们可以将一个负数与一个正数相加：\nc := -36 d := 25 fmt.Println(c + d) Output -11 浮点数的加法也类似：\ne := 5.5 f := 2.5 fmt.Println(e + f) Output 8 因为我们把两个浮点数加在一起，Go 返回了一个带有小数位的浮点数。然而，由于在这种情况下，小数位是零，fmt.Println 放弃了小数位的格式化。为了正确格式化输出，我们可以使用 fmt.Printf 和谓词 %.2f，它将格式化为两个小数位，就像这个例子：\nfmt.Printf(\u0026#34;%.2f\u0026#34;, e + f) Output 8.00 减法的语法与加法相同，只是我们将运算符从加号（+）改为减号（-）：\ng := 75.67 h := 32.0 fmt.Println(g - h) Output 43.67 在 Go 中，我们只能对相同的数据类型使用运算符。我们不能把一个 int 和一个 float64 加在一起：\ni := 7 j := 7.0 fmt.Println(i + j) Output i + j (mismatched types int and float64) 试图在不相同的数据类型上使用运算符将导致编译器错误。\n单项算术运算 # 一个单数的数学表达式只由一个成员或元素组成。在 Go 中，我们可以使用加号和减号作为与一个值配对的单一元素：返回值的特性（+），或改变值的符号（-）。\n虽然不常用，但加号表示值的特性。我们可以对正值使用加号：\ni := 3.3 fmt.Println(+i) Output 3.3 当我们使用加号与一个负值时，它也将返回该值的特性，在这种情况下它将是一个负值：\nj := -19 fmt.Println(+j) Output -19 对于一个负值，加号会返回同样的负值。\n然而，减号会改变一个数值的符号。因此，当我们传递一个正值时，我们会发现值前的减号会返回一个负值：\nk := 3.3 fmt.Println(-k) Output -3.3 另外，当我们使用负值的减号单选运算符时，将返回一个正值：\nj := -19 fmt.Println(-j) Output 19 由加号和减号表示的单项算术运算，在 +i 的情况下会返回值的同一性，或者像 -i 那样返回值的相反符号。\n乘法和除法 # 像加法和减法一样，乘法和除法看起来与数学中的情况非常相似。我们在 Go 中用于乘法的符号是 *，用于除法的符号是 /。\n下面是一个在 Go 中对两个浮点数进行乘法的例子：\nk := 100.2 l := 10.2 fmt.Println(k * l) Output 1022.04 在 Go 中，除法有不同的特点，这取决于我们要除的数字类型。\n如果我们要除以整数，Go 可以使用 / 运算符来执行除法，对于商 x，返回的数字是小于或等于 x 的最大整数。\n如果你运行下面这个除法80 / 6 的例子，你会收到 13 作为输出，数据类型是int：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { m := 80 n := 6 fmt.Println(m / n) } Output 13 如果想要的输出是浮点数，你必须在除法之前明确地转换这些数值。\n你可以用 float32() 或 float64() 包裹你想要的浮点数类型来实现：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { s := 80 t := 6 r := float64(s) / float64(t) fmt.Println(r) } Output 13.333333333333334 取模 # % 运算符是取模，它返回除法后的余数而不是商。这对于寻找同一数字的倍数是很有用的。\n让我们看一个取模的例子:\no := 85 p := 15 fmt.Println(o % p) Output 10 分开来看，85 除以 15 会返回 5 的商和 10 的余数。我们的程序在这里返回值 10，因为模运算符返回除法表达式的剩余部分。\n要对 float64 数据类型进行模数计算，你将使用 math 包中的 Mod 函数：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { q := 36.0 r := 8.0 s := math.Mod(q, r) fmt.Println(s) } Output 4 运算符优先级 # 在 Go 中，就像在数学中一样，我们需要牢记，运算符将按照优先顺序进行评估，而不是从左到右或从右到左。\n如果我们看一下下面这个数学表达式：\nu = 10 + 10 * 5 我们可以从左往右读，但是乘法会先进行，所以如果我们要打印 `u\u0026rsquo;，我们会收到以下数值：\nOutput 60 这是因为 10 * 5 被计算为 50，然后我们加上 10，返回 60 作为最终结果。\n如果我们想把10加到10上，然后把这个和乘以 5，我们在 Go 中使用括号，就像在数学中那样：\nu := (10 + 10) * 5 fmt.Println(u) Output 100 记住操作顺序的一个方法是通过缩写 PEMDAS：\n字母顺序代表的是\n1 P Parentheses 括号\n2 E Exponent 指数\n3 M Multiplication 乘法\n4 D Division 除法\n5 A Addition 加法\n6 S Subtraction 减法\n你可能熟悉另一个关于运算顺序的缩写，如 BEDMAS 或 BODMAS。无论哪种缩写对你来说都是有效的，在 Go 中进行数学运算时，尽量记住它，以便返回你所期望的结果。\n赋值运算符 # 最常见的赋值运算符是你已经使用过的：等号 =。= 赋值运算符将右边的值分配给左边的变量。例如，v = 23 将整数 23 的值分配给变量 v。\n在编程时，通常使用复合赋值运算符，对一个变量的值进行运算，然后将得到的新值赋给该变量。这些复合运算符将一个算术运算符和 = 运算符结合起来。因此，对于加法，我们将 + 和 = 结合起来，得到复合运算符 +=。让我们看看这看起来像什么：\nw := 5 w += 1 fmt.Println(w) Output 6 首先，我们设置变量 w 等于 5 的值，然后我们使用 += 复合赋值运算符将右边的数字加到左边变量的值上，然后将结果赋给 w。\n复合赋值运算符在 for 循环的情况下经常使用，当你想重复一个过程几次时，就会用到它：\npackage main import \u0026#34;fmt\u0026#34; func main() { values := []int{0, 1, 2, 3, 4, 5, 6} for _, x := range values { w := x w *= 2 fmt.Println(w) } } Output0 2 4 6 8 10 12 通过使用 for 循环遍历名为 values 的切片，你能够自动完成 *= 运算符的过程，该运算符将变量 w 乘以数字 2，然后将结果分配回变量 w。\nGo 对本教程中讨论的每个算术运算符都有一个复合赋值运算符。\n要添加然后赋值：\ny += 1 做减法，然后赋值：\ny -= 1 做乘法，然后再赋值：\ny *= 2 做除法，然后再赋值：\ny /= 3 取余，然后再赋值：\ny %= 3 当需要逐步增加或减少时，或者当你需要将程序中的某些过程自动化时，复合赋值运算符就很有用。\n总结 # 本教程涵盖了许多你将在整数和浮点数数据类型中使用的运算符。你可以在理解 Go 的数据类型和如何在 Go 中转换数据类型中了解更多关于不同的数据类型。\n"},{"id":13,"href":"/How-To-Code-in-Go/docs/14-Understanding_Boolean_Logic_in_Go/","title":"14 Understanding Boolean Logic in Go","section":"Docs","content":" 了解 Go 中的布尔逻辑 # 布尔数据类型（bool）可以是两个值中的一个，即真或假。布尔型数据在编程中被用来进行比较和控制程序的流程。\nBoolean 在 Go 中的数据类型是bool，全部小写。值 true 和 false 总是分别用小写的 t 和 f，因为它们是 Go 中的特殊值。\n本教程将涵盖你需要了解 bool 数据类型如何工作的基础知识，包括布尔比较、逻辑运算符和真值表。\n比较运算符 # 在编程中，比较运算符被用来比较数值，并计算为一个单一的布尔值，即真或假。\n下表展示了布尔比较运算符。\n运算符的含义\n== 等于\n!= 不等于\n\u0026lt; 少于\n\u0026gt; 大于\n\u0026lt;= 少于等于\n\u0026gt;= 大于等于\n为了了解这些运算符的工作原理，我们在 Go 程序中把两个整数分配给两个变量：\nx := 5 y := 8 在这个例子中，由于 x 的值是5，y 的值是 8，所以 x 小于 y。\n使用这两个变量和它们的相关值，让我们回忆一下之前的运算符。在这个程序中，你用 Go 打印出每个比较运算符的值是真还是假。为了帮助更好地理解这个输出，Go 打印一个字符串来显示它正在计算的内容。\npackage main import \u0026#34;fmt\u0026#34; func main() { x := 5 y := 8 fmt.Println(\u0026#34;x == y:\u0026#34;, x == y) fmt.Println(\u0026#34;x != y:\u0026#34;, x != y) fmt.Println(\u0026#34;x \u0026lt; y:\u0026#34;, x \u0026lt; y) fmt.Println(\u0026#34;x \u0026gt; y:\u0026#34;, x \u0026gt; y) fmt.Println(\u0026#34;x \u0026lt;= y:\u0026#34;, x \u0026lt;= y) fmt.Println(\u0026#34;x \u0026gt;= y:\u0026#34;, x \u0026gt;= y) } Output x == y: false x != y: true x \u0026lt; y: true x \u0026gt; y: false x \u0026lt;= y: true x \u0026gt;= y: false 遵循数学逻辑，Go 从表达式中计算了以下内容：\n5（x）等于 8（y）吗？假 5 不等于 8 吗？真 5 小于 8 吗？真 5 是否大于 8？假 5 是否小于或等于 8？真 5 不小于或等于 8 吗？假 虽然这里使用的是整数，但你可以用浮点数来代替。\n字符串也可以和布尔运算符一起使用。它们是区分大小写的，除非你使用一个额外的字符串方法。\n你可以看一下字符串在实践中是如何比较的：\nSammy := \u0026#34;Sammy\u0026#34; sammy := \u0026#34;sammy\u0026#34; fmt.Println(\u0026#34;Sammy == sammy: \u0026#34;, Sammy == sammy) Output Sammy == sammy: false 字符串 Sammy 不等于字符串 sammy，因为它们不完全相同；一个以大写字母 S 开头，另一个以小写字母 s 开头。但是，如果你添加了另一个变量，该变量被分配了 Sammy 的值，那么它们的值将相等。\nSammy := \u0026#34;Sammy\u0026#34; sammy := \u0026#34;sammy\u0026#34; alsoSammy := \u0026#34;Sammy\u0026#34; fmt.Println(\u0026#34;Sammy == sammy: \u0026#34;, Sammy == sammy) fmt.Println(\u0026#34;Sammy == alsoSammy\u0026#34;, Sammy == alsoSammy) Output Sammy == sammy: false Sammy == alsoSammy true 你还可以使用其他比较运算符，包括 \u0026gt; 和 \u0026lt; 来比较两个字符串。Go 将使用字符的 ASCII 值对这些字符串进行按字母顺序的比较。\n你也可以用比较运算符计算布尔值：\nt := true f := false fmt.Println(\u0026#34;t != f: \u0026#34;, t != f) Output t != f: true 前面的代码块计算了 true 不等于 false。\n注意两个运算符 = 和 == 之间的区别。\nx = y // Sets x equal to y x == y // Evaluates whether x is equal to y 第一个 = 是赋值运算符，它将设置一个值等于另一个值。第二个 == 是一个比较运算符，将评估两个值是否相等。\n逻辑运算符 # 有两个逻辑运算符被用来比较数值。它们将表达式评估为布尔值，返回 true 或 false。这些运算符是 \u0026amp;\u0026amp;，||，和 ！，下面的列表中为定义：\n\u0026amp;\u0026amp; (x \u0026amp;\u0026amp; y) 是 and 运算符。如果两个语句都是真，它就是真。\n|| (x || y) 是 or 运算符。如果至少有一个语句是真，它就是真。\n! (!x)是 not 运算符。只有当语句为假时，它才为真。\n逻辑运算符通常用于计算两个或多个表达式是真还是假。例如，它们可以用来确定成绩是否合格，以及学生是否在课程中注册，如果这两种情况都是真，那么该学生将在系统中被分配一个成绩。另一个例子是根据用户是否有商店信用或在过去6个月内有购买行为，来确定用户是否是一个网上商店的有效活跃客户。\n为了理解逻辑运算符的工作原理，我们来评估三个表达式：\nfmt.Println((9 \u0026gt; 7) \u0026amp;\u0026amp; (2 \u0026lt; 4)) // Both original expressions are true fmt.Println((8 == 8) || (6 != 6)) // One original expression is true fmt.Println(!(3 \u0026lt;= 1)) // The original expression is false Output true true true 在第一种情况下，fmt.Println((9 \u0026gt; 7) \u0026amp;\u0026amp; (2 \u0026lt; 4))，9 \u0026gt; 7 和 2 \u0026lt; 4 都计算为真，因为使用了and 运算符。\n在第二种情况下，fmt.Println((8 == 8) || (6 != 6))，由于8 == 8 为真，6 != 6 为假，因为使用了 or 运算符所以结果为真。如果你使用的是 and 运算符，那么这个结果将是假。\n在第三种情况下，fmt.Println(!(3 \u0026lt;= 1))，not 运算符否定了 3 \u0026lt;=1 返回的错误值。\n让我们用浮点数代替整数，并以假为目标：\nfmt.Println((-0.2 \u0026gt; 1.4) \u0026amp;\u0026amp; (0.8 \u0026lt; 3.1)) // One original expression is false fmt.Println((7.5 == 8.9) || (9.2 != 9.2)) // Both original expressions are false fmt.Println(!(-5.7 \u0026lt;= 0.3)) // The original expression is true 在这个例子中：\nand 必须至少有一个假则计算为假。 or 必须两个表达式都为假则计算为假。 ! 必须使其内部表达式为真，新表达式才为假。 如果这些结果对你来说不清楚，可以通过一些真值表来进一步澄清。\n你也可以用 \u0026amp;\u0026amp;、|| 和 ！ 来写复合语句：\n!((-0.2 \u0026gt; 1.4) \u0026amp;\u0026amp; ((0.8 \u0026lt; 3.1) || (0.1 == 0.1))) 先看一下最里面的表达式：(0.8 \u0026lt; 3.1) || (0.1 == 0.1)。这个表达式计算为 true，因为两个数学语句都是 true。\n接下来，Go 将返回值 true 与下一个内部表达式相结合：(-0.2 \u0026gt; 1.4) \u0026amp;\u0026amp; (true)。这个例子返回false，因为数学语句 -0.2 \u0026gt; 1.4 是假，而（false）和（true）返回 false。\n最后，我们有一个外层表达式：！(false)，它的值是 true，所以如果我们把这个语句打印出来，最后的返回值是：\nOutput true 逻辑运算符 \u0026amp;\u0026amp;、|| 和 ！ 用于计算并返回布尔值。\n真值表 # 关于数学的逻辑分支，有很多东西需要学习，但你可以有选择地学习一些，以提高你编程时的算法思维。\n下面是比较运算符 ==，以及每个逻辑运算符 \u0026amp;\u0026amp;，|| 和 ！ 的真值表。虽然你可能能够推理出它们，但记住它们也是有帮助的，因为这可以使你的编程决策过程更快。\n== (equal) 真值表\nx == y 返回\ntrue == true true\ntrue == false false\nfalse == true false\nfalse == false true\n\u0026amp;\u0026amp; (and) 真值表\nx and y 返回\ntrue and true true\ntrue and false false\nfalse and true false\nfalse and false false\n|| (or) 真值表\nx or y 返回\ntrue or true true\ntrue or false true\nfalse or true true\nfalse or false false\n! (not) 真值表\nnot x Returns\nnot true false\nnot false true\n真值表是逻辑学中常用的数学表，在构建计算机编程中的算法（指令）时，真值表是很有用的，可以牢记在心。\n使用布尔运算符进行流程控制 # 为了以流程控制语句的形式控制程序的流程和结果，你可以使用一个 condition 和一个 clause 。\n一个 condition 计算出一个布尔值的真或假，提出了一个在程序中做出决定的点。也就是说，一个条件会告诉你某个东西的值是真还是假。\nclause 是跟在 condition 后面的代码块，它决定了程序的结果。也就是说，\u0026ldquo;如果 x 是 true，那就往下执行\u0026rdquo;。\n下面的代码块显示了一个比较运算符与条件语句协同工作的例子，以控制 Go 程序的流程：\nif grade \u0026gt;= 65 { // Condition fmt.Println(\u0026#34;Passing grade\u0026#34;) // Clause } else { fmt.Println(\u0026#34;Failing grade\u0026#34;) } 这个程序将评估每个学生的成绩是合格还是不合格。如果一个学生的成绩是 83，第一条语句为 true，并且将触发 Passing grade 的打印语句。如果学生的成绩是 59，第一条语句为 false，所以程序将继续执行与 else 表达式相关的打印语句：Failing grade。\n布尔运算符提出的条件，可以通过流程控制语句来决定程序的最终结果。\n总结 # 本教程介绍了属于布尔类型的比较和逻辑运算符，以及真值表和使用布尔类型进行程序流程控制。\n"},{"id":14,"href":"/How-To-Code-in-Go/docs/15-Understanding_Maps_in_Go/","title":"15 Understanding Maps in Go","section":"Docs","content":" 理解 Go 中的 Map # 大多数现代编程语言都有_字典_或_哈希_类型的概念。这些类型通常用于以成对的方式存储数据，其中的key映射到value。\n在 Go 中，map 数据类型就是大多数程序员认为的字典类型。它将键映射到值，形成键值对，是 Go 中存储数据的一种有效方式。一个 map 的构造是通过使用关键字 map，然后是方括号中的键数据类型 [ ]，接着是值数据类型。然后将键值对放在大括号的两侧 { } 中。\nmap[key]value{} 通常在 Go 中使用 map 来保存相关数据，例如 ID 中包含的信息。一个有数据的 map 看起来像这样。\nmap[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} 除了大括号外，整个 map 中还有冒号连接键值对。冒号左边的字是键。键值可以是 Go 中可比较的类型，如 strings、ints 等。\n示例 map 中的键是：\n\u0026quot;name\u0026quot; \u0026quot;animal\u0026quot; \u0026quot;color\u0026quot; \u0026quot;location\u0026quot; 冒号右边的字是值，值可以是任何数据类型。示例 map 中的值是：\n\u0026quot;Sammy\u0026quot; \u0026quot;shark\u0026quot; \u0026quot;blue\u0026quot; \u0026quot;ocean\u0026quot; 像其他数据类型一样，你可以将 map 存储在一个变量内，并将其打印出来：\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} fmt.Println(sammy) 输出为：\nOutput map[animal:shark color:blue location:ocean name:Sammy] 键值对的顺序可能发生了变化。在 Go 中，map 数据类型是无序的。无论顺序如何，键值对将保持不变，你能够根据键值关系来访问数据。\n获取 map 元素 # 你可以通过引用相关的键来获取一个 map 的值。由于 map 提供了存储数据的键值对，它们可以成为你的 Go 程序中重要而有用的东西。\n如果你想获取 Sammy 的用户名，你可以通过调用 sammy[\u0026quot;name\u0026quot;] 来实现；持有你的 map 和相关键的变量。我们把它打印出来：\nfmt.Println(sammy[\u0026#34;name\u0026#34;]) 输出的值如下：\nOutput Sammy map 的行为就像一个数据库；而不是像分片那样调用一个整数来获得一个特定的索引值，你把一个值分配给一个键，然后调用这个键来获得它的相关值。\n通过调用键 name，你会得到该键的值，也就是 Sammy。\n类似地，你可以用同样的格式调用 sammy 映射中的其余值：\nfmt.Println(sammy[\u0026#34;animal\u0026#34;]) // returns shark fmt.Println(sammy[\u0026#34;color\u0026#34;]) // returns blue fmt.Println(sammy[\u0026#34;location\u0026#34;]) // returns ocean 通过利用 map 数据类型中的键值对，你可以引用键来查询值。\n键和值 # 与某些编程语言不同，Go 没有任何方便的函数来列出 map 的键或值。比如 Python 可以用 .keys() 方法来查看所有的键。然而，它允许通过使用 range 操作符来进行迭代查看：\nfor key, value := range sammy { fmt.Printf(\u0026#34;%q is the key for the value %q\\n\u0026#34;, key, value) } 当在 Go 中对一个 map 进行 range 遍历时，它将返回两个值。第一个值是键，第二个值是值。Go 将以正确的数据类型创建这些变量。在这个例子中，map 的键是一个 string，所以 key 也将是一个字符串。value 也是一个字符串：\nOutput animal\u0026#34; is the key for the value \u0026#34;shark\u0026#34; \u0026#34;color\u0026#34; is the key for the value \u0026#34;blue\u0026#34; \u0026#34;location\u0026#34; is the key for the value \u0026#34;ocean\u0026#34; \u0026#34;name\u0026#34; is the key for the value \u0026#34;Sammy\u0026#34; 要获得一个只有键的列表，你可以再次使用 range 操作符。你可以只声明一个变量，只访问键：\nkeys := []string{} for key := range sammy { keys = append(keys, key) } fmt.Printf(\u0026#34;%q\u0026#34;, keys) 程序一开始就声明了一个切片来存储你的键。\n只输出 map 的所有键：\nOutput [\u0026#34;color\u0026#34; \u0026#34;location\u0026#34; \u0026#34;name\u0026#34; \u0026#34;animal\u0026#34;] 同样，这些键没有被排序。如果你想对它们进行排序，你可以使用sort包中的 sort.Strings 函数：\nsort.Strings(keys) 使用这个函数，你会收到以下输出：\nOutput [\u0026#34;animal\u0026#34; \u0026#34;color\u0026#34; \u0026#34;location\u0026#34; \u0026#34;name\u0026#34;] 你可以使用同样的模式来检索一个 map 中的值。在下一个例子中，你预先分配了切片以避免分配，从而使程序更有效率：\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} items := make([]string, len(sammy)) var i int for _, v := range sammy { items[i] = v i++ } fmt.Printf(\u0026#34;%q\u0026#34;, items) 首先，你声明一个切片来存储键；因为你知道需要多少个元素，你可以通过定义切片的大小来避免潜在的内存分配。然后你声明索引变量。由于你不想要这个键而使用 _ 操作符，当开始循环时，忽略这个键的值。输出将如下：\nOutput [\u0026#34;ocean\u0026#34; \u0026#34;Sammy\u0026#34; \u0026#34;shark\u0026#34; \u0026#34;blue\u0026#34;] 要查看一个 map 中的元素数量，可以使用内置的len函数：\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} fmt.Println(len(sammy)) 输出展示 map 中的元素数量：\nOutput 4 尽管 Go 没有提供获取键和值的便利函数，但在需要时只需要几行代码就可以检索到键和值。\n检查存在性 # 当请求的键不存在时，Go 中的 map 将为 map 的值类型返回零值。正因为如此，你需要用另一种方法来区分存储零值和不存在的键。\n我们来查询 map 中的一个不存在的键，并看看返回的值：\ncounts := map[string]int{} fmt.Println(counts[\u0026#34;sammy\u0026#34;]) 你会看到一下输出：\nOutput 0 即使键 sammy 不在 map 中，Go 仍然返回 0 。这是因为值的数据类型是 int，由于 Go 中所有的变量都有零值，所以它返回的是 0 的零值。\n在很多情况下，这是不可取的，会导致你的程序出现错误。在查找 map 中的值时，Go 可以返回两个值。这第二个值是一个 bool 类型，如果找到了键，则为 true ，如果没有找到键，则为 false。在 Go 中，惯用变量名为 ok。尽管你可以把捕捉第二个参数的变量命名为任何名字，但在 Go 中，ok 是一种惯用方式：\ncount, ok := counts[\u0026#34;sammy\u0026#34;] 如果键 sammy 存在于 counts map 中，那么 ok 将是 true。否则，ok 将是 false。\n你可以使用 ok 变量来决定在你的程序中做什么：\nif ok { fmt.Printf(\u0026#34;Sammy has a count of %d\\n\u0026#34;, count) } else { fmt.Println(\u0026#34;Sammy was not found\u0026#34;) } 输出结果如下：\nOutput Sammy was not found 在 Go 中，你可以将变量声明和条件检查与 if/else 相结合。这使得你可以使用一个单一的语句来进行这种检查：\nif count, ok := counts[\u0026#34;sammy\u0026#34;]; ok { fmt.Printf(\u0026#34;Sammy has a count of %d\\n\u0026#34;, count) } else { fmt.Println(\u0026#34;Sammy was not found\u0026#34;) } 在 Go 中从 map 中查询一个值时，检查其是否存在是很好的做法，以避免程序中出现错误。\n修改 map # map 是一个可变的数据结构，所以你可以修改它们。让我们在本节中看看添加和删除 map 的元素。\n增加和修改 map 的元素 # 在不使用方法或函数的情况下，你可以向 map 添加键值对。你可以使用 map 的变量名，然后是方括号中的键值 [ ]，并使用 = 操作符来设置一个新值：\nmap[key] = value 你可以通过在一个名为 usernames 的 map 上添加一个键值对来看到这个行为：\nusernames := map[string]string{\u0026#34;Sammy\u0026#34;: \u0026#34;sammy-shark\u0026#34;, \u0026#34;Jamie\u0026#34;: \u0026#34;mantisshrimp54\u0026#34;} usernames[\u0026#34;Drew\u0026#34;] = \u0026#34;squidly\u0026#34; fmt.Println(usernames) 输出将展示 map 中新的 Drew:squidly 键值对：\nOutput map[Drew:squidly Jamie:mantisshrimp54 Sammy:sammy-shark] 因为 map 是无序返回的，这一对键值可以出现在 map 输出的任何地方。如果你程序后面使用 usernames 的 map，它将包括新加的这个键值对。\n你也可以使用这个语法来修改一个键的值。在这种情况下，你引用一个现有的键，并传递一个不同的值给它。\n考虑一个名为 followers 的 map，它记录某个网络上用户的粉丝。用户 drew 今天的粉丝增加了，所以你需要更新 drew 键的整数值。可以使用 Println() 函数来检查 map 是否被修改：\nfollowers := map[string]int{\u0026#34;drew\u0026#34;: 305, \u0026#34;mary\u0026#34;: 428, \u0026#34;cindy\u0026#34;: 918} followers[\u0026#34;drew\u0026#34;] = 342 fmt.Println(followers) 以下输出了 drew 更新后的值：\nOutput map[cindy:918 drew:342 mary:428] 你可以用这种方法将键值对添加到用户输入的 map 中。让我们写一个快速程序 usernames.go，它在命令行上运行，允许用户输入，以增加更多的名字和相关的用户名：\nusernames.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { usernames := map[string]string{\u0026#34;Sammy\u0026#34;: \u0026#34;sammy-shark\u0026#34;, \u0026#34;Jamie\u0026#34;: \u0026#34;mantisshrimp54\u0026#34;} for { fmt.Println(\u0026#34;Enter a name:\u0026#34;) var name string _, err := fmt.Scanln(\u0026amp;name) if err != nil { panic(err) } name = strings.TrimSpace(name) if u, ok := usernames[name]; ok { fmt.Printf(\u0026#34;%q is the username of %q\\n\u0026#34;, u, name) continue } fmt.Printf(\u0026#34;I don\u0026#39;t have %v\u0026#39;s username, what is it?\\n\u0026#34;, name) var username string _, err = fmt.Scanln(\u0026amp;username) if err != nil { panic(err) } username = strings.TrimSpace(username) usernames[name] = username fmt.Println(\u0026#34;Data updated.\u0026#34;) } } 在 usernames.go 中，你首先定义 map。然后设置了一个循环来迭代名字。你要求用户输入一个名字，并声明一个变量来存储它。接下来检查是否有错误；如果有，程序将以 panic 退出。因为 Scanln 捕获了整个输入，包括回车，你需要从输入中删除空格；你可以用 strings.TrimSpace 函数来做这个。\nif 代码块检查名字是否存在于 map 中并打印反馈。如果名字是存在的，则继续回到循环的顶部。如果名字不在 map 中，它会向用户提供反馈，然后会要求提供一个新的用户名。程序再次检查，看是否有错误。如果没有错误，它就去掉回车键，将用户名的值分配给名字键，然后打印出数据被更新的反馈。\n让我们在命令行上运行该程序：\ngo run usernames.go 你将看到如下输出：\nOutput Enter a name: Sammy \u0026#34;sammy-shark\u0026#34; is the username of \u0026#34;Sammy\u0026#34; Enter a name: Jesse I don\u0026#39;t have Jesse\u0026#39;s username, what is it? JOctopus Data updated. Enter a name: 完成测试后，可以通过 CTRL + C 键退出程序。\n这展示了你如何以交互方式修改 map。对于这个特殊的程序，只要你用 CTRL + C 退出程序，你就会丢失所有的数据，除非你实现了处理读写文件的方法。\n总结一下，你可以用 map[key] = value 语法向 map 添加元素或修改值。\n删除 map 的元素 # 正如你可以在 map 数据类型中添加键值对和改变数值一样，你也可以在 map 中删除元素。\n要从一个 map 中删除一个键值对，你可以使用内置函数 delete()。第一个参数是你想要删除的 map。第二个参数是你要删除的键：\ndelete(map, key) 我们定义一个名为 permission 的 map：\npermissions := map[int]string{1: \u0026#34;read\u0026#34;, 2: \u0026#34;write\u0026#34;, 4: \u0026#34;delete\u0026#34;, 8: \u0026#34;create\u0026#34;, 16:\u0026#34;modify\u0026#34;} 你不再需要 modify 变量，所以你要把它从 map 上删除。然后，你要打印出 map，以确认它被删除。\npermissions := map[int]string{1: \u0026#34;read\u0026#34;, 2: \u0026#34;write\u0026#34;, 4: \u0026#34;delete\u0026#34;, 8: \u0026#34;create\u0026#34;, 16: \u0026#34;modify\u0026#34;} delete(permissions, 16) fmt.Println(permissions) 输出如下：\nOutput map[1:read 2:write 4:delete 8:create] 这一行 delete(permissions, 16) 从 permissions map 中移除键值对 16: \u0026quot;modify\u0026quot;。\n如果你想清除一个 map 的所有值，你可以通过把它设置为一个相同类型的空 map 来实现。这将创建一个新的空 map 来使旧的 map 被垃圾收集器清除。\n让我们删除 permissions map 中的所有元素：\npermissions = map[int]string{} fmt.Println(permissions) 输出展示 map 为空：\nOutput map[] 因为 map 是可变的数据类型，它们可以被添加、修改、删除和清除元素。\n总结 # 本教程探讨了 Go 中的 map 数据结构。map 是由键值对组成的，提供了一种不依赖索引的数据存储方式。这使得我们可以根据其含义和与其他数据类型的关系来检索数值。\n"},{"id":15,"href":"/How-To-Code-in-Go/docs/16-Understanding_Arrays_and_Slices_in_Go/","title":"16 Understanding Arrays and Slices in Go","section":"Docs","content":" 理解 Go 中的数组和切片 # 介绍 # 在 Go 中，数组和切片是数据结构，由元素的有序序列组成。当你想处理许多相关的值时，这些数据集合是很好的选择。它们可以让你把相同类型的数据放在一起，降低代码量，并同时对多个值执行相同的方法和操作。\n虽然 Go 中的数组和切片都是元素的有序序列，但两者之间有很大的区别。Go 中的数组是一个数据结构，由一个有序的元素序列组成，其容量在创建时已经定义。一旦数组分配了它的大小，就不能再改变它的大小。另一方面，切片是数组的可变长度版本，为使用这些数据结构的开发者提供更多的灵活性。切片其实是你在其他语言中认为的数组。\n鉴于这些差异，在一些特定的情况下，你会选择使用一个替代另一个。如果你是 Go 的新手，确定何时使用它们可能会让人困惑。尽管切片的多功能性使其在大多数情况下成为更合适的选择，但在一些特殊情况下，数组可以优化程序的性能。\n本文将详细介绍数组和切片，以便在这些数据类型之间做出适当的选择。此外，你将回顾声明和处理数组和切片的常用方法。本教程将首先提供对数组的描述以及如何操作它们，然后解释切片以及它们的区别。\n数组 # 数组是具有固定数量元素的数据结构。因为数组的大小是静态的，所以数据结构只需要分配一次内存，而可变长度的数据结构则必须动态地分配内存，以便将来可以变大或变小。尽管数组的固定长度会使它们在工作时有些僵硬，但一次性的内存分配可以提高程序的速度和性能。正因为如此，开发人员在优化程序时通常使用数组，在这种情况下，数据结构不需要可变数量的元素。\n定义一个数组 # 数组的定义是在大括号 [] 中声明数组的大小，然后是各元素的数据类型。Go 中的数组必须使其所有元素都是相同的数据类型。在数据类型之后，你可以用大括号 { } 来声明数组元素的单个值。\n下面是声明一个数组的一般模式：\n[capacity]data_type{element_values} 注意： 重要的是要记住，每一个新数组的声明都会创建一个不同的类型。所以，尽管 [2]int 和 [3]int 都有整数元素，但它们不同的长度使得它们的数据类型不兼容。\n如果你不声明数组元素的值，默认为零值，这意味着数组的元素将是空的。对于整数，用 0 表示，对于字符串，用空字符串表示。\n例如，下面的数组 numbers 有三个整数元素，但还没有值：\nvar numbers [3]int 如果你打印 numbers，会得到以下输出：\nOutput [0 0 0] 如果你想在创建数组时指定元素的值，需要将这些值放在大括号里。一个有设定值的字符串数组看起来像这样：\n[4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} 可以将一个数组存储在一个变量中并打印出来：\ncoral := [4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} fmt.Println(coral) 打印结果如下：\nOutput [blue coral staghorn coral pillar coral elkhorn coral] 请注意，当数组被打印出来时，数组中的元素之间没有划分，因此很难分辨一个元素在哪里结束，另一个元素在哪里开始。由于这个原因，有时使用 fmt.Printf 函数是很有帮助的，它可以在打印到屏幕前对字符串进行格式化。在该命令中提供 %q 谓词并加上引号：\nfmt.Printf(\u0026#34;%q\\n\u0026#34;, coral) 打印的结果如下：\nOutput [\u0026#34;blue coral\u0026#34; \u0026#34;staghorn coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34;] 现在每个元素都有引号。\\n 谓词指示格式化会在每行结束打印换行符。\n有了关于如何声明数组及其组成的概念，现在可以继续学习如何用索引号指定数组中的元素。\n索引数组和切片 # 数组中的每个元素（也包括切片）都可以通过索引单独调用。每个元素都对应着一个索引号，它是一个从索引号 0 开始向上计数的 int 值。\n在下面的例子中，我们将使用一个数组，但是你也可以使用一个切片，因为它们在索引方式上是相同的。\n对于数组 coral 来说，索引看起来像这样。\n“blue coral” “staghorn coral” “pillar coral” “elkhorn coral”\n0 1 2 3\n第一个元素，字符串 \u0026quot;blue coral\u0026quot;，从索引 0 开始，在索引为 3 的元素 \u0026quot;elkhorn coral\u0026quot;结束。\n因为切片或数组中的每个元素都有一个相应的索引号，我们能够以与其他顺序数据类型相同的方式访问和操作它们。\n现在我们可以通过引用索引号来调用切片 中的一个离散元素：\nfmt.Println(coral[1]) Output staghorn coral 这个切片的索引号范围是 0-3，如前表所示。所以要单独调用一个元素的话，我们要像这样引用索引号：\ncoral[0] = \u0026#34;blue coral\u0026#34; coral[1] = \u0026#34;staghorn coral\u0026#34; coral[2] = \u0026#34;pillar coral\u0026#34; coral[3] = \u0026#34;elkhorn coral\u0026#34; 我们调用数组 coral 的索引号如果大于 3，它就会超出范围并 panic，因为它是无效的：\nfmt.Println(coral[18]) Output panic: runtime error: index out of range 当对数组或切片进行索引时，你必须始终使用正数。不像有些语言允许你用负数进行反向索引，在 Go 中这样做会导致错误：\nfmt.Println(coral[-1]) Output invalid array index -1 (index must be non-negative) 我们可以使用 + 操作符将数组或切片中的字符串元素与其他字符串连接起来：\nfmt.Println(\u0026#34;Sammy loves \u0026#34; + coral[0]) Output Sammy loves blue coral 我们能够将索引号为 0 的字符串元素与 \u0026quot;Sammy loves\u0026quot; 的字符串连接起来。\n有了与数组或切片中的元素相对应的索引号，我们就能够单独访问每个元素，并对这些元素进行操作。为了证明这一点，我们接下来将看看如何修改某个索引的元素。\n修改元素 # 我们可以使用索引号来给元素赋值来改变数组或切片中的元素。这使我们对切片和数组中的数据有了更大的控制，并将允许我们以编程方式操作单个元素。\n如果我们想把数组 coral 中索引为 1 的元素的字符串值从 \u0026quot;staghorn coral\u0026quot; 改为 \u0026quot;foliose coral\u0026quot;，我们可以这样做：\ncoral[1] = \u0026#34;foliose coral\u0026#34; 现在，当我们打印 coral 时，数组将是不同的：\nfmt.Printf(\u0026#34;%q\\n\u0026#34;, coral) Output [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34;] 现在你知道了如何操作数组或切片的单个元素，让我们来看看几个函数，它们将在处理集合数据类型时给你更多的灵活性。\n使用 len 计算元素个数 # 在 Go 中，len() 是一个内置函数，用来帮助你处理数组和切片。像处理字符串一样，你可以用数组或切片作为参数通过使用 len() 来计算一个数组或切片的长度。\n例如，要想知道 coral 数组中有多少个元素，你可以使用：\nlen(coral) 如果你打印出数组 coral 的长度，你会收到以下输出：\nOutput 4 可以看到数据类型为 int 的数组长度为 4，这是正确的，因为数组 coral 有四个元素：\ncoral := [4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} 如果你创建一个有更多元素的整数数组，你也可以对其使用 len() 函数：\nnumbers := [13]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} fmt.Println(len(numbers)) 得到的输出如下：\nOutput 13 尽管这些例子数组的元素相对较少，但在元素非常多的数组中 len() 函数特别有用。\n接下来，我们将介绍如何向集合数据类型添加一个元素，并展示由于数组的固定长度，追加这些静态数据类型将导致错误。\n使用 append() 追加元素 # append() 是 Go 中的一个内置方法，可以向集合数据类型添加元素。然而，当这个方法用于数组时，将无法工作。如前所述，数组与切片不同的是数组的大小不能被修改。这意味着，虽然你可以改变数组中元素的值，但在定义了数组后，你不能使其变大或变小。\n让我们看看你的 coral 数组：\ncoral := [4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} 假设你想把 \u0026quot;black coral\u0026quot; 这个元素添加到这个数组中。如果你试图用 append() 函数在数组中输入：\ncoral = append(coral, \u0026#34;black coral\u0026#34;) 你将得到一个错误的输出：\nOutput first argument to append must be slice; have [4]string 为了解决这个问题，我们进一步了解切片的数据类型，如何定义一个切片，以及如何从数组转换为切片。\n切片 # 切片是 Go 中的一种数据类型，它是一个可变的数据结构，有序的元素序列。由于切片的大小是可变的，所以在使用时有更大的灵活性；当处理可能需要扩容或缩容的数据集合时，使用切片可以确保你的代码在操作集合的长度时不会出现错误。在大多数情况下，与数组相比，这种可变性值得切片有时可能需要内存重新分配。当你需要存储大量的元素或对元素进行迭代，并且你希望能够随时修改这些元素时，切片数据类型是你的首选。\n定义一个切片 # 切片的定义是通过声明数据类型，前面是一组空的方括号（[]）和大括号之间的元素列表（{}）。你会注意到，与需要在大括号之间加入 int 来声明特定长度的数组不同，一个切片在大括号之间没有任何东西来代表其可变长度。\n我们来创建一个包含字符串数据类型元素的切片：\nseaCreatures := []string{\u0026#34;shark\u0026#34;, \u0026#34;cuttlefish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;, \u0026#34;anemone\u0026#34;} 当我们打印出切片时，就可以看到切片中的元素：\nfmt.Printf(\u0026#34;%q\\n\u0026#34;, seaCreatures) 可以得到如下的输出：\nOutput [\u0026#34;shark\u0026#34; \u0026#34;cuttlefish\u0026#34; \u0026#34;squid\u0026#34; \u0026#34;mantis shrimp\u0026#34; \u0026#34;anemone\u0026#34;] 如果你想在不填充元素的情况下创建一个特定长度的切片，你可以使用内置的 make() 函数：\noceans := make([]string, 3) 打印切片将得到如下输出：\nOutput [\u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34;] 如果你想预先分配一定容量的内存，你可以向 make() 传入第三个参数：\noceans := make([]string, 3, 5) 这将给分配一个长度为 3 容量为 5 的零切片。\n你现在知道如何声明一个切片了。然而，这还没有解决我们之前在 coral 数组中遇到的错误。要在 coral 中使用 append() 函数，你首先要学会如何在一个数组中切出部分内容。\n将数组切片 # 通过使用索引号来确定开始和结束点，你可以调用一个数组内的一个分片值。这被称为对数组进行切分，你可以通过创建一个由冒号分隔的索引号范围来实现，其形式为 [first_index:second_index]。然而，需要注意的是，当对一个数组进行切分时，其结果是一个切片，而不是一个数组。\n假设你想只打印 coral 数组的中间项，而不打印第一个和最后一个元素。你可以通过创建一个从索引 1 开始，在索引 3 之前结束的分片来实现：\nfmt.Println(coral[1:3]) 运行程序会产生以下结果：\nOutput [foliose coral pillar coral] 当创建一个切片时，如 [1:3]，第一个数字是切片开始的地方（包含），第二个数字是第一个数字和你想检索的元素总数之和：\narray[starting_index : (starting_index + length_of_slice)] 在这个例子中，你调用第二个元素（或索引 1）作为起点，总共调用了两个元素。计算结果会是这样的：\narray[1 : (1 + 2)] 所以我们可以得到下面的代码：\ncoral[1:3] 如果你想把数组的开始或结束作为切片的起点或终点，你可以省略 array[first_index:second_index] 语法中的一个数字。例如，如果你想打印数组 coral 的前三个元素\u0026ndash;即 \u0026quot;blue coral\u0026quot;、\u0026quot;foliose coral\u0026quot; 和 \u0026quot;pillar coral\u0026quot; \u0026ndash; 你可以这么做：\nfmt.Println(coral[:3]) 将输出：\nOutput [blue coral foliose coral pillar coral] 这就打印了数组的开头，在索引 3 之前就停止了。\n如果要包括数组末尾的所有元素，你可以反过来使用这个语法：\nfmt.Println(coral[1:]) 这将得到以下切片：\nOutput [foliose coral pillar coral elkhorn coral] 本节讨论了通过分片来调用数组的各个部分。接下来，你将学习如何使用分片将整个数组转换为切片。\n数组转换为切片 # 如果你创建了一个数组，并决定需要它有一个可变的长度，你可以把它转换为一个切片。要将一个数组转换为切片，使用你在本教程的将数组切片步骤中学到的切片过程，只是这次要省略决定端点的两个索引号，从而选择整个切片：\ncoral[:] 请记住，你不能将变量 coral 本身转换为一个切片，因为一旦在 Go 中定义了一个变量，它的类型就不能被改变。为了解决这个问题，你可以把数组的全部内容复制到一个新的变量中作为一个切片：\ncoralSlice := coral[:] 如果你打印 coralSlice，你将得到以下输出：\nOutput [blue coral foliose coral pillar coral elkhorn coral] 现在，使用 append() 在新切片中添加 black coral 元素：\ncoralSlice = append(coralSlice, \u0026#34;black coral\u0026#34;) fmt.Printf(\u0026#34;%q\\n\u0026#34;, coralSlice) 这将输出添加了新元素的切片：\nOutput [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34; \u0026#34;black coral\u0026#34;] 我们也可以在一条 append() 语句中添加一个以上的元素：\ncoralSlice = append(coralSlice, \u0026#34;antipathes\u0026#34;, \u0026#34;leptopsammia\u0026#34;) Output [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34; \u0026#34;black coral\u0026#34; \u0026#34;antipathes\u0026#34; \u0026#34;leptopsammia\u0026#34;] 要将两个切片组合在一起，可以使用 append()，但必须使用 ... 的扩展语法来扩展第二个参数进行追加。\nmoreCoral := []string{\u0026#34;massive coral\u0026#34;, \u0026#34;soft coral\u0026#34;} coralSlice = append(coralSlice, moreCoral...) Output [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34; \u0026#34;black coral\u0026#34; \u0026#34;antipathes\u0026#34; \u0026#34;leptopsammia\u0026#34; \u0026#34;massive coral\u0026#34; \u0026#34;soft coral\u0026#34;] 现在你已经学会了如何将一个元素追加到你的切片中，我们再来看看如何删除一个元素。\n从切片中删除元素 # 与其他语言不同，Go 没有提供任何内置函数来从切片中删除元素。需要通过分片的方式从切片中删除元素。\n要删除一个元素，你必须切出该元素之前的元素，切出该元素之后的元素，然后将这两个新的切片加在一起，不包括你想删除的元素。\n如果 i 是要删除的元素的索引，那么这个过程的格式看起来就像下面这样：\nslice = append(slice[:i], slice[i+1:]...) 从 coralSlice 中，让我们删除 \u0026quot;elkhorn coral\u0026quot; 这个元素。它的索引为 3。\ncoralSlice := []string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;, \u0026#34;black coral\u0026#34;, \u0026#34;antipathes\u0026#34;, \u0026#34;leptopsammia\u0026#34;, \u0026#34;massive coral\u0026#34;, \u0026#34;soft coral\u0026#34;} coralSlice = append(coralSlice[:3], coralSlice[4:]...) fmt.Printf(\u0026#34;%q\\n\u0026#34;, coralSlice) Output[\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;black coral\u0026#34; \u0026#34;antipathes\u0026#34; \u0026#34;leptopsammia\u0026#34; \u0026#34;massive coral\u0026#34; \u0026#34;soft coral\u0026#34;] 现在索引位置 3 的元素 \u0026quot;elkhorn coral\u0026quot;，已经不在我们的切片 coralSlice 中了。\n我们也可以用同样的方法删除一个范围。假设我们不仅想删除 \u0026quot;elkhorn coral\u0026quot; 这一项，还想删除 \u0026quot;black coral\u0026quot; 和 \u0026quot;antipathes\u0026quot;。我们可以在表达式中使用一个范围来完成这个任务：\ncoralSlice := []string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;, \u0026#34;black coral\u0026#34;, \u0026#34;antipathes\u0026#34;, \u0026#34;leptopsammia\u0026#34;, \u0026#34;massive coral\u0026#34;, \u0026#34;soft coral\u0026#34;} coralSlice = append(coralSlice[:3], coralSlice[6:]...) fmt.Printf(\u0026#34;%q\\n\u0026#34;, coralSlice) 这段代码将从切片中取出索引 3、4 和 5：\nOutput[\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;leptopsammia\u0026#34; \u0026#34;massive coral\u0026#34; \u0026#34;soft coral\u0026#34;] 现在你知道了如何从一个切片中添加和删除元素，让我们来看看如何衡量一个切片所能容纳的数据量。\n使用 cap() 获取切片的容量 # 由于切片的长度是可变的，len() 方法不是确定这种数据类型大小的最佳选择。相反，你可以使用 cap() 函数来了解一个切片的容量。这将告诉你一个切片可以容纳多少个元素，这是由已经为切片分配的内存的多少决定的。\n注意： 由于数组的长度和容量总是相同的，cap()函数对数组不起作用。\ncap() 的一个常见用途是创建一个有预设元素数量的切片，然后再填入元素。这就避免了潜在的不必要的内存分配，因为使用 append() 来添加超出当前分配容量的元素会导致内存重新分配。\n让我们来看看这样的场景：我们想做一个数字列表，0 到 3。我们可以在一个循环中使用 append() 来完成，或者我们可以先预分配切片，然后使用 cap() 来循环填充这些数值。\n首先，我们可以看看使用append()：\nnumbers := []int{} for i := 0; i \u0026lt; 4; i++ { numbers = append(numbers, i) } fmt.Println(numbers) Output [0 1 2 3] 在这个例子中，我们创建了一个切片，然后创建了一个 for 循环，这个循环会迭代四次。每次迭代都将循环变量 i 的当前值追加到 numbers 切片的索引中。然而，这可能会导致不必要的内存分配，使你的程序变慢。当添加到一个空切片时，每次你调用 append 时，程序都会检查切片的容量。如果添加的元素超过了这个容量，程序将分配额外的内存来存储它。这在你的程序中产生了额外的开销，并可能导致执行速度变慢。\n现在让我们在不使用 append() 的情况下，通过预先分配一定的长度/容量来填充切片:\nnumbers := make([]int, 4) for i := 0; i \u0026lt; cap(numbers); i++ { numbers[i] = i } fmt.Println(numbers) Output [0 1 2 3] 在这个例子中，我们使用 make() 来创建一个切片，并让它预先分配 4 个元素。然后我们在循环中使用 cap() 函数来迭代每个归零的元素，填充每个元素直到达到预先分配的容量。在每个循环中，我们将循环变量 i 的当前值放入 numbers 的索引中。\n虽然 append() 和 cap() 在功能上是等同的，但 cap() 的例子避免了使用 append() 函数所需的额外的内存分配。\n构建多维切片 # 你也可以定义由切片作为元素的切片，每个括号内的列表都包含在父切片的大括号内。像这样的切片集合被称为多维切片。这些可以被认为是描述多维坐标的；例如，一个由五个切片组成的集合，每个切片有六个元素，可以代表一个水平长度为 5、垂直高度为 6 的二维网格。\n让我们来看看下面这个多维切片：\nseaNames := [][]string{{\u0026#34;shark\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;}, {\u0026#34;Sammy\u0026#34;, \u0026#34;Jesse\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}} 要访问这个切片中的一个元素，我们必须使用多个索引，结构的每个维度都有一个索引：\nfmt.Println(seaNames[1][0]) fmt.Println(seaNames[0][0]) 在前面的代码中，我们首先打印索引为 1 0 的元素，然后我们打印索引为 0 0 的元素。这将产生以下结果：\nOutputSammy shark 以下是其余各个元素的索引值：\nseaNames[0][0] = \u0026#34;shark\u0026#34; seaNames[0][1] = \u0026#34;octopus\u0026#34; seaNames[0][2] = \u0026#34;squid\u0026#34; seaNames[0][3] = \u0026#34;mantis shrimp\u0026#34; seaNames[1][0] = \u0026#34;Sammy\u0026#34; seaNames[1][1] = \u0026#34;Jesse\u0026#34; seaNames[1][2] = \u0026#34;Drew\u0026#34; seaNames[1][3] = \u0026#34;Jamie\u0026#34; 在处理多维切片时，重要的是要记住，你需要参考一个以上的索引号，以便访问嵌套切片中的特定元素。\n总结 # 在本教程中，你学到了在 Go 中使用数组和切片的基础。通过多个练习来证明数组的长度是固定的，而切片的长度是可变的，并发现这种差异是如何影响这些数据结构的用途场景。\n要继续学习 Go 中的数据结构，请查看我们的文章理解 Go 中的 Map，或探索整个如何在 Go 中编码系列。\n"},{"id":16,"href":"/How-To-Code-in-Go/docs/17-Handling_Errors_in_Go_DigitalOcean/","title":"17 Handling Errors in Go Digital Ocean","section":"Docs","content":" 在 Go 中处理错误 # 健壮的代码需要对用户的不正确输入、网络连接错误和磁盘错误等意外情况做出正确的反应。错误处理是识别程序处于异常状态并且采取措施去记录供后期调试诊断信息的过程。\n相比于其他编程语言, 要求开发者使用专门的语法去处理错误, 在 Go 中将错误作为 error(Go 中的一个接口类型) 类型的值, 并且和其他类型的值一样作为函数返回值的一部分返回。要处理 Go 中的错误, 我们必须检查函数返回值中是否包含了错误信息, 并采取合适的措施去保护数据并告知用户或者操作人员发生错误。\n创建错误 # 在处理错误之前，我们需要先创建一些错误。标准库提供了两个内置函数来创建错误：errors.New 和 fmt.Errorf。这两个函数都允许您指定一条自定义错误消息，这些信息可以向用户展示具体错误信息的一部分。\nerrors.New 只提供了一个字符串类型的参数, 用户在使用的时候可以自定义一个错误发生时具体需要展示的错误消息.\n尝试运行以下示例以查看由 errors.New 创建的错误并打印到标准输出：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 使用 errors.New() 创建一个错误, 具体的错误消息是: barnacles err := errors.New(\u0026#34;barnacles\u0026#34;) // 将错误直接打印到标准错误输出 fmt.Println(\u0026#34;Sammy says:\u0026#34;, err) } # 这里是控制台的输出 # Output Sammy says: barnacles 我们使用标准库的 errors.New 函数创建了具体的消息是 \u0026quot;barnacles\u0026quot; 的错误。这里我们遵循了 Go 程序设计风格指南 使用小写了表示错误消息。\n最后，我们使用 fmt.Println 函数将我们的错误消息与\u0026quot;Sammy says:\u0026quot;相结合并且输出到控制台。\nfmt.Errorf 函数允许用户构建动态的错误消息。它的第一个参数是一个字符串，包含包含占位符值的错误消息，例如字符串的 %s 和整数的%d。fmt.Errorf 将这个格式化字符串后面的参数按顺序插入到这些占位符中:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 使用 fmt.Errorf() 来构建动态错误信息 // 错误内容是 error occurred at: %v // 其中 %v 的具体内容由 time.Now() 的具体返回值决定 err := fmt.Errorf(\u0026#34;error occurred at: %v\u0026#34;, time.Now()) // 将具体的错误信息 结合 `An error happened:` 打印到控制台 fmt.Println(\u0026#34;An error happened:\u0026#34;, err) } # 在控制台中输出错误信息 # Output # 输出内容中的: 2019-07-11 16:52:42.532621 -0400 EDT m=+0.000137103 是由 `time.Now()` 动态生成的 An error happened: error occurred at: 2019-07-11 16:52:42.532621 -0400 EDT m=+0.000137103 我们使用 fmt.Errorf 函数来构建一个错误消息，该消息将包括当前时间。我们提供给 fmt.Errorf 的格式字符串包含 ％v 格式指令，该指令告诉 fmt.Errorf 使用默认格式为格式化字符串后提供的第一个参数。这个参数由标准库的 time.Now 函数提供的当前时间。与较早的示例类似，我们将错误消息与简短前缀结合在一起，并使用 fmt.Println 函数将结果打印到标准输出。\n错误处理 # 一般来说, 你不会看到像上面一样直接创建错误, 然后直接打印。实际上, 在出现问题时, 错误都是由从函数中创建并且返回这种情况更加普遍。调用者使用 if 语句判断返回的错误是否为 nil(error 非初始化的值) 来判断错误是否存在。\n下面这个示例包含了一个总是返回错误的函数, 需要特别留意的时尽管这里的错误是由一个函数返回的, 当你在运行这个程序时, 它产生的输出总是与前面的示例相同。在其他位置声明错误不会改变错误的消息。\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // 定义一个名为: boom 的函数, 返回值总是 errors.New(\u0026#34;barnacles\u0026#34;) func boom() error { return errors.New(\u0026#34;barnacles\u0026#34;) } func main() { // 调用 boom() 函数, 并将返回值赋值给 err 变量 err := boom() // 判断 err 是否等于 nil if err != nil { // 如果 err != nil 条件成立, 输出内容, 然后返回 main.main 函数 fmt.Println(\u0026#34;An error occurred:\u0026#34;, err) return } // 如果 err == nil 成立, // 将会输出下面这一句 fmt.Println(\u0026#34;Anchors away!\u0026#34;) } # Output An error occurred: barnacles 这里我们先定义了一个名为 boom() 的函数并且总是返回单个使用 errors.New 构造 error 的函数。然后, 我们通过 err := boom() 这行调用 boom() 并捕捉错误(赋值给 err 变量即为捕捉错误)。在赋值 error 之后, 我们使用 if err != nil 这个条件判断语句来进行判断错误是否存在。因为 boom() 函数总是返回有效的 error 所以这里的判断条件永远为 true。\n但是情况并非总是如此(值的是 boom() 函数总是返回有效的 error 变量), 所以, 最好有逻辑去处理错误不存在和错误存在这两种情况。当错误存在时, 就像上面的示例中一样, 我们使用 fmt.Println 和前面的前缀打印错误。最后我们使用 return 语句来跳过 fmt.Println(\u0026quot;Anchors away!\u0026quot;) 语句的执行, 因为这个语句只有在 err == nil 时才会执行。\n注意: 在 Go 中主要采用上一个示例中的 if err != nil 来进行错误处理。函数运行到哪里都有可能发生错误, 重要的是使用 if 语句来判断错误是否发生。这样, Go 代码通常就具有第一个缩进级别的 快乐路径 的逻辑, 并且所有的 \u0026ldquo;悲伤的路径\u0026rdquo; 在第二个缩进。\nif 语句有一个可选的赋值子句，可以用来帮助压缩函数调用和错误处理。\n运行下一个程序，查看与前面示例相同的输出，但这一次使用复合 if 语句来减少一些重复的代码:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func boom() error { return errors.New(\u0026#34;barnacles\u0026#34;) } func main() { // 将 err 变量的赋值和判断都压缩在一个语句块中执行 if err := boom(); err != nil { fmt.Println(\u0026#34;An error occurred:\u0026#34;, err) return } fmt.Println(\u0026#34;Anchors away!\u0026#34;) } #Output An error occurred: barnacles 和之前的示例一样, 我们定义一个 boom() 总是返回错误的函数。我们将从 boom() 返回的错误赋值给 err 作为 if 语句的一部分。在 if 语句的第二部分语句中, err 变量变得可用。我们检查错误是否存在, 然后像以前一样使用一个简短的前缀字符串打印我们的错误。\n在本节中，我们学习了如何处理只返回错误的函数。这些函数很常见，但是能够处理可能返回多个值的函数的错误也很重要。\n同时返回错误和多个值 # 返回单个值的函数通常是影响某些状态更改的函数。 比如将行数据插入到数据库中。通常还会编写这样的函数: 如果成功则返回一个值, 如果失败则返回一个潜在的错误。Go 允许函数返回多个结果, 可以用来同时返回一个值和一个错误类型。\n为了创建一个返回多个值的函数, 我们需要在函数签名的括号中列出返回值类型。例如, 一个 capitalize 函数返回值类型是 string 和 error, 那么我们可以这么声明 func capitalize(name string)(string, error){}。其中 (string, error) 这一块的语法是告诉 Go 的编译器, 函数会按照 string 和 error 这一顺序返回值。\n运行下面的程序并且查看函数返回的 string 和 error:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func capitalize(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;no name provided\u0026#34;) } return strings.ToTitle(name), nil } func main() { name, err := capitalize(\u0026#34;sammy\u0026#34;) if err != nil { fmt.Println(\u0026#34;Could not capitalize:\u0026#34;, err) return } fmt.Println(\u0026#34;Capitalized name:\u0026#34;, name) } # Output Capitalized name: SAMMY 我们定义了 capitalize() 函数, 这个函数需要传递一个字符串作为参数(完成将字符串的转为大写)并返回字符串和错误。在 main() 函数中, 我们调用 capitalize(), 然后在 := 运算符的左边将函数的返回值赋值给 name 和 err 这两个变量。之后, 我们执行 if err != nil 检查错误, 如果存在错误, 使用 fmt.Prtintln 将错误信息打印到标准输出。如果没有错误, 输出 Capitalized name: SAMMY。\n如果将 err := capitalize(\u0026quot;sammy\u0026quot;) 中的 \u0026quot;sammy\u0026quot; 更改为为空字符串 (\u0026quot;\u0026quot;)，你将收到 Could not capitalize: no name provided 这个错误。\n当函数的调用者为 name 参数提供一个空字符串时， capitalize 函数将返回错误。当 name 参数不是空字符串时，capledize() 调用 strings.ToTitle 函数将 name 参数转为大写并返回为 nil 的错误值。\n这个例子遵循一些微妙的规约，这些规约是 Go 代码的典型特征，但 GO 编译器并没有强制执行。当函数返回多个值（包括错误）时，规约我们将 error 类型作为最后一项。具有多个返回值的函数返回错误时，通常约定 GO 代码还将每个不是 error 类型的值设置为零值。比如字符串的零值空字符串，整数为 0，一个用于结构类型的空结构，以及用 nil 表示接口和指针类型的零值。我们在有关 变量和常数的教程 中更详细地介绍零值。\n简化重复的代码 # 如果函数有多个返回值时，遵守这些约定可能会变得啰嗦。我们可以使用 匿名函数 来帮助减少重复的代码。匿名函数是分配变量的过程。与我们在较早的示例中定义的函数相反，它们仅在你声明它们的函数中可用 - 这使其非常适合用作可重复使用的 helper 逻辑代码片段。\n以下程序是修改了最后一个示例，返回值增加了一个类型, 包括大写的名称的长度。由于它具有三个值可以返回的值，因此如果没有匿名函数来帮助我们，处理错误可能会变得麻烦:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func capitalize(name string) (string, int, error) { handle := func(err error) (string, int, error) { return \u0026#34;\u0026#34;, 0, err } if name == \u0026#34;\u0026#34; { return handle(errors.New(\u0026#34;no name provided\u0026#34;)) } return strings.ToTitle(name), len(name), nil } func main() { name, size, err := capitalize(\u0026#34;sammy\u0026#34;) if err != nil { fmt.Println(\u0026#34;An error occurred:\u0026#34;, err) } fmt.Printf(\u0026#34;Capitalized name: %s, length: %d\u0026#34;, name, size) } # Output Capitalized name: SAMMY, length: 5 在 main() 中，我们现在可以从 capitalize() 函数中获取转为大写的 name，size 和 err 这三个返回的参数。然后，我们检查是否通过检查错误变量不等于 nil。在尝试使用 capitalize() 返回的任何其他值之前，这一点很重要，因为匿名函数可以将它们设置为零值。由于我们提供了字符串 \u0026quot;Sammy\u0026quot;，因此没有发生错误，因此我们打印出转为大写之后的名称及其长度。\n再次，你可以尝试将 \u0026quot;Sammy\u0026quot; 更改为空字符串 (\u0026quot;\u0026quot;) 以查看已打印的错误情况 (An error occurred: no name provided)。\n在 capitalize 函数中，我们将 handle 变量定义为匿名函数。它需要传递要给错误类型的参数，并以与 capitalize 函数的返回值相同的顺序返回相同的值。handle 将这些值设置为零值，并将其作为最终返回值作为参数传递的错误转发。然后，使用 err 作为 handle 的参数，就可以返回在 capitalize 中遇到的任何错误。\n请记住，capitalize 必须一直返回三个值，因为这就是我们定义函数的方式。有时我们不想处理函数可能返回的所有值。幸运的是，我们在赋值并如何使用这些值方面具有一定的灵活性。\n处理多回报功能的错误 # 当函数返回许多值时，Go 要求我们将每个值分配给变量。在最后一个示例中，我们通过提供从 capitalize 函数返回的两个值的名称来做到这一点。这些名称应通过逗号分隔，并出现在 := 操作符的左侧。从 capitalize 返回的第一个值将分配给 name 变量，第二个值(error)将分配给 err 这个变量。有时，我们只对错误值感兴趣。您可以丢弃使用特殊 _ 变量名称返回功能的任何不需要值。\n在以下程序中，我们修改了涉及大写功能的第一个示例，以通过传递空字符串 (\u0026quot;\u0026quot;) 来产生错误。尝试运行此程序，以查看我们如何通过使用 _ 变量丢弃第一个返回的值来检查错误：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func capitalize(name string) (string, error) { if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;no name provided\u0026#34;) } return strings.ToTitle(name), nil } func main() { _, err := capitalize(\u0026#34;\u0026#34;) if err != nil { fmt.Println(\u0026#34;Could not capitalize:\u0026#34;, err) return } fmt.Println(\u0026#34;Success!\u0026#34;) } # Output Could not capitalize: no name provided 这次在 main() 函数中，我们将 capitalize 的第一个返回值 (首先返回的字符串) 分配给下划线变量(_)。同时，我们分配了通过 capitalize 返回的 err 变量返回的错误。然后，我们通过 if err != nil 条件判断错误是否存在。由于我们已经对一个空字符串进行了硬编码，作为在行中大写的参数，_, err := capitalize(\u0026quot;\u0026quot;)，因此该条件始终将评估为 true。这会产生输出\u0026quot;Could not capitalize: no name provided\u0026quot;，该输出由 fmt.Println 函数在 if 语句的正文中打印出来。此后的返回将跳过 fmt.Println(\u0026quot;Success!\u0026quot;)。\n结论 # 我们已经看到了许多使用标准库创建错误的方法，以及如何构建以惯用方式返回错误的函数。在本教程中，我们设法使用标准库的 errors.New 和 fmt.Errorf 函数成功地创建了各种错误。在将来的教程中，我们将研究如何创建自己的自定义错误类型，以向用户传达更丰富的信息。\n"},{"id":17,"href":"/How-To-Code-in-Go/docs/18-Creating_Custom_Errors_in_Go_DigitalOcean/","title":"18 Creating Custom Errors in Go Digital Ocean","section":"Docs","content":" 在 Go 中创建自定义错误 # 介绍 # GO 标准库提供了errors.Newandfmt.Errorf 这两种方法来在创建错误。但是这两种方法并不能满足你的用户或者后期调试时提供更加复杂的错误信息或者报告发生了什么。为了传递这种更复杂的错误信息并获得更多功能，我们可以实现标准库 error 接口类型。\nerror 接口定义如下：\ntype error interface { Error() string } 内置 软件包将 error 定义为具有单个 Error() 方法的接口，该接口将错误消息字符串作为返回。通过实现此方法，我们可以将定义的任何类型转换为自己的错误。\n让我们尝试运行以下示例以查看 error 接口的实现：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) // 定义一个 MyError 的接口体 type MyError struct{} // 实现 error 接口的 Error 方法 func (m *MyError) Error() string { return \u0026#34;boom\u0026#34; } // 定义 sayHello 函数 // 函数返回类型为 string 和 error func sayHello() (string, error) { // 由于 *MyError 实现了 error 接口 // 所以 \u0026amp;MyError{} 可以作为 error 对象返回 return \u0026#34;\u0026#34;, \u0026amp;MyError{} } func main() { s, err := sayHello() if err != nil { fmt.Println(\u0026#34;unexpected error: err:\u0026#34;, err) os.Exit(1) } fmt.Println(\u0026#34;The string:\u0026#34;, s) } 我们将看到以下输出：\n# Output unexpected error: err: boom exit status 1 在这里，我们创建了一个新的空结构类型 MyError，并在其上定义了 Error() 方法。Error() 方法返回字符串 \u0026quot;Boom\u0026quot;。\n在 main() 中，我们调用 sayhello 函数，该函数返回一个空字符串和一个新 MyError 实例。由于 sayhello 将始终返回错误，因此在main() 中的 if 语句主体内的 fmt.Println 调用将始终执行。我们使用 fmt.Println 来打印短前缀字符串 \u0026quot;unexpected error:\u0026quot;以及在保存MyError 实例中的在 err 变量。\n值得注意的是，我们不必直接调用 Error()，因为 fmt 包能够自动检测到已经实现了 error 接口。它 透明 地调用 Error() 来获取字符串 \u0026quot;hoom\u0026quot;，并将其与前缀字符串 \u0026quot;unexpected error: err:\u0026quot; 相连。\n自定义错误收集详细信息 # 有时，自定义错误是捕获详细错误信息的最有效的方式。例如，假设我们要捕获 HTTP 请求产生的错误的状态代码；运行以下程序以查看 error 的实现，使我们能够清晰捕获该信息：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) type RequestError struct { StatusCode int Err error } func (r *RequestError) Error() string { return fmt.Sprintf(\u0026#34;status %d: err %v\u0026#34;, r.StatusCode, r.Err) } func doRequest() error { return \u0026amp;RequestError{ StatusCode: 503, Err: errors.New(\u0026#34;unavailable\u0026#34;), } } func main() { err := doRequest() if err != nil { fmt.Println(err) os.Exit(1) } fmt.Println(\u0026#34;success!\u0026#34;) } 我们将看到以下输出：\n# Output status 503: err unavailable exit status 1 在此示例中，我们创建了创建一个错误的 RequestError 的新实例, 其中包含一个状态码和使用标准库提供的 errors.New 函数创建的 err。之后，如前所述，我们使用 fmt.Println 打印了错误信息。\n在 RequestError 的 Error() 方法中，我们使用创建 error 对象时提供的信息和 fmt.Sprintf 函数构造字符串。\n类型断言和自定义错误 # error 接口仅公开一种方法，但是为了正确处理错误, 我们可能需要访问 error 实现类型的其他方法。例如，我们可能有几个暂时的自定义错误实现，可以通过 Temporary() 方法的存在来重述。\n接口为类型提供的更广泛的方法集提中供了一个狭窄的视图，因此，我们必须使用类型断言来更改视图正在显示的方法，或完全删除它。\n下面的示例增加了前面显示的 RequestError 具有 Temporary() 方法，该方法将指示调用者是否应重试请求：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) type RequestError struct { StatusCode int Err error } func (r *RequestError) Error() string { return r.Err.Error() } func (r *RequestError) Temporary() bool { // 如果状态码是 503 返回 true return r.StatusCode == http.StatusServiceUnavailable // 503 } func doRequest() error { return \u0026amp;RequestError{ StatusCode: 503, Err: errors.New(\u0026#34;unavailable\u0026#34;), } } func main() { err := doRequest() if err != nil { fmt.Println(err) // 进行类型断言 re, ok := err.(*RequestError) // 如果类型断言成功 if ok { if re.Temporary() { fmt.Println(\u0026#34;This request can be tried again\u0026#34;) } else { fmt.Println(\u0026#34;This request cannot be tried again\u0026#34;) } } os.Exit(1) } fmt.Println(\u0026#34;success!\u0026#34;) } 我们将看到以下输出：\n# Output unavailable This request can be tried again exit status 1 在 main() 中，我们调用 doRequest() 将错误接口返回给我们。我们首先打印由 Error() 方法返回的错误消息。接下来，我们尝试通过使用类型的断言 re, ok := err.(*RequestError)。如果类型断言成功，我们然后使用 Temporary() 方法来查看此错误是否是临时错误。由于doRequest() 设置的状态代码为 503，它匹配 HTTP.Statusserviceunavailable，因此将返回 true，并且要打印\u0026quot;This request can be tried again\u0026quot; 的原因。实际上，我们将提出另一个请求，而不是打印消息。\n包装错误 # 通常，错误是从程序的外部产生(例如：数据库，网络连接等)。这些错误提供的错误消息不能够帮助任何人找到错误的根源。有必要在错误消息开始时，将错误与额外信息包装，将为成功调试提供一些必要的上下文。\n下面的示例说明了我们如何将一些上下文信息附加到从其他功能中返回的其他隐性错误：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // 定义一个错误的包装类型 type WrappedError struct { // 上下文信息 Context string // 具体错误内容 Err error } func (w *WrappedError) Error() string { return fmt.Sprintf(\u0026#34;%s: %v\u0026#34;, w.Context, w.Err) } func Wrap(err error, info string) *WrappedError { return \u0026amp;WrappedError{ Context: info, Err: err, } } func main() { err := errors.New(\u0026#34;boom!\u0026#34;) err = Wrap(err, \u0026#34;main\u0026#34;) fmt.Println(err) } 我们将看到以下输出\n# Output main: boom! WrappedError 是一个具有两个字段的结构：字符串类型的 context 字段和 error, 这让 WrappedError 提供了更多信息。当调用 Error() 方法时，我们再次使用 fmt.Sprintf 打印上下文消息和 error(fmt.Sprintf 也会隐式调用 err 的 Error() 方法)。\n在 main() 中，我们使用 errors.New 创建一个错误，然后我们使用定义的 Wrap 函数包装该错误。这使我们可以指出此错误是在 \u0026quot;main\u0026quot; 中生成的。另外，由于我们的 WrappedError 也是一个 error，因此我们也可以包装其它的WrappedError - 这将使我们看到链条来帮助我们追踪错误源。在标准库的一点帮助下，我们甚至可以在错误中嵌入完整的堆栈跟踪。\n总结 # 由于 error 接口只提供一种方法，我们已经看到，在为不同情况提供不同类型的错误方面，我们有很大的灵活性。这可以包含所有内容，从传达多个信息作为错误的一部分到实现 指数退回。尽管表面上的错误处理机制似乎很简单，但我们可以使用这些自定义错误来处理常见和不常见情况。\nGO 有另一种传达意外行为的机制，panic。在错误处理系列的下一篇文章中，我们将检查恐慌 - 它们是什么以及如何处理它们。\n"},{"id":18,"href":"/How-To-Code-in-Go/docs/19-Handling_Panics_in_Go-_DigitalOcean/","title":"19 Handling Panics in Go Digital Ocean","section":"Docs","content":" 在 Go 中处理恐慌 # 介绍 # 程序遇到的错误分为两个广泛的类别：程序员已经预料到的错误和程序员没有预料到的错误。我们在前两篇关于 错误处理 的文章中介绍过的 error 接口主要用于处理我们在编写 Go 程序时可能遇到的错误。error 接口甚至允许我们去确认在调用一个函数时发生罕见性错误的可能性，因此我们可以在这些情况下进行适当的响应。\nPanics 属于第二类错误，这些错误是程序员意料之外的。这些意料之外的错误导致一个 GO 程序自发终止并退出运行。常见的错误通常是造成 panic 的原因。在本教程中，我们将研究哪些常见操作可以引起 panic ，我们还将看到避免这些 panic 的方法。我们还将使用 defer 语句与 recover 函数一起捕获 panic，以免 panic 有机会意外终止我们正在运行的 GO 程序。\n了解 panics # GO 中的某些操作会自动返回 panic 并停止程序的运行。常见的操作包括索引超出 数组 的容量，执行类型的断言，空指针上的调用方法，错误地使用互斥锁以及尝试使用已经关闭的 chanel 等等。这些情况中的大多数是由于编程时犯错而导致的，再加上编译器在编译程序时没有检测到这些错误。\n由于 panic 包含了有助于解决问题的细节，所以开发者通常会使用 panic 来标记在开发过程中犯了一个错误。\n由于越界引发的 panic # 当你尝试访问超出切片长度或数组容量之外的索引时，GO 运行时会产生 panic。\n下面的示例是尝试使用内置的 len 函数返回的切片的长度, 然后访问切片的最后一个元素时常见错误。尝试运行此代码以了解为什么这可能会引起 panic：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { names := []string{ \u0026#34;lobster\u0026#34;, \u0026#34;sea urchin\u0026#34;, \u0026#34;sea cucumber\u0026#34;, } fmt.Println(\u0026#34;My favorite sea creature is:\u0026#34;, names[len(names)]) } 这将会有有以下输出：\n# Output panic: runtime error: index out of range [3] with length 3 goroutine 1 [running]: main.main() # 备注这一块信息可能会有不一样的输出 /tmp/sandbox879828148/prog.go:13 +0x20 panic 输出的名称提供了一个提示：panic: runtime error: index out of range。我们用三个海洋生物创建了一个切片。然后，我们尝试通过使用内置的 len 函数将切片的长度作为索引来获取切片的最后一个元素。请记住，切片和数组的第一个元素的下标都是 0; 因此，第一个元素的索引是 0，此切片中的最后一个元素在索引2。由于我们尝试在第三个索引，3 时，因此切片中没有元素要返回并且超出了切片的边界。运行时别无选择，只能终止和退出，因为我们要求它做一些不可能的事情。Go 在编译过程中也无法证明此代码将尝试执行此操作，因此编译器无法捕获到这种操作。\n还请注意，后续代码还没被执行。这是因为 panic 是一个完全阻止执行你的 GO 程序的事件。其中产生的消息中包含多个有助于诊断 panic 的原因。\n剖析 panic # panics 由指示 panic 的原因和一个 堆栈跟踪 信息组成，这些可帮助你在代码中找到 panic 的位置。\n任何 panic 的第一部分都是消息。它始终将以字符串 panic: 开始, 紧接着是引发 panic 的具体原因的字符串。在上一个练习中有一个 panic 的消息：\npanic: runtime error: index out of range [3] with length 3 紧接着 panic: 的是 runtime error: 这告诉我们这个 panic 是由语言的运行时引起的。这个 panic 告诉我们, 我们尝试使用下标 [3]已经超出了切片的长度 3 了。\n消息后面的是堆栈跟踪。堆栈跟踪形成一个映射，我们可以根据映射信息，以准确地定位生成 panic 时正在执行的代码所在的行，和代码的调用链关系。\ngoroutine 1 [running]: main.main() /tmp/sandbox879828148/prog.go:13 +0x20 上一个示例的堆栈跟踪表示，我们的程序从 /tmp/sandbox879828148/prog.go 文件的第 13 行中生成了 panic。这些信息还告诉我们 panic 在 main 包中的 main() 函数产生。\n堆栈跟踪分为单独的块 - 对于你程序中的每个 goroutine一个块。每个 GO 程序的执行都是通过一个或多个 goroutines 来完成的，它们可以独立并同时执行 GO 代码的一部分。每个块从标头 goroutine x [state]: (其中 x: 表示 goroutine 的 id, [state] 表示 goroutine 当前的状态)开头。标头给出了 goroutine 的 ID 号，以及发生 panic 时所处的状态。标头后，堆栈跟踪显示了发生 panic 时程序执行的函数，以及执行函数所在的文件名和行号。\n上一个示例中的 panic 是通过对切片的越界访问而产生的。当使用空指针去调用方法时，也可以生成 panic。\nNil Receivers # nil 指针调用方法 # GO 编程语言在运行时具有指向计算机内存中存在的某种类型的特定实例的指针。指针可以是 nil 值, 这表明他们没有指向任何东西。当我们尝试在零指针上调用方法时，GO 运行时会产生 panic。同样，当调用方法时，是接口类型的变量也会产生 panic。要查看这些情况下产生的 panic，请尝试以下示例：\npackage main import ( \u0026#34;fmt\u0026#34; ) type Shark struct { Name string } func (s *Shark) SayHello() { fmt.Println(\u0026#34;Hi! My name is\u0026#34;, s.Name) } func main() { s := \u0026amp;Shark{\u0026#34;Sammy\u0026#34;} s = nil s.SayHello() } The panics produced will look like this:\n由此产生的 panic 将是这样的:\n# Output panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xdfeba] goroutine 1 [running]: main.(*Shark).SayHello(...) /tmp/sandbox160713813/prog.go:12 main.main() /tmp/sandbox160713813/prog.go:18 +0x1a 在此示例中，我们定义了一个称为 Shark 的结构体。Shark 在其指针接收器上定义了一个叫做 Sayhello 的方法，这个方法将在被调用时在标准输出中打印出问候信息。在我们的 main 函数主体中，我们创建了 Shark 结构体的新实例，并使用 \u0026amp; 操作符取变量的指针并将指针分配给 S 变量。然后，我们使用语句 s = nil 将 s 变量重新赋值为 nil。最后，我们尝试在变量 s 上调用 SayHello 方法。我们没有收到 Sammy 的友好消息，而是收到 panic，因为我们试图访问无效的内存地址。因为 s 变量为 nil，所以当调用 SayHello 函数时，它试图访问 *Shark 类型上的 Name 字段。因为这是一个指针接收者，并且在这种情况下的接收者是 nil 的，所以无法解引用零值指针而引起的 panic。\n虽然我们在本例中显式地将 s 设置为nil，但实际上，这种情况却不明显。当你看到有关解引用 nil 指针而引发的 panic 时，请确保你已正确分配了你可能创建的任何指针变量。\n备注, 通过使用指针作为接收者时, 使用零值取调用时没有不会发生 panic 的, 真正发生 panic 的时, 解引用 nil 指针。\n// 这种定义时, 使用零值的 `* Shark` 对象去调用 SayHello 方法是没有问题的 func (s *Shark) SayHello() { if s == nil { return } fmt.Println(\u0026#34;Hi! My name is\u0026#34;, s.Name) } 解引用 nil 指针和越界访问产生的 panic 是两种在运行时产生的 panic 常见的场景。也可以使用内置函数手动产生 panic。\n使用内置的 panic 函数 # 我们还可以使用内置的 panic 函数来产生自己的 panic。它使用单个字符串作为参数，这是 panic 产生的信息。一般这条消息比重写 error 代码中的消息简单得多。此外，我们可以在我们自己的软件包中使用它向开发者指出，他们在使用包装代码时可能犯了一个错误。但是，最佳实践就是尝试在我们提供的软件包中将 error 值返回给开发者。\n运行此代码以查看从 main 函数调用 foo 函数产生的 panic：\npackage main func main() { foo() } func foo() { panic(\u0026#34;oh no!\u0026#34;) } 产生的 panic 输出看起来像：\n# Output panic: oh no! goroutine 1 [running]: main.foo(...) /tmp/sandbox494710869/prog.go:8 main.main() /tmp/sandbox494710869/prog.go:4 +0x40 在这里，我们定义了一个 foo 函数，里面会使用 \u0026quot;oh no!\u0026quot; 这个字符串调用 panic 这个内置函数。foo 函数由我们的 main 函数调用。请注意输出如何输出 panic: oh no! 和堆栈跟踪, 在堆栈跟踪中展示一个 goroutine 和两行堆栈跟踪: 一行是 main() 函数，另一行是 foo() 函数。\n我们已经看到，panic 产生时似乎终止了我们的程序的运行。当需要正确关闭的开放资源时, 这可能会产生一些问题。GO 提供了一种机制，即使在 panic 的情况下，也可以始终执行一些代码。\nderfer 函数 # 你的程序即使在运行时处理 panic 也必须能够正确清理的资源。GO 允许使用 defer 来调用延迟执行函数，直到调用它的函数完成时才会执行。延迟函数即使在出现 panic 的情况下也会运行，并被用作一种安全机制，用来防范 panic 的混乱本质。通过调用普通一样调用函数, 使用关键字 defer 作为调用整个函数调用语句的前缀，比如像调用 defer sayHello() 一样。运行此示例以查看即使产生 panic 时也可以打印消息：\npackage main import \u0026#34;fmt\u0026#34; func main() { defer func() { fmt.Println(\u0026#34;hello from the deferred function!\u0026#34;) }() panic(\u0026#34;oh no!\u0026#34;) } 此示例产生的输出看起来像：\n# Output hello from the deferred function! panic: oh no! goroutine 1 [running]: main.main() /Users/gopherguides/learn/src/github.com/gopherguides/learn//handle-panics/src/main.go:10 +0x55 在此示例的 main() 函数中，我们首先使用 defer 调用到打印消息 \u0026quot;hello from the deferred function!\u0026quot; 的匿名函数。然后，main 函数立即使用 panic 函数产生 panic。在此程序的输出中，我们首先看到执行递延函数并打印其消息。在此之后是，我们在 main 中产生 panic 消息。\n延迟函数提供了防范 panic 的保护。在递延函数中，GO 提供另一个内置函数来阻止 panic 终止 GO 程序的机会。\n处理 panic # go 内置的 recover 函数提供了一个恢复 panic 的机制。这个函数通过拦截函数的调用栈并且阻止程序的意外退出。它具有严格的使用规则，但是在编写应用代码时非常有用。\n因为 recover 是内置包的一部分, 所以我们可以在不导包的情况下使用这个函数:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func main() { divideByZero() fmt.Println(\u0026#34;we survived dividing by zero!\u0026#34;) } func divideByZero() { defer func() { if err := recover(); err != nil { log.Println(\u0026#34;panic occurred:\u0026#34;, err) } }() fmt.Println(divide(1, 0)) } func divide(a, b int) int { return a / b } 此示例将输出：\n# Output 2009/11/10 23:00:00 panic occurred: runtime error: integer divide by zero we survived dividing by zero! 在此示例中，我们在 main 函数调用了我们定义的 DivideByZero 函数。在 DivideByZero 中，我们使用 defer 关键字调用匿名函数。这个匿名函数负责处理在 divideByZero 中出现的任何 panic。在匿名函数中, 我们调用内置的 recover 函数并且将错误信息赋值给 err, 如果 DivideByZero感处于 panic 状态，那么 err 将会被设置值，否则为 nil。通过将 err 与 nil 进行比较，我们可以检测到是否发生了 panic，在这种情况下，我们处理 panic 就像处理其他错误一样, 使用 log.Println 函数记录了 panic。\n在延迟执行匿名函数之后, 我们调用了另外一个我们定义的另一个函数, 并且尝试使用 fmt.Println 打印这个函数的返回值。所提供的参数将导致除法执行除数为零的操作，这将引起 panic。\n在此示例的输出中，我们首先从匿名函数中恢复 panic 的日志消息，接下来是 we survived dividing by zero! 的消息。我们真的做到了这一点，这要归功于内置的 recover 函数, 它成功阻止有可能终止 GO 程序运行的灾难性 panic。\n从 recover() 函数中返回的 err 值正是调用 panic 的值。因此，在没有发生 panic 时，确保 err 值仅为 nil 至关重要。\n使用 recover 检测 panic # recover 函数依赖于错误的值来确定是否发生了 panic。因为 panic 函数的参数是空接口，所以它可以是任何类型。任何接口类型 (包括空接口) 的零值为 nil。必须注意避免使用 nil作为 panic 的参数，如本示例所证明的：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func main() { divideByZero() fmt.Println(\u0026#34;we survived dividing by zero!\u0026#34;) } func divideByZero() { defer func() { if err := recover(); err != nil { log.Println(\u0026#34;panic occurred:\u0026#34;, err) } }() fmt.Println(divide(1, 0)) } func divide(a, b int) int { if b == 0 { panic(nil) } return a / b } 这将输出：\n# Output we survived dividing by zero! 此示例与以前的示例相同，该示例涉及 recover 并进行一些小的修改。已更改了 divide 函数判断 b 是否为 0。如果是, 它将使用带有 nil 作为参数调用 panic 函数来产生 panic。这次的输出不包括 defer 调用匿名函数的日志消息，即使通过 Divide 创建了 panic，也会出现 panic。这种沉默行为是为什么确保调用 panic 的参数不是 nil 很重要的原因。\nConclusion # 总结 # 我们已经看到了多种可以在 GO 中造成 panic 的方法，以及如何使用恢复的内置的 recover 来恢复它们。虽然您不一定会自己使用 panic，但适当的 panic 的恢复机制是使 Go 代码达到生产级别应用程序的重要步骤。\n"},{"id":19,"href":"/How-To-Code-in-Go/docs/20-Importing_Packages_in_Go_DigitalOcean/","title":"20 Importing Packages in Go Digital Ocean","section":"Docs","content":" 在 Go 中导入包 # 介绍 # 有时，你的代码需要当前程序的基础上增加更多的功能。在这些情况下，你可以使用软件包来丰富你的程序。在 Go 中, 一个包表示磁盘上单个目录中的所有文件。包可以定义可以在其他 Go 文件或包中引用的函数、类型和接口。\n本教程将带你来完成软件包的安装, 导入和重命名。\n标准库包 # 标准库是 Go 附带的一组软件包。这些软件包包含许多用于编写现代软件的基本模块。例如， fmt 软件包包含用于格式和打印字符串的基本功能。 net/http 软件包包含允许开发人员创建 Web 服务，通过HTTP 协议发送和检索数据的功能，等等。\n为了利用软件包中的功能，你需要使用 import 语句访问软件包。import 语句由 import 关键字以及软件包的名称组成。\n例如，在 GO 程序中 random.go 文件。你可以导入 math/rand 包来生成随机数：\nimport \u0026#34;math/rand\u0026#34; 当我们导入一个包时，我们把它在当前程序中作为一个单独 namespace 命名空间来使用。这意味着我们必须像 package.function 调用其中的函数。\n实际上，math/rand 软件包的功能看起来像这些示例：\nrand.Int() 调用函数返回随机整数。 rand.Intn() 调用函数将随机元素从 0 返回到所提供的指定数字。 让我们创建一个 for 循环，以显示我们如何在随机过程中调用 math/rand 软件包的函数。\nrandom.go\npackage main import \u0026#34;math/rand\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { println(rand.Intn(25)) } } 该程序首先在第三行中导入 math/rand 软件包，然后移至将运行10次的循环中。在循环中，程序将打印一个在 0 到 25 范围内的随机整数。其中, 整数 25 是作为其参数传递给 rand.Intn()。\n当我们使用 go run random.go 来运行程序时，我们将收到 10 个随机整数作为输出。因为这些是随机的，所以每次运行程序时，你都可能会获得不同的整数。输出看起来像这样：\n# Output 6 12 22 9 6 18 0 15 6 0 整数永远不会低于 0 或 24 以上。\n当需要导入多个包时，你可以使用 () 来创建一个块。通过使用块，可以避免在每行上重复 import 关键字。这将使你的代码看起来更整洁\nrandom.go\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) 为了利用新增的软件包，我们现在可以格式化输出并打印出循环中每次迭代生成的随机数：\nrandom.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { for i := 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;%d) %d\\n\u0026#34;, i, rand.Intn(25)) } } 现在，当我们运行程序时，我们将收到看起来像这样的输出：\n# Output 0) 6 1) 12 2) 22 3) 9 4) 6 5) 18 6) 0 7) 15 8) 6 9) 0 在本节中，我们学会了如何导入软件包并使用它们来编写更复杂的程序。到目前为止，我们只使用了标准库中的软件包。接下来，让我们看看如何安装和使用其他开发人员编写的软件包。\n安装软件包 # 虽然标准库包含了许多出色且有用的软件包，但它们的设计是通用的，本质上不是特定的。这使开发者可以根据自己的特定需求在标准库之上构建自己的软件包。\nGO 工具链带有 go get 命令。此命令使你可以将第三方软件包安装到本地开发环境中，并且将这些软件包应用到你的程序中。\n使用 go get 来安装第三方软件包时，通常可以通过其规范路径引用软件包。这个路径也可能是通往公共项目的途径，该项目托管在诸如 GitHub 之类的代码存储库中。因此，如果要导入 flect 软件包，则将使用完整的规范路径：\ngo get github.com/gobuffalo/flect 在这种情况下，使用 go get 工具将在 GitHub 上找到软件包，并将其安装到你的 $Gopath 中。\n对于此示例，代码将安装在此目录中：\n$GOPATH/src/github.com/gobuffalo/flect 原始作者通常会更新软件包，以解决 bug 或添加新功能。发生这种情况时，你可能需要使用该软件包的最新版本来利用新功能或已解决的 bug。要更新软件包，你可以使用 go get 命令使用 -u 标志：\ngo get -u github.com/gobuffalo/flect 如果在本地找不到该软件包，此命令也将安装该软件包。如果已经安装了它，Go 将尝试将软件包更新为最新版本。\ngo get 命令始终检索可用的包装的最新版本。但是，可能还会对该软件包的之前的版本进行更新，这些版本仍然比你使用的更新，并且对你的程序中的更新非常有用。要检索包装的特定版本，你需要使用一个软件包管理工具，例如Go Modules。\n从 GO 1.11 开始，使用 Go Modules 来管理要导入的软件包的哪个版本。软件包管理的主题超出了本文的范围，但是你可以在on the Go Modules GitHub page上阅读有关它的更多信息。\n使用别名的方式导入软件包 # 如果你的本地软件包已经命名为与你正在使用的第三方软件包相同的包名时，则可能需要更改软件包名称。当发生这种情况时，使别名导入的方式是处理软件包名冲突的最佳方法。你可以通过将 alias 名称放在导入的软件包的前面来修改包装及其功能的名称及其功能。\n该声明的结构看起来像这样：\nimport another_name \u0026#34;package\u0026#34; 在此示例中，在 random.go 程序文件中修改 fmt 软件包的名称。我们将 fmt 的包名称更改为 f，以缩写它。我们的修改程序看起来像这样：\nrandom.go\npackage main import ( f \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { for i := 0; i \u0026lt; 10; i++ { f.Printf(\u0026#34;%d) %d\\n\u0026#34;, i, rand.Intn(25)) } } 在程序中，我们现在将 Printf 函数称为 f.Printf，而不是 fmt.Printf。\n虽然其他语言喜欢以别名的方式命名包以便于在程序中更加容易使用，但 GO 却不是。例如，与 fmt 软件包与 f 相反， style guide 更加倾向于一致。\n在重命名导入包以避免命名冲突时，你应该重命名本地导入的软件包或特定的项目中导入的包。例如，如果你有一个名为 Strings 的本地软件包，并且还需要导入称为 strings 的系统软件包，你应该重命名本地软件包而不是系统软件包。只要有可能，最好避免完全命名冲突。\n在本节中，我们了解了如何以别名的方式导入软件包以避免与我们计划中的其他导入冲突。重要的是要记住，程序的可读性和清晰度很重要，因此你只能使用别名使代码更可读或何时需要避免命名冲突。\n格式化导入 # 通过格式化导入，你可以将软件包分为特定的顺序，以使你的代码更加一致。此外，当惟一改变的是导入的排序顺序时，这将防止发生随机提交。由于格式化导入将防止随机提交，因此这将防止不必要的代码混乱和混淆代码审查。\n大多数编辑器将自动为你格式化导入，或者让你配置编辑器以使用 goimports 工具。在编辑器中使用 goimports 被认为是标准实践，因为尝试手动维护导入的排序顺序可能是乏味的，而且容易出错。此外，如果进行了任何样式更改，则将更新 goimports 以反映这些样式更改。这样可以确保你和任何在代码上工作的人都将在你的 import 块中具有一致的样式。\n这是格式化之前的示例导入块可能的样子：\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/digital/ocean/godo\u0026#34; \u0026#34;github.com/sammy/foo\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;github.com/sammy/bar\u0026#34; ) 运行 goimport 工具(或使用已安装它的大多数编辑器，保存文件将为你运行)，现在你将具有以下格式：\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/sammy/foo\u0026#34; \u0026#34;github.com/sammy/bar\u0026#34; \u0026#34;github.com/digital/ocean/godo\u0026#34; ) 请注意，它首先将所有标准库软件包分组，然后将第三方软件包与空白行分组。这使得更容易阅读和了解正在使用哪些软件包。\n在本节中，我们了解到，使用 goimports 将保持我们所有导入块的正确格式，并防止在处理相同文件在开发人员之间产生不必要的代码混乱。\n总结 # 当我们导入软件包时，我们可以调用未内置的功能。有些软件包是随着 GO 安装的标准库的一部分，有些软件包将通过 go get 来安装。\n使用软件包可以使我们在利用现有代码时使程序更加健壮和强大。我们还可以为自己和其他程序员 创建自己的软件包，以便将来使用。\n"},{"id":20,"href":"/How-To-Code-in-Go/docs/21-How_To_Write_Packages_in_Go/","title":"21 How to Write Packages in Go","section":"Docs","content":" 如何在 Go 中编写包 # 一个包由同一目录下的 Go 文件组成的，并且在文件开头有相同的包声明。你可以从包中加入额外的功能，使你的程序更加复杂。有些包可以通过 Go 标准库获得，因此在安装 Go 时就已经安装了。其他的可以用 Go 的go get命令来安装。你也可以通过在同一目录下创建 Go 文件来建立你自己的 Go 包，你可以通过使用必要的包声明来分享代码。\n本教程将指导你如何编写 Go 包，以便在其他编程文件中使用。\n前提条件 # 按照如何安装和设置 Go 的本地编程环境系列教程中的一个教程设置 Go 编程环境。按照本地编程环境教程中的步骤5创建你的 Go 工作区。要遵循本文的例子和命名规则，请阅读第一节「编写和导入软件包」。 为了加深你对 GOPATH 的了解，请阅读文章了解 GOPATH。 编写和导入软件包 # 编写包就像编写任何其他 Go 文件一样，包可以包含函数、类型和变量的定义，然后可以在其他 Go 程序中使用。\n在我们创建一个新的包之前，我们需要进入我们的 Go 工作区。这通常是在我们的gopath下。对于这个例子，本教程中我们将把包称为greet。为了做到这一点，在我们的项目空间下的gopath中创建了一个名为greet的目录。当使用 Github 作为代码库，组织名称为gopherguides，想在此组织下创建greet包，那么我们的目录会是这样的：\n└── $GOPATH └── src └── github.com └── gopherguides greet目录在gopherguides目录中：\n└── $GOPATH └── src └── github.com └── gopherguides └── greet 最后，我们可以添加我们目录中的第一个文件。通常的做法是，包中的 主要或 入口 文件是以目录名来命名的。在这种情况下，将在greet目录下创建一个名为greet.go的文件：\n└── $GOPATH └── src └── github.com └── gopherguides └── greet └── greet.go 创建了文件后，我们就可以开始编写我们想要重复使用或在不同项目中共享的代码。在本例中，我们将创建一个打印出 Hello World的 Hello 的函数。\n在文本编辑器中打开 greet.go 文件，增加如下代码：\npackage greet import \u0026#34;fmt\u0026#34; func Hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 让我们把这个文件分解一下，每个文件中第一行需要是所处的包名称。因为你在greet包里，所以通过使用package关键字，后面加包的名称：\npackage greet 这将告诉编译器把文件中的所有内容作为greet包的一部分。\n接下来，你用 import 语句声明你需要使用的任何其他包。在这个文件中你只使用一个包，fmt包：\nimport \u0026#34;fmt\u0026#34; 最后，你创建函数Hello，它将使用fmt包来打印出Hello, World!。\nfunc Hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 现在已经编写了greet包，可以在你创建的任何其他包中使用它。让我们创建一个新的包，在其中使用greet包。\n接下来创建一个名为example的包，这意味着需要一个名为example的目录。在gopherguides中创建这个包，所以目录结构看起来像这样：\n└── $GOPATH └── src └── github.com └── gopherguides └── example 现在你有了新包的目录，可以创建入口文件。因为这将是一个可执行的程序，最好的做法是将入口文件命名为main.go：\n└── $GOPATH └── src └── github.com └── gopherguides └── example └── main.go 在文本编辑器中，打开main.go，添加以下代码来调用greet包：\npackage main import \u0026#34;github.com/gopherguides/greet\u0026#34; func main() { greet.Hello() } 因为正在导入一个包，通过用点符号来调用指定包的函数。点符号是指在使用的包的名称和想使用的包中资源之间加一个句号.。例如，在greet包中，有Hello函数作为一个资源。如果想调用该资源，可以使用 greet.Hello() 的形式。\n现在，可以打开终端，在命令行上运行该程序：\ngo run main.go 完成后，你将收到以下输出：\nHello, World! 为了解如何在包中使用变量，让我们在greet.go文件中添加一个变量定义：\npackage greet import \u0026#34;fmt\u0026#34; var Shark = \u0026#34;Sammy\u0026#34; func Hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 接下来，打开main.go文件，添加以下高亮行，在fmt.Println()函数中调用greet.go中的变量:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gopherguides/greet\u0026#34; ) func main() { greet.Hello() fmt.Println(greet.Shark) } 再次运行此程序：\ngo run main.go 你会收到以下输出：\nHello, World! Sammy 最后，让我们也在greet.go文件中定义一个类型。创建一个带有 name 和 color字段的 Octopus 类型，以及一个在调用时将打印出字段的函数：\npackage greet import \u0026#34;fmt\u0026#34; var Shark = \u0026#34;Sammy\u0026#34; type Octopus struct { Name string Color string } func (o Octopus) String() string { return fmt.Sprintf(\u0026#34;The octopus\u0026#39;s name is %q and is the color %s.\u0026#34;, o.Name, o.Color) } func Hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 打开main.go，在文件的末尾创建一个该类型的实例:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gopherguides/greet\u0026#34; ) func main() { greet.Hello() fmt.Println(greet.Shark) oct := greet.Octopus{ Name: \u0026#34;Jesse\u0026#34;, Color: \u0026#34;orange\u0026#34;, } fmt.Println(oct.String()) } 一旦你用oct := greet.Octopus创建了一个Octopus类型的实例，就可以在main.go文件的命名空间中访问该类型的函数和字段。这使得在最后一行直接写oct.String()，而不用调用greet。同样的，也可以在不引用greet包的名字的情况下调用oct.Color等类型字段。\nOctopus类型上的String方法使用fmt.Sprintf函数来输出一段文本，并将结果即一个字符串，返回给调用者（在这里是指主程序）。\n当你运行该程序时，你会收到以下输出：\ngo run main.go Hello, World! Sammy The octopus\u0026#39;s name is \u0026#34;Jesse\u0026#34; and is the color orange. 通过在Octopus上创建String方法，你现在有一个可重复使用的方法来打印出自定义类型的信息。如果想在将来改变这个方法的行为，只需要编辑这一个方法。\n可导出代码 # 你可能已经注意到，调用的greet.go文件中所有的声明都是大写的。Go 没有像其他语言那样有public、private或protected修饰符的概念。外部可见性是由大写字母控制的。以大写字母开头的类型、变量、函数等等，在当前包之外是可以公开使用的。一个在其包外可见的符号被认为是 可导出 的。\n如果你给Octopus添加了一个名为reset的新方法，可以在greet包内调用它，但是不能在main.go文件中调用，因为调用者在greet包之外：\npackage greet import \u0026#34;fmt\u0026#34; var Shark = \u0026#34;Sammy\u0026#34; type Octopus struct { Name string Color string } func (o Octopus) String() string { return fmt.Sprintf(\u0026#34;The octopus\u0026#39;s name is %q and is the color %s.\u0026#34;, o.Name, o.Color) } func (o *Octopus) reset() { o.Name = \u0026#34;\u0026#34; o.Color = \u0026#34;\u0026#34; } func Hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 如果你试图从main.go文件中调用reset：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gopherguides/greet\u0026#34; ) func main() { greet.Hello() fmt.Println(greet.Shark) oct := greet.Octopus{ Name: \u0026#34;Jesse\u0026#34;, Color: \u0026#34;orange\u0026#34;, } fmt.Println(oct.String()) oct.reset() } 你会收到以下编译错误：\noct.reset undefined (cannot refer to unexported field or method greet.Octopus.reset) 要从 Octopus 中导出 reset 功能，请将reset 中的R 大写：\npackage greet import \u0026#34;fmt\u0026#34; var Shark = \u0026#34;Sammy\u0026#34; type Octopus struct { Name string Color string } func (o Octopus) String() string { return fmt.Sprintf(\u0026#34;The octopus\u0026#39;s name is %q and is the color %s.\u0026#34;, o.Name, o.Color) } func (o *Octopus) Reset() { o.Name = \u0026#34;\u0026#34; o.Color = \u0026#34;\u0026#34; } func Hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 如此一来，可以从其他包中调用`Reset\u0026rsquo;而不会得到错误：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gopherguides/greet\u0026#34; ) func main() { greet.Hello() fmt.Println(greet.Shark) oct := greet.Octopus{ Name: \u0026#34;Jesse\u0026#34;, Color: \u0026#34;orange\u0026#34;, } fmt.Println(oct.String()) oct.Reset() fmt.Println(oct.String()) } 现在，如果你运行这个程序：\ngo run main.go 你将收到以下输出：\nHello, World! Sammy The octopus\u0026#39;s name is \u0026#34;Jesse\u0026#34; and is the color orange The octopus\u0026#39;s name is \u0026#34;\u0026#34; and is the color . 通过调用Reset，清除了Name和Color字段中的所有信息。当调用String方法时，Name和Color打印为空，因为这些字段现在是空的。\n总结 # 编写 Go 包与编写其他 Go 文件是一样的，但把它放在另一个目录中可以隔离代码，以便在其他地方重复使用。本教程介绍了如何在包中编写定义，演示了如何在另一个 Go 文件中使用这些定义，并解释了控制包是否可访问的选项。\n"},{"id":21,"href":"/How-To-Code-in-Go/docs/22-Understanding_Package_Visibility_in_Go/","title":"22 Understanding Package Visibility in Go","section":"Docs","content":" 理解 Go 中包的可见性 # 介绍 # 当创建一个Go 中的包时，最终的目标通常是让其他开发者可以使用这个包，无论是高阶包还是整个程序。通过导入包，你的这段代码可以作为其他更复杂的工具的构建模块。然而，只有某些包是可以导入的。这是由包的可见性决定的。\n这里的可见性是指一个包或其他构造可以被引用的文件空间。例如，如果我们在一个函数中定义一个变量，那么这个变量的可见性（范围）只在定义它的那个函数中。同样，如果你在一个包中定义了一个变量，你可以让它只在该包中可见，或允许它在包外也可见。\n在编写符合人体工程学的代码时，仔细控制包的可见性是很重要的，特别是在考虑到将来可能要对你的包进行修改时。如果你需要修复一个错误，提高性能，或改变功能，你会希望以一种不会破坏使用你的包的人的代码的方式进行改变。尽量减少破坏性修改的一个方法是只允许访问你的包中需要正常使用的部分。通过限制访问，你可以在内部对包进行修改，而减少影响其他开发者使用你的包的机会。\n在这篇文章中，将学习如何控制包的可见性，以及如何保护代码中只应在包内使用的部分。为了做到这一点，我们将创建一个基本的记录器来记录和调试信息，使用具有不同程度的项目可见性的包。\n前提条件 # 要遵循本文中的示例，你将需要：\n按照如何安装 Go 并设置本地编程环境设置的 Go 工作区。 本教程将使用以下文件结构： . ├── bin │ └── src └── github.com └── gopherguides 可导出与不可导出 # 不同于其他程序语言，如 Java 和Python使用访问修饰符如public、private或protected来指定范围不同，Go 通过其声明方式来决定一个项目是否exported和unxported。在这种情况下，导出一个项目会使它在当前包之外是 \u0026ldquo;可见的\u0026rdquo;。如果它没有被导出，它只能在它被定义的包内可见和使用。\n这种外部可见性是通过将声明的项目的第一个字母大写来控制的。所有以大写字母开头的声明，如 \u0026ldquo;类型\u0026rdquo;、\u0026ldquo;变量\u0026rdquo;、\u0026ldquo;常量\u0026rdquo;、\u0026ldquo;函数\u0026quot;等，在当前包外是可见的。\n让我们看看下面的代码，仔细注意一下大写字母。\npackage greet import \u0026#34;fmt\u0026#34; var Greeting string func Hello(name string) string { return fmt.Sprintf(Greeting, name) } 这段代码声明它是在greet包中。然后声明了两个符号，一个叫做 Greeting 的变量和一个叫做 Hello 的函数。因为它们都以大写字母开头，所以它们都被 \u0026ldquo;可导出\u0026rdquo; 的，可供任何外部程序使用。如前所述，精心设计一个限制访问的包将允许更好的 API 设计，并使内部更新你的包更容易，而不会破坏任何依赖此包的代码。\n定义包的可见性 # 为了仔细看看包的可见性在程序中是如何工作的，让我们创建一个logging包，记住哪些信息我们希望包外可见，哪些我们不希望它可见。这个日志包将负责把我们程序的任何信息记录到控制台。它还将查看我们在什么级别上进行的日志记录，一个级别描述了日志的类型，它将是三种状态之一：信息、警告或错误。\n首先，在你的 src 目录下，创建一个名为 logging 的目录来放置日志文件：\nmkdir logging 进入目录：\ncd logging 然后，使用 nano 这样的编辑器，创建一个名为logging.go的文件：\nnano logging.go 在刚刚创建的logging.go文件中写入以下代码：\npackage logging import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var debug bool func Debug(b bool) { debug = b } func Log(statement string) { if !debug { return } fmt.Printf(\u0026#34;%s %s\\n\u0026#34;, time.Now().Format(time.RFC3339), statement) } 这段代码的第一行声明了一个名为 logging 的包。在这个包中，有两个 \u0026ldquo;导出 \u0026ldquo;的函数。Debug和Log。这些函数可以被任何其他导入logging的包所调用。还有一个名为debug的私有变量。这个变量只能从logging包内访问。值得注意的是，虽然函数Debug和变量debug的拼写相同，但函数是大写的，变量不是。这使得它们成为具有不同作用域的不同声明。\n保存并退出该文件。\n为了在我们代码的其他地方使用这个包，我们可以import它到一个新的包。我们将创建这个新的包，但需要一个新的目录来首先存储这些源文件。\n让我们离开logging目录，创建一个名为cmd的新目录，然后进入这个新目录：\ncd .. mkdir cmd cd cmd 在刚刚创建的cmd目录下创建一个名为main.go的文件：\nnano main.go 现在我们可以添加以下代码：\npackage main import \u0026#34;github.com/gopherguides/logging\u0026#34; func main() { logging.Debug(true) logging.Log(\u0026#34;This is a debug statement...\u0026#34;) } 现在整个程序已经写好了。然而，在运行这个程序之前，我们还需要创建几个配置文件，以便我们的代码能够正常工作。Go 使用Go 模块来配置导入资源的软件包依赖性。Go 模块是放置在你的包目录中的配置文件，它告诉编译器从哪里导入包。虽然对模块的学习超出了本文的范围，但我们可以只写几行配置来使这个例子在本地工作。\n在cmd目录下打开以下go.mod文件：\nnano go.mod 然后在文件中放置以下内容：\nmodule github.com/gopherguides/cmd replace github.com/gopherguides/logging =\u0026gt; ../logging 这个文件的第一行告诉编译器，cmd包的文件路径是github.com/gopherguides/cmd。第二行告诉编译器，github.com/gopherguides/logging包可以在磁盘上的.../logging目录下找到。\n我们还需要一个go.mod文件用于我们的logging包。让我们回到logging目录中，创建一个go.mod文件。\ncd ../logging nano go.mod 在文件中加入以下内容：\nmodule github.com/gopherguides/logging 这告诉编译器，我们创建的logging包实际上是github.com/gopherguides/logging包。这使得在 main 包中导入该包成为可能，之前写了以下这一行：\npackage main import \u0026#34;github.com/gopherguides/logging\u0026#34; func main() { logging.Debug(true) logging.Log(\u0026#34;This is a debug statement...\u0026#34;) } 你现在应该有以下目录结构和文件布局：\n├── cmd │ ├── go.mod │ └── main.go └── logging ├── go.mod └── logging.go 现在我们已经完成了所有的配置，可以用以下命令运行cmd包中的main程序：\ncd ../cmd go run main.go 你将得到类似以下的输出：\n2019-08-28T11:36:09-05:00 This is a debug statement... 该程序将以 RFC 3339 格式打印出当前时间，后面是我们发送给记录器的任何语句。RFC 3339是一种时间格式，被设计用来表示互联网上的时间，通常用于日志文件。\n因为Debug和Log函数是从日志包中导出的，我们可以在main包中使用它们。然而，logging包中的debug变量没有被导出。试图引用一个未导出的声明将导致一个编译时错误。\n在main.go中添加错误操作的一行fmt.Println(logging.debug)：\npackage main import \u0026#34;github.com/gopherguides/logging\u0026#34; func main() { logging.Debug(true) logging.Log(\u0026#34;This is a debug statement...\u0026#34;) fmt.Println(logging.debug) } 保存并运行该文件，你将收到一个类似于以下的错误：\n. . . ./main.go:10:14: cannot refer to unexported name logging.debug 现在我们已经了解了包中的 exported 和 unexported 项的行为，接下来我们将看看如何从 structs 中导出 fields 和 methods。\n结构内的可见性 # 虽然在上一节中构建的记录器中的可见性方案可能对简单的程序有效，但它分享了太多的状态，在多个包中都是有用的。这是因为导出的变量可以被多个包所访问，这些包可以将变量修改成相互矛盾的状态。允许你的包的状态以这种方式被改变，使得你很难预测你的程序将如何表现。例如，在目前的设计中，一个包可以将Debug变量设置为true，而另一个包可以在同一实例中将其设置为false。这将产生一个问题，因为导入logging包的两个包都会受到影响。\n我们可以通过创建一个结构，然后把方法挂在它上面，使日志记录器隔离。这将允许我们创建一个日志记录器的instance实例，在每个使用它的包中独立使用。\n将logging包改为以下内容，以重构代码并隔离记录器：\npackage logging import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type Logger struct { timeFormat string debug bool } func New(timeFormat string, debug bool) *Logger { return \u0026amp;Logger{ timeFormat: timeFormat, debug: debug, } } func (l *Logger) Log(s string) { if !l.debug { return } fmt.Printf(\u0026#34;%s %s\\n\u0026#34;, time.Now().Format(l.timeFormat), s) } 在这段代码中，我们创建了一个Logger结构。这个结构将存放未导出的状态，包括要打印出来的时间格式和debug变量设置为true或false。New函数设置初始状态来创建记录器，例如时间格式和调试状态。然后，它将内部给它的值存储到未导出的变量timeFormat和debug中。我们还在Logger类型上创建了一个名为Log的方法，该方法接收我们想要打印出来的语句。在Log方法内有一个对其本地方法变量l的引用，以获得对其内部字段的访问，如l.timeFormat和l.debug。\n这种方法将允许在许多不同的包中创建一个Logger，并独立于其他包的使用方式而使用它。\n为了在其他软件包中使用它，让我们把cmd/main.go改成下面的样子：\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/gopherguides/logging\u0026#34; ) func main() { logger := logging.New(time.RFC3339, true) logger.Log(\u0026#34;This is a debug statement...\u0026#34;) } 运行这个程序将给你带来以下输出：\noutput 2019-08-28T11:56:49-05:00 This is a debug statement... 在这段代码中，我们通过调用导出的函数New创建了一个记录器的实例。将这个实例的引用存储在logger变量中。现在可以调用logging.Log来打印出语句。\n如果试图从logger中引用一个未导出的字段，如timeFormat字段，将收到一个编译时错误。尝试添加以下高亮行，并运行cmd/main.go。\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/gopherguides/logging\u0026#34; ) func main() { logger := logging.New(time.RFC3339, true) logger.Log(\u0026#34;This is a debug statement...\u0026#34;) fmt.Println(logger.timeFormat) } 这将给出如下错误信息：\n. . . cmd/main.go:14:20: logger.timeFormat undefined (cannot refer to unexported field or method timeFormat) 编译器认识到logger.timeFormat没有被导出，因此不能从logging包中检索到。\n方法中的可见性 # 与结构字段相同，方法也可以被导出或未导出。\n为了说明这一点，让我们为日志器添加级别的日志记录。分级日志是一种对日志进行分类的方法，这样就可以在日志中搜索特定类型的事件。我们将在记录器中加入的级别是。\ninfo级别，代表信息类型的事件，通知用户一个动作，如 \u0026ldquo;程序开始\u0026rdquo;，或 \u0026ldquo;电子邮件发送\u0026rdquo;。这些帮助我们调试和跟踪我们程序的一部分，看看是否有预期的行为发生。 warning 级别。这些类型的事件可以识别出一些不属于错误的意外情况，如 \u0026ldquo;邮件发送失败，重试\u0026rdquo;。它们帮助我们看到我们的程序中没有像我们预期的那样顺利进行的部分。 error级别，意味着程序遇到了问题，如 \u0026ldquo;未找到文件\u0026rdquo;。这往往会导致程序的运行失败。 你也可能希望打开和关闭某些级别的日志记录，特别是当你的程序没有按照预期执行，你想调试程序的时候。我们将通过改变程序来增加这个功能，当debug被设置为true时，它将打印所有级别的信息。否则，如果它是false，它将只打印错误信息。\n通过对logging/logging.go进行以下修改来增加分级日志：\npackage logging import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) type Logger struct { timeFormat string debug bool } func New(timeFormat string, debug bool) *Logger { return \u0026amp;Logger{ timeFormat: timeFormat, debug: debug, } } func (l *Logger) Log(level string, s string) { level = strings.ToLower(level) switch level { case \u0026#34;info\u0026#34;, \u0026#34;warning\u0026#34;: if l.debug { l.write(level, s) } default: l.write(level, s) } } func (l *Logger) write(level string, s string) { fmt.Printf(\u0026#34;[%s] %s %s\\n\u0026#34;, level, time.Now().Format(l.timeFormat), s) } 在这个例子中，我们为Log方法引入了一个新的参数。我们现在可以传入日志信息的级别。Log方法决定了它是什么级别的消息。如果是 info 或 warning 消息，并且 debug 字段是 true,，那么它就会写下该消息。否则，它将忽略该消息。如果是其他级别的信息，比如 error，它将写出该信息。\n大多数确定消息是否被打印出来的逻辑存在于Log方法中。我们还引入了一个未导出的方法，叫做 write。write方法是实际输出日志信息的方法。\n现在我们可以在其他软件包中使用这种分级日志，方法是将cmd/main.go改成下面的样子：\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/gopherguides/logging\u0026#34; ) func main() { logger := logging.New(time.RFC3339, true) logger.Log(\u0026#34;info\u0026#34;, \u0026#34;starting up service\u0026#34;) logger.Log(\u0026#34;warning\u0026#34;, \u0026#34;no tasks found\u0026#34;) logger.Log(\u0026#34;error\u0026#34;, \u0026#34;exiting: no work performed\u0026#34;) } 运行这个将返回：\n[info] 2019-09-23T20:53:38Z starting up service [warning] 2019-09-23T20:53:38Z no tasks found [error] 2019-09-23T20:53:38Z exiting: no work performed 在这个例子中，cmd/main.go成功使用了导出的Log方法。\n现在我们可以通过将debug切换为false来传递每个消息的`level\u0026rsquo;：\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/gopherguides/logging\u0026#34; ) func main() { logger := logging.New(time.RFC3339, false) logger.Log(\u0026#34;info\u0026#34;, \u0026#34;starting up service\u0026#34;) logger.Log(\u0026#34;warning\u0026#34;, \u0026#34;no tasks found\u0026#34;) logger.Log(\u0026#34;error\u0026#34;, \u0026#34;exiting: no work performed\u0026#34;) } 现在我们将看到，只有 error 级别的信息会被打印出来：\n[error] 2019-08-28T13:58:52-05:00 exiting: no work performed 如果我们试图从logging包之外调用write方法，我们将收到一个编译时错误：\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/gopherguides/logging\u0026#34; ) func main() { logger := logging.New(time.RFC3339, true) logger.Log(\u0026#34;info\u0026#34;, \u0026#34;starting up service\u0026#34;) logger.Log(\u0026#34;warning\u0026#34;, \u0026#34;no tasks found\u0026#34;) logger.Log(\u0026#34;error\u0026#34;, \u0026#34;exiting: no work performed\u0026#34;) logger.write(\u0026#34;error\u0026#34;, \u0026#34;log this message...\u0026#34;) } cmd/main.go:16:8: logger.write undefined (cannot refer to unexported field or method logging.(*Logger).write) 当编译器看到你试图引用另一个包中以小写字母开头的东西时，它知道这个东西没有被导出，因此抛出一个编译器错误。\n本教程中的记录器说明了如何编写代码，只暴露出希望其他包消费的部分。因为我们控制了包的哪些部分在包外是可见的，所以现在能够在未来进行修改而不影响任何依赖包的代码。例如，如果想只在debug为 false 时关闭info级别的消息，你可以在不影响你的 API 的任何其他部分的情况下做出这个改变。我们也可以安全地对日志信息进行修改，以包括更多的信息，如程序运行的目录。\n总结 # 这篇文章展示了如何在包之间共享代码，同时也保护你的包的实现细节。这允许你输出一个简单的 API，为了向后兼容而很少改变，但允许在你的包中根据需要私下改变，使其在未来更好地工作。这被认为是创建包和它们相应的 API 时的最佳做法。\n要了解更多关于 Go 中的包，请查看我们的在 Go 中导入包和如何在 Go 中编写包文章，或者探索我们整个如何在 Go 中编码系列。\n"},{"id":22,"href":"/How-To-Code-in-Go/docs/23-How_To_Write_Conditional_Statements_in_Go/","title":"23 How to Write Conditional Statements in Go","section":"Docs","content":" 如何在 Go 中编写条件语句 # 介绍 # 条件性语句是每一种编程语言的组成部分。通过条件语句，我们可以让代码有时运行，有时不运行，这取决于当时程序的条件。\n当我们完全执行程序的每个语句时，我们并没有要求程序评估特定的条件。通过使用条件语句，程序可以确定某些条件是否被满足，然后被告知下一步该做什么。\n让我们来看看一些使用条件语句的例子。\n如果学生的考试成绩超过65%，报告她的成绩通过；如果没有，报告她的成绩不合格。 如果他的账户里有钱，就计算利息；如果没有，就收取罚款。 如果他们买了10个或更多的橙子，计算5%的折扣；如果他们买的少，就不买。 通过评估条件，并根据是否满足这些条件来分配代码运行，我们就是在写条件代码。\n本教程将带你了解在 Go 编程语言中编写条件语句。\nIf 语句 # 我们将从 if 语句开始，它将评估一个语句是真的还是假的，并且只在该语句为真的情况下运行代码。\n在一个纯文本编辑器中，打开一个文件，写入以下代码：\npackage main import \u0026#34;fmt\u0026#34; func main() { grade := 70 if grade \u0026gt;= 65 { fmt.Println(\u0026#34;Passing grade\u0026#34;) } } 在这段代码中，我们有一个变量grade，并给它一个整数值70。然后我们使用if语句来评估变量grade是否大于或等于（\u0026gt;=）65。如果它确实满足这个条件，我们告诉程序打印出字符串 Passing grade。\n将程序保存为grade.go，并在终端窗口中用go run grade.go命令运行它。\n在这种情况下，70分的成绩*符合大于或等于65分的条件，因此，一旦你运行该程序，你将收到以下输出：\nPassing grade 现在让我们改变这个程序的结果，把grade变量的值改为60：\npackage main import \u0026#34;fmt\u0026#34; func main() { grade := 60 if grade \u0026gt;= 65 { fmt.Println(\u0026#34;Passing grade\u0026#34;) } } 当我们保存并运行这个代码时，我们不会收到任何输出，因为条件*没有得到满足，我们也没有告诉程序执行另一条语句。\n再举一个例子，让我们计算一个银行账户余额是否低于0。让我们创建一个名为account.go的文件，并编写以下程序：\npackage main import \u0026#34;fmt\u0026#34; func main() { balance := -5 if balance \u0026lt; 0 { fmt.Println(\u0026#34;Balance is below 0, add funds now or you will be charged a penalty.\u0026#34;) } } 当我们用go run account.go运行该程序时，我们会收到以下输出：\nBalance is below 0, add funds now or you will be charged a penalty. 在程序中，我们将变量balance初始化为5，即小于0。由于balance符合if语句的条件（balance\u0026lt;0），一旦我们保存并运行代码，我们将收到字符串的输出。同样，如果我们把余额改为0或一个正数，我们将不会收到任何输出。\nElse 语句 # 我们很可能希望程序在 if语句评估为假时也能有所作为。在我们的成绩例子中，我们希望输出成绩是合格还是不合格。\n要做到这一点，我们将在上面的成绩条件中添加一个 else 语句，其结构如下：\npackage main import \u0026#34;fmt\u0026#34; func main() { grade := 60 if grade \u0026gt;= 65 { fmt.Println(\u0026#34;Passing grade\u0026#34;) } else { fmt.Println(\u0026#34;Failing grade\u0026#34;) } } 由于成绩变量的值是60，if语句评估为假，所以程序不会打印出Passing grade。接下来的 else 语句告诉程序无论如何都要做一些事情。\n当我们保存并运行该程序时，我们将收到以下输出：\nFailing grade 如果我们重写程序，给成绩一个65或更高的值，我们将收到Passing grade的输出。\n为了给银行账户的例子增加一个 else 语句，我们这样改写代码:\npackage main import \u0026#34;fmt\u0026#34; func main() { balance := 522 if balance \u0026lt; 0 { fmt.Println(\u0026#34;Balance is below 0, add funds now or you will be charged a penalty.\u0026#34;) } else { fmt.Println(\u0026#34;Your balance is 0 or above.\u0026#34;) } } Your balance is 0 or above. 在这里，我们把balance变量的值改为正数，这样else语句就会打印出来。为了让第一个if语句打印出来，我们可以把这个值改写成一个负数。\n通过将if语句和else语句结合起来，你就构建了一个由两部分组成的条件语句，无论if条件是否满足，都会告诉计算机执行某些代码。\nElse if 语句 # 到目前为止，我们已经为条件语句提出了一个布尔选项，每个if语句的评估结果为真或假。在许多情况下，我们会希望一个程序能评估出两个以上的可能结果。为此，我们将使用else if语句，在 Go 中写成else if。else if或 else if 语句看起来和if语句一样，将评估另一个条件。\n在银行账户程序中，我们可能希望在三种不同的情况下有三个离散的输出。\n余额低于0 余额等于0 余额高于0 else if语句将被放在 if 语句和 else 语句之间，如下所示：\npackage main import \u0026#34;fmt\u0026#34; func main() { balance := 522 if balance \u0026lt; 0 { fmt.Println(\u0026#34;Balance is below 0, add funds now or you will be charged a penalty.\u0026#34;) } else if balance == 0 { fmt.Println(\u0026#34;Balance is equal to 0, add funds soon.\u0026#34;) } else { fmt.Println(\u0026#34;Your balance is 0 or above.\u0026#34;) } } 现在，一旦我们运行该程序，有三种可能的输出：\n如果变量余额等于0，我们将收到else if语句的输出（`余额等于0，尽快添加资金。） 如果变量balance被设置为一个正数，我们将收到else语句的输出（你的余额为0或以上）。 如果变量balance被设置为一个负数，输出将是if语句的字符串（余额低于0，现在添加资金，否则将被收取罚款）。 如果我们想有三个以上的可能性呢？我们可以通过在代码中写一个以上的else if语句来实现。\n在grade.go程序中，让我们重写代码，以便有几个字母等级对应于数字等级的范围。\n90分或以上相当于A级 80-89相当于B级 70-79相当于C级 65-69相当于D级 64分或以下相当于F级 要运行这段代码，我们将需要一个if语句，三个else if语句，以及一个处理所有失败情况的else语句。\n让我们重写前面的例子中的代码，让字符串打印出每个字母等级。我们可以保持我们的else语句不变。\npackage main import \u0026#34;fmt\u0026#34; func main() { grade := 60 if grade \u0026gt;= 90 { fmt.Println(\u0026#34;A grade\u0026#34;) } else if grade \u0026gt;= 80 { fmt.Println(\u0026#34;B grade\u0026#34;) } else if grade \u0026gt;= 70 { fmt.Println(\u0026#34;C grade\u0026#34;) } else if grade \u0026gt;= 65 { fmt.Println(\u0026#34;D grade\u0026#34;) } else { fmt.Println(\u0026#34;Failing grade\u0026#34;) } } 由于else if语句将按顺序评估，我们可以保持我们的语句相当基本。这个程序正在完成以下步骤。\n如果成绩大于90，程序将打印 \u0026ldquo;A 级\u0026rdquo;，如果成绩小于90，程序将继续下一个语句\u0026hellip;。 如果成绩大于或等于80，程序将打印 \u0026ldquo;B 级\u0026rdquo;，如果成绩在79或以下，程序将继续下一个语句\u0026hellip;\u0026hellip; 如果成绩大于或等于70，程序将打印 \u0026ldquo;C 级\u0026rdquo;，如果成绩是69或更少，程序将继续下一个语句\u0026hellip;\u0026hellip; 如果成绩大于或等于65，程序将打印 \u0026ldquo;D 级\u0026rdquo;，如果成绩是64或更少，程序将继续下一个语句\u0026hellip;\u0026hellip; 程序将打印 \u0026ldquo;成绩不合格\u0026rdquo;，因为上述所有的条件都没有满足。 嵌套的If语句 # 一旦你对 if, else if, 和 else语句感到满意，你就可以转到嵌套条件语句。我们可以使用嵌套的if语句来处理这样的情况：如果第一个条件执行为真，我们想检查第二个条件。为此，我们可以在另一个 if-else 语句中设置一个 if-else 语句。让我们来看看嵌套的if语句的语法。\nif statement1 { // outer if statement fmt.Println(\u0026#34;true\u0026#34;) if nested_statement { // nested if statement fmt.Println(\u0026#34;yes\u0026#34;) } else { // nested else statement fmt.Println(\u0026#34;no\u0026#34;) } } else { // outer else statement fmt.Println(\u0026#34;false\u0026#34;) } 这段代码可以产生一些可能的输出。\n如果statement1评估为真，程序将评估nested_statement是否也评估为真。如果这两种情况都是真的，那么输出将是： true yes 然而，如果statement1评估为真，但nested_statement评估为假，那么输出将是： true no 而如果statement1评估为 false，嵌套的 if-else 语句将不会运行，所以else语句将单独运行，输出结果为： false 我们也可以在代码中嵌套多个if语句：\nif statement1 { // outer if fmt.Println(\u0026#34;hello world\u0026#34;) if nested_statement1 { // first nested if fmt.Println(\u0026#34;yes\u0026#34;) } else if nested_statement2 { // first nested else if fmt.Println(\u0026#34;maybe\u0026#34;) } else { // first nested else fmt.Println(\u0026#34;no\u0026#34;) } } else if statement2 { // outer else if fmt.Println(\u0026#34;hello galaxy\u0026#34;) if nested_statement3 { // second nested if fmt.Println(\u0026#34;yes\u0026#34;) } else if nested_statement4 { // second nested else if fmt.Println(\u0026#34;maybe\u0026#34;) } else { // second nested else fmt.Println(\u0026#34;no\u0026#34;) } } else { // outer else statement(\u0026#34;hello universe\u0026#34;) } 在这段代码中，除了 else if 语句外，每个 if 语句内都有一个嵌套的 if 语句。这将使每个条件内有更多的选项。\n让我们用grade.go程序来看一个嵌套if语句的例子。可以首先检查一个成绩是否合格（大于或等于65%），然后评估数字成绩应该相当于哪个字母等级。如果成绩不合格，我们就不需要运行字母等级，而可以让程序报告该成绩不合格。修改后的代码和嵌套的 if 语句看起来是这样的：\npackage main import \u0026#34;fmt\u0026#34; func main() { grade := 92 if grade \u0026gt;= 65 { fmt.Print(\u0026#34;Passing grade of: \u0026#34;) if grade \u0026gt;= 90 { fmt.Println(\u0026#34;A\u0026#34;) } else if grade \u0026gt;= 80 { fmt.Println(\u0026#34;B\u0026#34;) } else if grade \u0026gt;= 70 { fmt.Println(\u0026#34;C\u0026#34;) } else if grade \u0026gt;= 65 { fmt.Println(\u0026#34;D\u0026#34;) } } else { fmt.Println(\u0026#34;Failing grade\u0026#34;) } } 如果我们在运行代码时将变量grade设置为整数值92，那么第一个条件就得到了满足，程序将打印出Passing grade of:。接下来，它将检查成绩是否大于或等于90，由于这个条件也被满足，它将打印出A。\n如果我们在运行代码时将grade变量设置为60，那么第一个条件就没有得到满足，所以程序将跳过嵌套的if语句，向下移动到else语句，程序将打印出Failing grade。\n当然，我们可以在此基础上增加更多的选项，并使用第二层嵌套的if语句。也许我们想对A+、A和A-的成绩分别进行评估。我们可以这样做，首先检查成绩是否合格，然后检查成绩是否在90分或以上，然后检查成绩是否在96分以上为A+：\n... if grade \u0026gt;= 65 { fmt.Print(\u0026#34;Passing grade of: \u0026#34;) if grade \u0026gt;= 90 { if grade \u0026gt; 96 { fmt.Println(\u0026#34;A+\u0026#34;) } else if grade \u0026gt; 93 \u0026amp;\u0026amp; grade \u0026lt;= 96 { fmt.Println(\u0026#34;A\u0026#34;) } else { fmt.Println(\u0026#34;A-\u0026#34;) } ... 在这段代码中，对于设置为96的 grade 变量，程序将运行以下程序。\n检查该等级是否大于或等于65（真）。 打印出 Passing grade of: 检查成绩是否大于或等于90（真）。 检查成绩是否大于96（假）。 检查等级是否大于93，同时小于或等于96（真）。 打印 \u0026ldquo;A\u0026rdquo;。 离开这些嵌套的条件语句，继续执行剩余的代码 因此，成绩为96的程序的输出看起来是这样的：\nPassing grade of: A 嵌套的if语句可以提供机会，在你的代码中添加几个特定级别的条件。\n总结 # 通过使用像 if 语句这样的条件语句，你将对你的程序执行内容有更大的控制。条件性语句告诉程序要评估是否满足某个条件。如果满足条件，它将执行特定的代码，但如果不满足条件，程序将继续执行其他代码。\n要继续练习条件语句，请尝试使用不同的运算符来获得对条件语句的更多熟悉。\n"},{"id":23,"href":"/How-To-Code-in-Go/docs/24-How_To_Write_Switch_Statements_in_Go/","title":"24 How to Write Switch Statements in Go","section":"Docs","content":" 如何在 Go 中编写 Switch 语句 # 介绍 # 条件语句使程序员有能力指导他们的程序在某个条件为真时采取某些行动，在条件为假时采取另一种行动。经常，我们想把一些变量与多个可能的值进行比较，在每种情况下采取不同的行动。仅仅使用if语句就可以做到这一点。然而，编写软件不仅是为了让事情顺利进行，也是为了向未来的自己和其他开发者传达你的意图。switch是一个替代性的条件语句，对于传达你的 Go 程序在遇到不同选项时采取的行动很有用。\n我们可以用 switch 语句编写的所有内容也可以用if语句编写。在本教程中，我们将看几个例子，看看 switch 语句能做什么，它所取代的if语句，以及它最合适的应用场合。\nSwitch 语句的结构 # Switch 通常用于描述当一个变量被分配到特定值时程序所采取的行动。下面的例子演示了我们如何使用 if 语句来完成这个任务。\npackage main import \u0026#34;fmt\u0026#34; func main() { flavors := []string{\u0026#34;chocolate\u0026#34;, \u0026#34;vanilla\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;banana\u0026#34;} for _, flav := range flavors { if flav == \u0026#34;strawberry\u0026#34; { fmt.Println(flav, \u0026#34;is my favorite!\u0026#34;) continue } if flav == \u0026#34;vanilla\u0026#34; { fmt.Println(flav, \u0026#34;is great!\u0026#34;) continue } if flav == \u0026#34;chocolate\u0026#34; { fmt.Println(flav, \u0026#34;is great!\u0026#34;) continue } fmt.Println(\u0026#34;I\u0026#39;ve never tried\u0026#34;, flav, \u0026#34;before\u0026#34;) } } 这将输出如下信息：\nchocolate is great! vanilla is great! strawberry is my favorite! I\u0026#39;ve never tried banana before 在main中，我们定义了一个slice的冰激凌口味。然后我们使用一个for loop来迭代它们。我们使用三个if语句来打印不同的信息，表明对不同冰淇淋口味的偏好。每个if语句必须使用continue语句来停止for循环的执行，这样就不会在最后打印出首选冰淇淋口味的默认信息。\n当我们添加新的偏好时，我们必须不断添加if语句来处理新的情况。重复的信息，如 \u0026ldquo;香草\u0026quot;和 \u0026ldquo;巧克力\u0026quot;的情况，必须有重复的if语句。对于我们代码的未来读者（包括我们自己）来说，if语句的重复性掩盖了它们所做的重要部分\u0026ndash;将变量与多个值进行比较并采取不同的行动。另外，我们的回退信息与条件语句分开，使得它看起来不相关。转换器 \u0026ldquo;语句可以帮助我们更好地组织这个逻辑。\nswitch 语句以 switch 关键字开始，在其最基本的形式下，后面是一些要进行比较的变量。之后是一对大括号（{}），其中可以出现多个case 子句。case 子句描述了当提供给 switch 语句的变量等于 case 子句所引用的值时，Go 程序应该采取的行动。下面的例子将先前的例子转换为使用一个switch而不是多个if语句：\npackage main import \u0026#34;fmt\u0026#34; func main() { flavors := []string{\u0026#34;chocolate\u0026#34;, \u0026#34;vanilla\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;banana\u0026#34;} for _, flav := range flavors { switch flav { case \u0026#34;strawberry\u0026#34;: fmt.Println(flav, \u0026#34;is my favorite!\u0026#34;) case \u0026#34;vanilla\u0026#34;, \u0026#34;chocolate\u0026#34;: fmt.Println(flav, \u0026#34;is great!\u0026#34;) default: fmt.Println(\u0026#34;I\u0026#39;ve never tried\u0026#34;, flav, \u0026#34;before\u0026#34;) } } } 输出与之前相同：\nchocolate is great! vanilla is great! strawberry is my favorite! I\u0026#39;ve never tried banana before 我们再次在main中定义了一片冰淇淋的口味，并使用range语句来遍历每个口味。但是这一次，我们使用了一个switch语句来检查flav变量。我们使用两个case'子句来表示偏好。我们不再需要继续\u0026rsquo;语句，因为只有一个case子句将被switch语句执行。我们还可以将\u0026quot;巧克力\u0026quot;和 \u0026ldquo;香草\u0026quot;条件的重复逻辑结合起来，在 case子句的声明中用逗号将其分开。default子句是我们的万能子句。它将对我们在 switch 语句中没有考虑到的任何口味运行。在这种情况下，\u0026ldquo;香蕉\u0026quot;将导致 default 的执行，打印出 \u0026ldquo;I\u0026rsquo;ve never tried banana before\u0026quot;的信息。\n这种简化形式的switch语句解决了它们最常见的用途：将一个变量与多个替代品进行比较。它还为我们提供了便利，当我们想对多个不同的值采取相同的行动，以及在没有满足所列的条件时，通过使用所提供的default关键字采取一些其他行动。\n当这种简化的switch形式被证明太有局限性时，我们可以使用一种更通用的switch语句形式。\n通常的 Switch 语句 # switch语句对于将更复杂的条件集合在一起以显示它们之间有某种联系是很有用的。这在将某些变量与一定范围的值进行比较时最常用，而不是像前面的例子中的特定值。下面的例子使用if语句实现了一个猜谜游戏，可以从switch语句中受益：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { rand.Seed(time.Now().UnixNano()) target := rand.Intn(100) for { var guess int fmt.Print(\u0026#34;Enter a guess: \u0026#34;) _, err := fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;guess) if err != nil { fmt.Println(\u0026#34;Invalid guess: err:\u0026#34;, err) continue } if guess \u0026gt; target { fmt.Println(\u0026#34;Too high!\u0026#34;) continue } if guess \u0026lt; target { fmt.Println(\u0026#34;Too low!\u0026#34;) continue } fmt.Println(\u0026#34;You win!\u0026#34;) break } } 输出将取决于所选择的随机数和你玩游戏的程度。下面是一个例子会话的输出：\nEnter a guess: 10 Too low! Enter a guess: 15 Too low! Enter a guess: 18 Too high! Enter a guess: 17 You win! 我们的猜谜游戏需要一个随机数来比较猜测的结果，所以我们使用math/rand包中的rand.Intn函数。为了确保我们每次玩游戏都能得到不同的target值，我们使用rand.Seed来根据当前时间随机化随机数发生器。rand.Intn的参数100将给我们一个0-100范围内的数字。然后我们使用for循环来开始收集玩家的猜测。\nfmt.Scanf函数为我们提供了一种方法来读取用户的输入到我们选择的变量中。它接受一个格式化的字符串动词，将用户的输入转换为我们期望的类型。这里的%d意味着我们期望一个 int，我们传递 guess 变量的地址，这样 fmt.Scanf 就能够设置该变量。在处理任何解析错误之后，我们使用两个if语句来比较用户的猜测和target值。它们返回的string和bool一起控制显示给玩家的信息，以及游戏是否会退出。\n这些 if 语句掩盖了一个事实，即变量被比较的数值范围都有某种联系。一眼就能看出我们是否遗漏了该范围的某些部分，这也是很困难的。下一个例子重构了前面的例子，用switch语句代替：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { target := rand.Intn(100) for { var guess int fmt.Print(\u0026#34;Enter a guess: \u0026#34;) _, err := fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;guess) if err != nil { fmt.Println(\u0026#34;Invalid guess: err:\u0026#34;, err) continue } switch { case guess \u0026gt; target: fmt.Println(\u0026#34;Too high!\u0026#34;) case guess \u0026lt; target: fmt.Println(\u0026#34;Too low!\u0026#34;) default: fmt.Println(\u0026#34;You win!\u0026#34;) return } } } 这将产生类似以下的输出:\nEnter a guess: 25 Too low! Enter a guess: 28 Too high! Enter a guess: 27 You win! 在这个版本的猜谜游戏中，我们用一个switch语句代替了if语句块。我们省略了switch的表达式参数，因为我们只对使用switch来收集条件语句感兴趣。每个case子句包含一个不同的表达式，将guess与target进行比较。与第一次用switch代替if语句类似，我们不再需要continue语句，因为只有一个case子句会被执行。最后，default子句处理guess == target的情况，因为我们已经用另外两个case子句覆盖了所有其他可能的值。\n在我们目前看到的例子中，正好有一个 case 语句将被执行。偶尔，你可能希望结合多个case子句的行为。switch语句提供了另一个实现这种行为的关键字。\nFallthrough # 有时你想重复使用另一个 case 子句包含的代码。在这种情况下，可以使用 fallthrough 关键字要求 Go 运行下一个 case 子句的主体。下面这个例子修改了我们之前的冰淇淋口味的例子，以更准确地反映我们对草莓冰淇淋的热情：\npackage main import \u0026#34;fmt\u0026#34; func main() { flavors := []string{\u0026#34;chocolate\u0026#34;, \u0026#34;vanilla\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;banana\u0026#34;} for _, flav := range flavors { switch flav { case \u0026#34;strawberry\u0026#34;: fmt.Println(flav, \u0026#34;is my favorite!\u0026#34;) fallthrough case \u0026#34;vanilla\u0026#34;, \u0026#34;chocolate\u0026#34;: fmt.Println(flav, \u0026#34;is great!\u0026#34;) default: fmt.Println(\u0026#34;I\u0026#39;ve never tried\u0026#34;, flav, \u0026#34;before\u0026#34;) } } } 将得到如下输出：\nchocolate is great! vanilla is great! strawberry is my favorite! strawberry is great! I\u0026#39;ve never tried banana before 正如我们之前看到的，我们定义了一个 string 片段来表示口味，并使用 for 循环来迭代。这里的 switch 语句与我们之前看到的语句相同，但是在 case 子句的末尾添加了 fallthrough 关键字，即 strawberry。这将使 Go 运行case \u0026quot;strawberry\u0026quot;:的主体，首先打印出字符串strawberry is my favorite!。当它遇到fallthrough时，它将运行下一个case子句的主体。这将导致case \u0026quot;vanilla\u0026quot;, \u0026quot;chocolate\u0026quot;:的主体运行，打印出strawberry is great!。\nGo 开发人员不经常使用fallthrough关键字。通常情况下，通过使用fallthrough实现的代码重用，可以通过定义一个具有公共代码的函数来更好地获得。由于这些原因，一般不鼓励使用fallthrough。\n总结 # switch语句帮助我们向阅读代码的其他开发者传达出彼此有某种联系。使我们在将来添加新的情况时更容易添加不同的行为，并有可能确保任何忘记的事情也能通过default子句得到正确处理。下次你发现自己写的多个if语句都涉及同一个变量时，试着用switch语句重写它\u0026ndash;你会发现当需要考虑其他值时，它将更容易重写。\n如果你想了解更多关于 Go 编程语言的信息，请查看整个How To Code in Go 系列\n"},{"id":24,"href":"/How-To-Code-in-Go/docs/25-How_To_Construct_For_Loops_in_Go/","title":"25 How to Construct for Loops in Go","section":"Docs","content":" 如何在 Go 中构造 for 循环 # 介绍 # 在计算机编程中，循环 是在满足某些条件之前循环重复执行一段代码的代码结构。在计算机编程中使用循环可以让您自动并重复地执行类似的任务。想象一下，如果您有一个需要处理的文件列表，或者您想计算一篇文章的行数。您就可以在代码中使用循环来解决这样的问题。\n在 Go 中，for 循环是基于循环计数器或循环变量实现代码的重复执行。与其他具有多个循环结构（例如 while ， do 等 ）的编程语言不同，Go 只有 for 循环。这有助于使您的代码更清晰和更具可读性，因为您不必担心会有多种策略来实现相同的循环结构。在开发过程中，这种强可读性和低认知负担也将使您的代码比其他语言更不容易出错。\n在本教程中，您将了解 Go 中 for 循环是如何工作的，包括其使用的三个主要变体。我们将首先展示如何创建不同类型的 for 循环，然后介绍如何在 Go 中遍历顺序数据类型。最后，我们将解释如何使用嵌套循环。\n声明 ForClause 和 Condition 循环 # 为了适应各种用例，在 Go 中创建 for 循环有三种不同的方法，每种方法都有自己的功能。这些是使用 Condition、ForClause 或 RangeClause 创建 for 循环。在本节中，我们将解释如何声明和使用 ForClause 和 Condition 变体。\n让我们先看看如何在 ForClause 中使用 for 循环。\nForClause 循环 被定义为有一个 初始语句，后跟一个 条件，然后是一个 后置语句。它们按以下语法排列：\nfor [ Initial Statement ] ; [ Condition ] ; [ Post Statement ] { [Action] } 为了解释前面组成元素的作用，让我们看一个使用 ForClause 语法在指定值范围内递增的 for 循环：\nfor i := 0; i \u0026lt; 5; i++ { fmt.Println(i) } 让我们分解这个循环并识别每个部分\n循环的第一部分是 i := 0 ，这是初始语句：\nfor i := 0; i \u0026lt; 5; i++ { fmt.Println(i) } 它表明我们正在声明一个名为 i 的变量，并将初始值设置为 0。\n接下来是条件：\nfor i := 0; i \u0026lt; 5; i++ { fmt.Println(i) } 在这种情况下，我们声明当 i 小于 5 时，循环应该继续。\n最后，是一个后置语句：\nfor i := 0; i \u0026lt; 5; i++ { fmt.Println(i) } 在后置语句中，循环遍历 i 以 i++ 增量运算符进行迭代加一。\n当我们运行这个程序时，输出如下所示：\nOutput 0 1 2 3 4 循环运行了 5 次。最初，设置 i 为 0，然后检查是否 i 小于5。由于 i 的值小于 5 ，因此执行了循环并执行了 fmt.Println(i) 的动作。循环结束时， 调用 i++ 语句，使 i 的值加 1。\n注意： 请记住，在编程中我们倾向于从索引 0 开始，这就是为什么虽然打印了 5 个数字，但它们的范围是 0-4。\n我们不会限制必须从 0 开始或者以某个特定值结束。我们可以为我们的初始语句分配任何值，也可以在我们的后置语句中赋予任何值。这允许我们创建任何所需的范围来循环：\nfor i := 20; i \u0026lt; 25; i++ { fmt.Println(i) } 在这里，迭代会从 20（包括）到 25（不包括），所以输出如下所示：\nOutput 20 21 22 23 24 我们还可以使用我们的后置语句以不同的值递增。这类似于其他语言中的 step：\n首先，让我们使用正值递增的后置语句：\nfor i := 0; i \u0026lt; 15; i += 3 { fmt.Println(i) } 在这种情况下，设置 for 循环以便打印出从 0 到 15 的数字，但增量为 3，因此每三个数字打印一次，如下所示：\nOutput 0 3 6 9 12 我们也可以为我们的后置语句使用负值来向后迭代，但我们必须相应地调整我们的初始语句和条件参数：\nfor i := 100; i \u0026gt; 0; i -= 10 { fmt.Println(i) } 在这里，我们将 i 初始值设置为100，使用 i \u0026lt; 0 的条件在处停止，并且后置语句使用 -= 运算符将值减 10。循环开始于 100 并结束于 0，每次迭代减少 10。我们可以在输出中看到这种情况：\nOutput 100 90 80 70 60 50 40 30 20 10 您也可以从语法中不使用初始语句和后置语句，而只使用条件。这就是所谓的 Condition 循环：\ni := 0 for i \u0026lt; 5 { fmt.Println(i) i++ } 这一次，我们在前面的代码行中将变量声明为 i 与循环分开。该循环只有一个条件子句，用于检查 i 是否小于5。只要条件为 true，循环就会继续迭代。\n有时您可能不知道完成某项任务所需的迭代次数。在这种情况下，您可以省略所有语句，并使用 break 关键字退出执行：\nfor { if someCondition { break } // do action here } 这方面的一个例子可能是，如果我们正在从一个不确定大小的结构（如缓冲区）中读取，并且我们不知道何时完成读取：\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; ) func main() { buf := bytes.NewBufferString(\u0026#34;one\\ntwo\\nthree\\nfour\\n\u0026#34;) for { line, err := buf.ReadString(\u0026#39;\\n\u0026#39;) if err != nil { if err == io.EOF { fmt.Print(line) break } fmt.Println(err) break } fmt.Print(line) } } 在前面的代码中，buf :=bytes.NewBufferString(\u0026quot;one\\ntwo\\nthree\\nfour\\n\u0026quot;) 声明了一个包含一些数据的缓冲区。因为我们不知道缓冲区何时会完成读取，所以我们创建了一个没有子句的 for 循环。在 for 循环内部，我们使用 line, err := buf.ReadString('\\n') 从缓冲区读取一行并检查从缓冲区读取是否有错误。如果有，我们解决错误，并使用 break 关键字退出 for 循环。有了break，您就不需要使用停止循环的条件。\n在本节中，我们学习了如何声明 ForClause 循环并使用它来迭代已知范围的值。我们还学习了如何使用 Condition 循环进行迭代，直到满足特定条件。接下来，我们将了解 RangeClause 如何用于迭代顺序数据类型。\n使用 RangeClause 循环遍历顺序数据类型 # 在 Go 中，使用 for 循环来迭代连续或集合数据类型（如切片、数组和字符串）的元素是很常见的。为了更容易做到这一点，我们可以使用带有 RangeClause 语法的 for 循环。虽然您可以使用 ForClause 语法遍历顺序数据类型，但 RangeClause 更简洁且更易于阅读。\n在我们研究使用 RangeClause 之前，让我们看看如何使用 ForClause 语法遍历切片：\npackage main import \u0026#34;fmt\u0026#34; func main() { sharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;} for i := 0; i \u0026lt; len(sharks); i++ { fmt.Println(sharks[i]) } } 运行它将给出以下输出，打印出切片的每个元素：\nOutput hammerhead great white dogfish frilled bullhead requiem 现在，让我们使用 RangeClause 执行相同的操作：\npackage main import \u0026#34;fmt\u0026#34; func main() { sharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;} for i, shark := range sharks { fmt.Println(i, shark) } } 在这种情况下，我们打印出列表中的每个项。虽然我们使用了变量 i 和 shark ，但我们可以将变量称为任何其他有效的变量名，我们会得到相同的输出：\nOutput 0 hammerhead 1 great white 2 dogfish 3 frilled 4 bullhead 5 requiem 在切片上使用 range 时，它将始终返回两个值。第一个值将是当前迭代所在的索引，第二个是该索引处的值。在这个示例中，对于第一次迭代，索引是 0，值是 hammerhead。\n有时，我们只想要切片元素内的值，而不是索引。但是，如果我们将前面的代码更改为仅打印值，我们将收到编译时错误：\npackage main import \u0026#34;fmt\u0026#34; func main() { sharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;} for i, shark := range sharks { fmt.Println(shark) } } Output src/range-error.go:8:6: i declared and not used 因为 i 在 for 循环中声明了，但从未使用过，编译器会报告 i declared and not used。每当您声明一个变量并且不使用它时，您都会在 Go 中收到相同的错误。\n因此，Go 具有空白标识符，即下划线 ( _ )。在 for 循环中，您可以使用空白标识符来忽略从 range 关键字返回的任何值。在这种情况下，我们要忽略索引，它是返回的第一个参数。\npackage main import \u0026#34;fmt\u0026#34; func main() { sharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;} for _, shark := range sharks { fmt.Println(shark) } } Output hammerhead great white dogfish frilled bullhead requiem 输出显示 for 循环遍历字符串切片，并打印切片中每个项，且不会打印索引。\n您也可以使用 range 将项目添加到列表中：\npackage main import \u0026#34;fmt\u0026#34; func main() { sharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;} for range sharks { sharks = append(sharks, \u0026#34;shark\u0026#34;) } fmt.Printf(\u0026#34;%q\\n\u0026#34;, sharks) } Output [\u0026#39;hammerhead\u0026#39;, \u0026#39;great white\u0026#39;, \u0026#39;dogfish\u0026#39;, \u0026#39;frilled\u0026#39;, \u0026#39;bullhead\u0026#39;, \u0026#39;requiem\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;] 在这里，我们为切片 \u0026quot;shark\u0026quot; 添加了切片长度的占位符字符串 sharks。\n请注意，我们不必使用空白标识符 _ 来忽略 range 运算符的任何返回值。如果我们不需要使用任何一个 range 的返回值，Go 允许我们省略语句的整个声明部分。\n我们也可以使用 range 运算符来填充切片的值\npackage main import \u0026#34;fmt\u0026#34; func main() { integers := make([]int, 10) fmt.Println(integers) for i := range integers { integers[i] = i } fmt.Println(integers) } 在这个例子中，切片 integers 初始化了十个空值，但 for 循环会设置列表中的所有值，如下所示：\nOutput [0 0 0 0 0 0 0 0 0 0] [0 1 2 3 4 5 6 7 8 9] 第一次打印切片 integers 的值时，我们看到全为零。然后我们遍历每个索引并将值设置为当前索引。然后当我们第二次打印值integers 时，显示它们现在都具有0 到 9 的值。\n我们也可以使用 range 运算符来遍历字符串中的每个字符：\npackage main import \u0026#34;fmt\u0026#34; func main() { sammy := \u0026#34;Sammy\u0026#34; for _, letter := range sammy { fmt.Printf(\u0026#34;%c\\n\u0026#34;, letter) } } Output S a m m y 当遍历 map 时，range将返回键和值：\npackage main import \u0026#34;fmt\u0026#34; func main() { sammyShark := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} for key, value := range sammyShark { fmt.Println(key + \u0026#34;: \u0026#34; + value) } } Output color: blue location: ocean name: Sammy animal: shark 注意：map 返回的顺序是随机的。每次运行此程序时，您可能会得到不同的结果。\n现在我们已经学会了如何使用 range for 循环来遍历数据，下面让我们看看如何在循环中使用循环。\n嵌套 For 循环 # 就像其他编程语言一样，在 Go 中循环也是可以嵌套的。嵌套 是当我们在一个结构内又使用了一个结构。在这种情况下，嵌套循环是发生在另一个循环中的循环。当您希望对数据集的每个元素执行循环操作时，这些可能很有用。\n嵌套循环在结构上类似于嵌套if语句。它的构造如下：\nfor { [Action] for { [Action] } } 程序首先遇到外循环，执行它的第一次迭代。第一次迭代触发内部嵌套循环，然后运行完成。然后程序返回到外部循环的顶部，完成第二次迭代并再次触发嵌套循环。同样，嵌套循环运行到完成，程序返回到外部循环的顶部，直到序列完成或中断或其他语句中断该过程。\n让我们实现一个嵌套 for 循环，以便我们仔细看看。在这个例子中，外层循环将遍历一个名为 numList 的整数切片，而内层循环将遍历一个名为 alphaList 的字符串切片。\npackage main import \u0026#34;fmt\u0026#34; func main() { numList := []int{1, 2, 3} alphaList := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} for _, i := range numList { fmt.Println(i) for _, letter := range alphaList { fmt.Println(letter) } } } 当我们运行这个程序时，我们将得到以下输出：\nOutput 1 a b c 2 a b c 3 a b c 输出说明程序通过打印 1 完成了外循环的第一次迭代，然后连续触发内循环打印的完成。内循环完成后，程序返回到外循环的顶部，打印 2，然后再次完整打印内循环（a, b, c）等。\n嵌套 for 循环可用于遍历由切片组成的切片中的项。在由切片组成的切片中，如果我们只使用一个 for 循环，程序会将每个内部列表作为一项输出：\npackage main import \u0026#34;fmt\u0026#34; func main() { ints := [][]int{ []int{0, 1, 2}, []int{-1, -2, -3}, []int{9, 8, 7}, } for _, i := range ints { fmt.Println(i) } } Output [0 1 2] [-1 -2 -3] [9 8 7] 为了访问内部切片的每个单独项，我们将实现一个嵌套for循环：\npackage main import \u0026#34;fmt\u0026#34; func main() { ints := [][]int{ []int{0, 1, 2}, []int{-1, -2, -3}, []int{9, 8, 7}, } for _, i := range ints { for _, j := range i { fmt.Println(j) } } } Output 0 1 2 -1 -2 -3 9 8 7 当我们在这里使用嵌套 for 循环时，我们能够迭代切片中包含的各个项。\n结论 # 在本教程中，我们学习了如何声明和使用 for 循环来解决 Go 中的重复任务。我们还学习了 for 循环的三种不同变体以及何时使用它们。要了解有关 for 循环以及如何控制它们的流程的更多信息，请阅读在 Go 中使用循环时的 Break 和 Continue 语句。\n"},{"id":25,"href":"/How-To-Code-in-Go/docs/26-Using_Break_and_Continue_Statements_When_Working_with_Loops_in_Go/","title":"26 Using Break and Continue Statements When Working With Loops in Go","section":"Docs","content":" 在循环中使用 Break 和 Continue # 介绍 # 在 Go 中使用 for 循环可以让您以有效的方式自动化重复任务。\n学习如何控制循环的操作和流程将允许在您的程序中自定义逻辑。您可以使用 break 和 continue 语句控制循环\nBreak 语句 # 在 Go 中， break 语句终止当前循环的执行。break几乎总是与条件if语句配对。\n让我们看一个在循环中使用break语句的示例：\npackage main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { if i == 5 { fmt.Println(\u0026#34;Breaking out of loop\u0026#34;) break // break here } fmt.Println(\u0026#34;The value of i is\u0026#34;, i) } fmt.Println(\u0026#34;Exiting program\u0026#34;) } 这个小程序创建了一个 for循环，该循环在当 i 小于 10 时进行迭代。\n在 for 循环中，有一个if语句。该 if语句会检查 i 的值是否小于 5。如果 i 的值不等于 5，则循环继续并打印出 i 的值。如果 i 的值等于 5，则循环将执行 break 语句，打印 Breaking out of loop，并停止循环。在程序结束时，我们打印出 Exiting program 表示我们已经退出了循环。\n当我们运行此代码时，输出将如下所示：\nOutput The value of i is 0 The value of i is 1 The value of i is 2 The value of i is 3 The value of i is 4 Breaking out of loop Exiting program 这表明，一旦整数 i 被检查为等于 5，循环就会中断，因为程序使用 break 语句来这样做。\n嵌套循环 # 要记住，break 语句只会停止调用它的最内层循环的执行。如果您有一组嵌套循环，如果需要的话，您将需要为每个循环设置 break。\npackage main import \u0026#34;fmt\u0026#34; func main() { for outer := 0; outer \u0026lt; 5; outer++ { if outer == 3 { fmt.Println(\u0026#34;Breaking out of outer loop\u0026#34;) break // break here } fmt.Println(\u0026#34;The value of outer is\u0026#34;, outer) for inner := 0; inner \u0026lt; 5; inner++ { if inner == 2 { fmt.Println(\u0026#34;Breaking out of inner loop\u0026#34;) break // break here } fmt.Println(\u0026#34;The value of inner is\u0026#34;, inner) } } fmt.Println(\u0026#34;Exiting program\u0026#34;) } 在这个程序中，我们有两个循环。虽然两个循环都迭代 5 次，但每个循环都有一个带有 break 语句的 if 条件语句。outer 如果等于 3，外部循环将中断。如果 inner 值为 2 ，内部循环将中断。\n如果我们运行程序，可以看到输出：\nOutput The value of outer is 0 The value of inner is 0 The value of inner is 1 Breaking out of inner loop The value of outer is 1 The value of inner is 0 The value of inner is 1 Breaking out of inner loop The value of outer is 2 The value of inner is 0 The value of inner is 1 Breaking out of inner loop Breaking out of outer loop Exiting program 请注意，每次内循环中断时，外循环都不会中断。这是因为break 只会中断调用它的最内层循环。\n我们已经看到 break 是如何停止循环的。接下来，让我们看看 continue 如何继续循环的。\nContinue 语句 # 当您想要跳过循环的剩余部分并返回循环顶部继续新的迭代时，可以使用 continue 语句。\n与 break 语句一样，continue 语句通常与 if 条件语句一起使用。\n使用与前面的Break 语句部分相同的 for 循环程序，这里我们将使用 continue 语句而不是 break 语句：\npackage main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { if i == 5 { fmt.Println(\u0026#34;Continuing loop\u0026#34;) continue // break here } fmt.Println(\u0026#34;The value of i is\u0026#34;, i) } fmt.Println(\u0026#34;Exiting program\u0026#34;) } 使用 continue 语句而不是 break 语句的区别在于，当变量 i 等于 5 时，尽管出现中断，我们的代码仍将继续执行。让我们看看我们的输出：\nOutput The value of i is 0 The value of i is 1 The value of i is 2 The value of i is 3 The value of i is 4 Continuing loop The value of i is 6 The value of i is 7 The value of i is 8 The value of i is 9 Exiting program 在这里，我们看到 The value of i is 5 没有出现在输出中，但循环在该点之后继续打印数字 6-10 的行，然后结束循环。\n您可以使用 continue 语句来避免深度嵌套的条件代码，或者通过消除您想要拒绝的一些频繁发生的情况来优化循环。\ncontinue 语句能够让程序跳过循环中出现的某些情况，然后继续循环的其余部分。\n结论 # Go 中的 break and continue 语句将允许您在代码中更高效地使用 for 循环。\n"},{"id":26,"href":"/How-To-Code-in-Go/docs/27-How_To_Define_and_Call_Functions_in_Go/","title":"27 How to Define and Call Functions in Go","section":"Docs","content":" 如何在 Go 中定义并调用函数 # 介绍 # _函数_是一段一旦定义，就可以重用的代码。函数的作用在于可以通过将在整个程序中多次使用的代码分解为更小、更可理解的任务，从而使您的代码更易于理解。\nGo 附带了强大的标准库，其中包含许多预定义的函数。您可能已经熟悉了fmt包：\nfmt.Println() 会将对象打印到标准输出（最可能在您的终端）。 fmt.Printf() 允许您将输出格式化打印。 函数名称包括括号，并且可能包括参数。\n在本教程中，我们将介绍如何定义您自己的函数以在您的项目中使用。\n定义一个函数 # 让我们从经典的“Hello, World!”程序开始理解函数。\n我们将在一个文本编辑器中创建一个新的文本文件，然后调用程序 hello.go。然后，我们将在里面定义函数。\nGo 中使用 func 关键字来定义函数。然后是您选择的名称和一组括号，其中包含函数将采用的任何参数（它们可以为空）。函数代码行用大括号 {} 括起来。\n在这种情况下，我们将定义一个名为 hello() 的函数：\nfunc hello() {} 这就是用于创建函数的初始语句。\n基于此，我们将添加第二行来提供函数功能的说明。我们将打印 Hello, World! 到控制台：\nfunc hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 现在我们的函数已经完全定义好了，但是如果我们此时运行程序，什么都不会发生，因为我们没有调用函数。\n因此，在我们的 main() 代码块中，来调用 hello() 函数：\npackage main import \u0026#34;fmt\u0026#34; func main() { hello() } func hello() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 现在，让我们运行程序：\n$ go run hello.go 您将收到以下输出：\nOutput Hello, World! 请注意，我们还引入了一个名为 main() 的函数。main() 函数是一个特殊的函数，它告诉编译器程序应该从这里开始。对于 可执行 的任何程序（可以从命令行运行的程序），都需要一个 main() 函数。main() 函数只能在 main() 包 中出现一次，并且不接收和返回任何参数。在任何 Go 程序中程序执行都是这样的。根据以下示例：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;this is the main section of the program\u0026#34;) } 函数可以比我们定义的 hello() 函数更复杂。我们可以在函数中使用for循环、条件语句等。\n例如，以下函数使用条件语句检查 name 变量的输入是否包含元音，并使用 for 循环遍历 name 字符串中的字母。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { names() } func names() { fmt.Println(\u0026#34;Enter your name:\u0026#34;) var name string fmt.Scanln(\u0026amp;name) // Check whether name has a vowel for _, v := range strings.ToLower(name) { if v == \u0026#39;a\u0026#39; || v == \u0026#39;e\u0026#39; || v == \u0026#39;i\u0026#39; || v == \u0026#39;o\u0026#39; || v == \u0026#39;u\u0026#39; { fmt.Println(\u0026#34;Your name contains a vowel.\u0026#34;) return } } fmt.Println(\u0026#34;Your name does not contain a vowel.\u0026#34;) } 我们在这里定义的 names() 函数设置一个带有输入的变量 name，然后在一个 for 循环中设置一个条件语句。这显示了如何在函数定义中组织代码。但是，根据我们对程序的意图以及我们对代码的安排，我们可能希望将条件语句和循环定义为两个独立的函数。\n在程序中定义函数可使我们的代码更模块化和可重用，这样我们就可以调用相同的函数而无需重写它们。\n使用参数 # 到目前为止，我们已经研究了带有空括号且不带参数的函数，但我们是可以在函数定义中的括号内定义参数的。\n参数 是函数定义中的命名实体，指定函数可以接受的参数。在 Go 中，您必须为每个参数指定数据类型。\n让我们创建一个将单词重复指定次数的程序。它将接受一个 string 类型的 word 参数和一个用于重复单词的次数的 int 类型参数 reps。\npackage main import \u0026#34;fmt\u0026#34; func main() { repeat(\u0026#34;Sammy\u0026#34;, 5) } func repeat(word string, reps int) { for i := 0; i \u0026lt; reps; i++ { fmt.Print(word) } } 我们分别为 word 参数和 reps 参数传递了Sammy 和 5 值。这些值按照给定的顺序与每个参数相对应。repeat 函数有一个 for 循环，将循环参数 reps 指定的次数。对于每次循环，都会打印参数 word 的值。\n这是程序的输出：\nOutput SammySammySammySammySammy 如果你有一组参数都是相同的值，你可以不用每次指定类型。让我们创建一个小程序，它接受都是 int 值的参数 x, y, 和 z 这些。我们将创建一个函数，函数将打印他们的总和。下面我们将调用该函数并将数字传递给该函数。\npackage main import \u0026#34;fmt\u0026#34; func main() { addNumbers(1, 2, 3) } func addNumbers(x, y, z int) { a := x + y b := x + z c := y + z fmt.Println(a, b, c) } 当我们创建 addNumbers 的函数签名时，我们不需要每次都指定类型，而只需要在最后指定。\n我们将数字 1 传入参数 x，2 传入参数 y，3 传入参数 z。这些值按照给定的顺序与每个参数对应。\n该程序会根据我们传递参数的值进行以下数学运算：\na = 1 + 2 b = 1 + 3 c = 2 + 3 该函数会打印 a，b， c 的值。基于这个数学运算，我们期望 a 等于 3， b 等于 4，c 等于 5。让我们运行程序：\n$ go run add_numbers.go Output 3 4 5 当我们将 1、2 和 3 作为参数传递给 addNumbers() 函数时，我们会收到预期的输出。\n在函数定义中的参数通常是作为变量使用，当您运行方法时，会将参数传递给函数，并为它们赋值。\n返回值 # 您可以将参数值传递给函数，一个函数也可以产生值。\n函数可以通过 return 语句生成一个值，return 语句将退出函数并 可选地 将表达式传递回调用者。返回的数据类型必须是指定过的。\n到目前为止，我们在函数中使用了fmt.Println() 语句而不是 return 语句。让我们创建一个程序，返回一个变量。\n在一个名为 double.go 的新文本文件中，我们将创建一个将参数 x 加倍并返回变量 y 的程序。我们将 3 作为double() 函数的参数，然后打印 result 的值。\npackage main import \u0026#34;fmt\u0026#34; func main() { result := double(3) fmt.Println(result) } func double(x int) int { y := x * 2 return y } 我们可以运行程序并查看输出：\n$ go run double.go Output 6 整数 6 将作为输出返回，这正是所期望的 3 乘以 2的结果。\n如果函数指定了返回值，则必须在代码中提供返回值。否则，将收到编译错误。\n我们可以通过用 return 语句注释掉这一行来证明这一点：\npackage main import \u0026#34;fmt\u0026#34; func main() { result := double(3) fmt.Println(result) } func double(x int) int { y := x * 2 // return y } 现在，让我们再次运行程序：\n$ go run double.go Output ./double.go:13:1: missing return at end of function 如果不使用此处的 return 语句，程序将无法编译。\n函数在遇到 return 语句时立即退出，即使它们不在函数末尾：\npackage main import \u0026#34;fmt\u0026#34; func main() { loopFive() } func loopFive() { for i := 0; i \u0026lt; 25; i++ { fmt.Print(i) if i == 5 { // Stop function at i == 5 return } } fmt.Println(\u0026#34;This line will not execute.\u0026#34;) } 这里我们设置一个 for 循环，循环运行 25 次。但是，在 for 循环内部，我们有一个条件语句来检查 i 的值是否等于 5。如果等于，我们将 return 进行返回。因为我们在 loopFive 函数中，所以函数中的任何一个 return 都会退出函数。所以，我们永远不会到达该函数的最后一行来打印 This line will not execute.语句。\n在 for 循环内使用了 return 语句来结束函数，因此循环外的行将不会运行。相反，如果我们使用了break语句，那么此时只有循环会退出，最后 fmt.Println() 一行会被运行。\nreturn 语句能够退出一个函数，并且如果在函数签名中指定，则会返回一个值。\n返回多个值 # 一个函数可以指定多个返回值。让我们编写 repeat.go 程序并让它返回两个值。第一个返回值是得到的最终重复值，第二个返回值在参数 reps 小于等于 0 时会得到一个错误。\npackage main import \u0026#34;fmt\u0026#34; func main() { val, err := repeat(\u0026#34;Sammy\u0026#34;, -1) if err != nil { fmt.Println(err) return } fmt.Println(val) } func repeat(word string, reps int) (string, error) { if reps \u0026lt;= 0 { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;invalid value of %d provided for reps. value must be greater than 0.\u0026#34;, reps) } var value string for i := 0; i \u0026lt; reps; i++ { value = value + word } return value, nil } repeat 函数首先检查 reps 参数是否为有效值。任何不大于 0 的值都会导致错误。由于我们传入了 -1，因此该代码分支将执行。请注意，当我们从函数返回时，我们必须同时提供 string 和 error 的返回值。因为提供的参数导致了错误，我们将为第一个返回值传回一个空白字符串，为第二个返回值传回错误。\n在 main() 函数中，我们可以通过声明两个新变量来接收两个返回值，value 和 err。因为返回中可能有错误，我们想在继续程序之前检查是否收到错误。在这个例子中，我们确实收到了一个错误。我们打印出错误并 return 返回退出main() 函数以退出程序。\n如果没有错误，我们将打印出函数的返回值。\n注意： 最好只返回两个或三个值。此外，您应该始终将错误作为函数的最后一个返回值返回。\n运行程序将产生以下输出：\noutput invalid value of -1 provided for reps. value must be greater than 0. 在本节中，我们回顾了如何使用 return 语句从函数返回多个值。\n结论 # 函数是在程序中执行操作指令的代码块，有助于使我们的代码更好地可重用和模块化。\n要了解有关如何使您的代码更模块化的更多信息，您可以阅读我们关于如何在 Go 中编写包的指南。\n"},{"id":27,"href":"/How-To-Code-in-Go/docs/28-How_To_Use_Variadic_Functions_in_Go/","title":"28 How to Use Variadic Functions in Go","section":"Docs","content":" 如何在 Go 中使用可变参数函数 # 介绍 # 可变参数函数 是可以接受零个、一个或多个值作为单个参数的函数。虽然可变参数函数并不常见，但它们能够使您的代码更清晰、更具可读性。\n可变参数函数其实很常见。最常见的是fmt包中的 Println。\nfunc Println(a ...interface{}) (n int, err error) 参数前面带有一组省略号 ( ... )的函数被视为可变参数函数。省略号表示提供的参数可以是零个、一个或多个。对于fmt.Println包，它声明参数a是可变参数。\n让我们创建一个使用 fmt.Println 函数并传入零个、一个或多个值的程序：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println() fmt.Println(\u0026#34;one\u0026#34;) fmt.Println(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;) fmt.Println(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;) } 第一次调用 fmt.Println 时，我们不传递任何参数。第二次调用时，我们只传入一个参数，值为 one。 然后我们传递 one 和 two，最后是 one，two 和 three 三个值。\n让我们使用以下命令运行程序：\n$ go run print.go 我们将看到以下输出：\nOutput one one two one two three 输出的第一行为空。这是因为我们在第一次调用 fmt.Println 时没有传递任何参数。第二次打印了 one 。然后打印 one 和 two，最后打印 one，two 和 three。\n现在我们已经了解了如何调用可变参数函数，让我们看看如何定义自己的可变参数函数。\n定义可变参数函数 # 我们可以通过在参数前面使用省略号 ( ... ) 来定义可变参数函数。让我们创建一个程序，当人们的名字被发送到函数时会进行问候：\npackage main import \u0026#34;fmt\u0026#34; func main() { sayHello() sayHello(\u0026#34;Sammy\u0026#34;) sayHello(\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) } func sayHello(names ...string) { for _, n := range names { fmt.Printf(\u0026#34;Hello %s\\n\u0026#34;, n) } } 我们创建了一个 sayHello 函数，它只接受一个名为names，该参数是可变参数，因为我们在数据类型之前放置了一个省略号 (...)： ...string。这告诉 Go 这个函数可以接受零个、一个或多个参数。\nsayHello 函数将 names 参数作为 slice 接收。由于数据类型是 string，因此 names 可以将参数视为字符串切片 ( []string ) 。我们可以使用range运算符创建一个循环并遍历字符串切片。\n如果我们运行程序，我们将得到以下输出：\nOutput Hello Sammy Hello Sammy Hello Jessica Hello Drew Hello Jamie 请注意，我们第一次调用 sayHello 什么也没打印。这是因为可变参数是一个空的字符串切片。 由于我们会遍历切片，因此没有任何内容可以迭代，并且 fmt.Printf 永远不会被调用。\n让我们修改程序以检测接收到值的情况：\npackage main import \u0026#34;fmt\u0026#34; func main() { sayHello() sayHello(\u0026#34;Sammy\u0026#34;) sayHello(\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) } func sayHello(names ...string) { if len(names) == 0 { fmt.Println(\u0026#34;nobody to greet\u0026#34;) return } for _, n := range names { fmt.Printf(\u0026#34;Hello %s\\n\u0026#34;, n) } } 现在，通过使用if语句，如果没有传递任何值，则 names 长度将为 0，我们将打印出nobody to greet：\nOutput nobody to greet Hello Sammy Hello Sammy Hello Jessica Hello Drew Hello Jamie 使用可变参数可以使您的代码更具可读性。让我们创建一个函数，将单词通过指定的分隔符连接在一起。我们将首先创建没有可变参数函数的程序来展示它的读取方式：\npackage main import \u0026#34;fmt\u0026#34; func main() { var line string line = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;}) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;}) fmt.Println(line) } func join(del string, values []string) string { var line string for i, v := range values { line = line + v if i != len(values)-1 { line = line + del } } return line } 在这个程序中，我们将逗号 (,) 作为分隔符传递给 join 函数，再传递一个字符串切片。输出如下：\nOutput Sammy,Jessica,Drew,Jamie Sammy,Jessica Sammy 因为该函数将字符串切片作为 values 参数，所以当我们调用 join 函数时，我们必须将所有单词包装在一个切片中。这会使代码难以阅读。\n现在，让我们编写相同的函数，但我们将使用可变参数函数：\npackage main import \u0026#34;fmt\u0026#34; func main() { var line string line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;) fmt.Println(line) } func join(del string, values ...string) string { var line string for i, v := range values { line = line + v if i != len(values)-1 { line = line + del } } return line } 如果我们运行该程序，可以看到我们得到了与之前的程序相同的输出：\nOutput Sammy,Jessica,Drew,Jamie Sammy,Jessica Sammy 虽然这两个版本的 join 函数执行完全相同的操作，但可变参数函数的版本在调用时更容易阅读。\n可变参数顺序 # 一个函数中只能有一个可变参数，并且它必须是函数定义中的最后一个参数。将可变参数放在最后位置以外的任何顺序在函数定义会导致编译错误：\npackage main import \u0026#34;fmt\u0026#34; func main() { var line string line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;) fmt.Println(line) } func join(values ...string, del string) string { var line string for i, v := range values { line = line + v if i != len(values)-1 { line = line + del } } return line } 这次我们把 values 参数放在 join 函数的首位时，将导致以下编译错误：\nOutput ./join_error.go:18:11: syntax error: cannot use ... with non-final parameter values 定义任何可变参数函数时，只有最后一个参数可以是可变参数。\n分解参数 # 到目前为止，我们已经看到我们可以将零个、一个或多个值传递给可变参数函数。但是，有时我们有一个切片并且我们希望将它们发送到可变参数函数。\n让我们用上一节中的 join 函数尝试一下，看看会发生什么：\npackage main import \u0026#34;fmt\u0026#34; func main() { var line string names := []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;} line = join(\u0026#34;,\u0026#34;, names) fmt.Println(line) } func join(del string, values ...string) string { var line string for i, v := range values { line = line + v if i != len(values)-1 { line = line + del } } return line } 如果我们运行这个程序，我们会收到一个编译错误：\nOutput ./join-error.go:10:14: cannot use names (type []string) as type string in argument to join 即使可变参数函数将 values ...string 参数转换为字符串切片 []string，我们也不能将字符串切片作为参数传递。这是因为编译器需要的是字符串的离散参数。\n为了解决这个问题，我们可以通过在 切片 后面加上一组省略号 (...) 来分解切片，将其转换为离散参数，然后传递给可变参数函数：\npackage main import \u0026#34;fmt\u0026#34; func main() { var line string names := []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;} line = join(\u0026#34;,\u0026#34;, names...) fmt.Println(line) } func join(del string, values ...string) string { var line string for i, v := range values { line = line + v if i != len(values)-1 { line = line + del } } return line } 这一次，当我们调用 join 函数时，我们通过附加省略号 (...)来分解 names 切片。\n这样程序就会按照预期运行：\nOutput Sammy,Jessica,Drew,Jamie 要注意，我们仍然可以传递零个、一个或多个参数，以及我们分解的切片。以下是我们迄今为止看到的所有变体的代码：\npackage main import \u0026#34;fmt\u0026#34; func main() { var line string line = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}...) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;) fmt.Println(line) line = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;) fmt.Println(line) } func join(del string, values ...string) string { var line string for i, v := range values { line = line + v if i != len(values)-1 { line = line + del } } return line } Output Sammy,Jessica,Drew,Jamie Sammy,Jessica,Drew,Jamie Sammy,Jessica Sammy 现在，我们知道了如何将零个、一个或多个参数以及我们分解的切片传递给可变参数函数。\n结论 # 在本教程中，我们了解了可变参数函数如何使您的代码更简洁。虽然您并不总是需要使用它们，但您可能会发现它们很有用：\n如果你创建了一个临时切片，只是为了传递给函数。 当输入参数的数量未知或调用时会发生变化。 使您的代码更具可读性。 要了解有关创建和调用函数的更多信息，您可以阅读如何在 Go 中定义和调用函数。\n"},{"id":28,"href":"/How-To-Code-in-Go/docs/29-Understanding_defer_in_Go/","title":"29 Understanding Defer in Go","section":"Docs","content":" 了解 Go 中的 defer # 简介 # Go 有许多其他编程语言中常见的控制流关键字，如 if、switch、for 等。有一个关键词在大多数其他编程语言中都没有，那就是 defer ，虽然它不太常见，但你很快就会发现它在你的程序中是多么有用。\ndefer 语句的主要用途之一是清理资源，如打开的文件、网络连接和数据库句柄。当你的程序使用完这些资源后，关闭它们很重要，以避免耗尽程序的限制，并允许其他程序访问这些资源。defer 通过保持关闭文件/资源的调用与打开调用保持一致，使我们的代码更加简洁，不易出错。\n在这篇文章中，我们将学习如何正确使用 defer 语句来清理资源，以及使用 defer 时常犯的几个错误。\n什么是 defer 语句 # defer 语句将 defer 关键字后面的函数调用添加到一个栈中。当该语句所在的函数返回时，将执行堆栈中所有的函数调用。由于这些调用位于堆栈上，因此将按照后进先出的顺序进行调用。\n让我们看看 defer 是如何工作的，打印出一些文本：\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;Bye\u0026#34;) fmt.Println(\u0026#34;Hi\u0026#34;) } 在 main 函数中，我们有两条语句。第一条语句以 defer 关键字开始，后面是 print 语句，打印出 Bye。下一行打印出 Hi。\n如果我们运行该程序，我们将看到以下输出：\nHi Bye 请注意，Hi 被首先打印出来。这是因为以 defer 为前缀的语句直到该函数结束前，都不会被调用。\n让我们再看看这个程序，这次我们将添加一些注释来帮助说明正在发生的事情：\npackage main import \u0026#34;fmt\u0026#34; func main() { // defer statement is executed, and places // fmt.Println(\u0026#34;Bye\u0026#34;) on a list to be executed prior to the function returning defer fmt.Println(\u0026#34;Bye\u0026#34;) // The next line is executed immediately fmt.Println(\u0026#34;Hi\u0026#34;) // fmt.Println*(\u0026#34;Bye\u0026#34;) is now invoked, as we are at the end of the function scope } 理解 defer 的关键是，当 defer 语句被执行时，延迟函数的参数被立即评估。当 defer 执行时，它把后面的语句放在一个列表中，在函数返回之前被调用。\n虽然这段代码说明了 defer 的运行顺序，但这并不是编写 Go 程序时的典型使用方式。我们更可能使用 defer 来清理资源，例如文件句柄。接下来让我们看看如何做到这一点。\n使用 defer 来清理资源 # 使用 defer 来清理资源在 Go 中是非常常见的。让我们先看看一个将字符串写入文件的程序，但没有使用 defer 来处理资源清理的问题：\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil { log.Fatal(\u0026#34;failed to write file:\u0026#34;, err) } } func write(fileName string, text string) error { file, err := os.Create(fileName) if err != nil { return err } _, err = io.WriteString(file, text) if err != nil { return err } file.Close() return nil } 在这个程序中，有一个叫做 write 的函数，它将首先尝试创建一个文件。如果它有错误，它将返回错误并退出函数。接下来，它试图将字符串 This is a readme file 写到指定文件中。如果它收到一个错误，它将返回错误并退出该函数。然后，该函数将尝试关闭该文件并将资源释放回系统。最后，该函数返回 nil 以表示该函数的执行没有错误。\n虽然这段代码可以工作，但有一个细微的错误。如果对 io.WriteString 的调用失败，该函数将在没有关闭文件并将资源释放回系统的情况下返回。\n我们可以通过添加另一个 file.Close() 语句来解决这个问题，在没有 defer 的语言中，你可能会这样解决：\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil { log.Fatal(\u0026#34;failed to write file:\u0026#34;, err) } } func write(fileName string, text string) error { file, err := os.Create(fileName) if err != nil { return err } _, err = io.WriteString(file, text) if err != nil { file.Close() return err } file.Close() return nil } 现在，即使调用 io.WriteString 失败了，我们仍然会关闭该文件。虽然这是一个相对容易发现和修复的错误，但对于一个更复杂的函数来说，它可能会被遗漏。\n我们可以使用 defer 语句来确保在执行过程中无论采取何种分支，我们都会调用 Close() ，而不是增加对 file.Close() 的第二次调用。\n下面是使用 defer 关键字的版本：\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil { log.Fatal(\u0026#34;failed to write file:\u0026#34;, err) } } func write(fileName string, text string) error { file, err := os.Create(fileName) if err != nil { return err } defer file.Close() _, err = io.WriteString(file, text) if err != nil { return err } return nil } 这一次我们添加了这行代码，defer file.Close()。这告诉编译器，它应该在退出函数 write 之前执行 file.Close。\n现在我们已经确保，即使我们在未来添加更多的代码并创建另一个退出该函数的分支，我们也会一直清理并关闭该文件。\n然而，我们通过添加 defer 引入了另一个错误。我们不再检查可能从 Close 方法返回的潜在错误。这是因为当我们使用 defer 时，没有办法将任何返回值传回给我们的函数。\n在 Go 中，在不影响程序行为的情况下多次调用 Close() 被认为是一种安全和公认的做法。如果 Close() 要返回一个错误，它将在第一次被调用时返回。这使得我们可以在函数的成功执行路径中明确地调用它。\n让我们看看我们如何既能 defer 对 Close 的调用，又能在遇到错误时报告错误。\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil { log.Fatal(\u0026#34;failed to write file:\u0026#34;, err) } } func write(fileName string, text string) error { file, err := os.Create(fileName) if err != nil { return err } defer file.Close() _, err = io.WriteString(file, text) if err != nil { return err } return file.Close() } 这个程序中唯一的变化是最后一行，我们返回 file.Close()。如果对 Close 的调用导致错误，现在将按照预期返回给调用函数。请记住，我们的 defer file.Close() 语句也将在 return 语句之后运行。这意味着 file.Close() 有可能被调用两次。虽然这并不理想，但这是可以接受的做法，因为它不应该对你的程序产生任何副作用。\n然而，如果我们在函数的早期收到一个错误，例如当我们调用 WriteString 时，函数将返回该错误，并且也将尝试调用 file.Close，因为它被推迟了。尽管 file.Close 也可能（而且很可能）返回一个错误，但这不再是我们关心的事情，因为我们收到的错误更有可能告诉我们一开始就出了什么问题。\n到目前为止，我们已经看到我们如何使用一个 defer 来确保我们正确地清理我们的资源。接下来我们将看到如何使用多个 defer 语句来清理多个资源。\n多个 defer 语句 # 在一个函数中拥有多个 defer 语句是很正常的。让我们创建一个只有 defer 语句的程序，看看当我们引入多个 defer 时，会发生什么情况：\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;one\u0026#34;) defer fmt.Println(\u0026#34;two\u0026#34;) defer fmt.Println(\u0026#34;three\u0026#34;) } 如果我们运行该程序，我们将收到以下输出结果：\nthree two one 注意，顺序与我们调用 defer 语句的顺序相反。这是因为每个被调用的延迟语句都是堆叠在前一个语句之上的，然后在函数退出范围时反向调用（后进先出）。\n在一个函数中，你可以根据需要有尽可能多的 defer 调用，但重要的是要记住它们都将以相反的顺序被调用。\n现在我们了解了多个延迟的执行顺序，让我们看看如何使用多个延迟来清理多个资源。我们将创建一个程序，打开一个文件，向其写入内容，然后再次打开，将内容复制到另一个文件。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { if err := write(\u0026#34;sample.txt\u0026#34;, \u0026#34;This file contains some sample text.\u0026#34;); err != nil { log.Fatal(\u0026#34;failed to create file\u0026#34;) } if err := fileCopy(\u0026#34;sample.txt\u0026#34;, \u0026#34;sample-copy.txt\u0026#34;); err != nil { log.Fatal(\u0026#34;failed to copy file: %s\u0026#34;) } } func write(fileName string, text string) error { file, err := os.Create(fileName) if err != nil { return err } defer file.Close() _, err = io.WriteString(file, text) if err != nil { return err } return file.Close() } func fileCopy(source string, destination string) error { src, err := os.Open(source) if err != nil { return err } defer src.Close() dst, err := os.Create(destination) if err != nil { return err } defer dst.Close() n, err := io.Copy(dst, src) if err != nil { return err } fmt.Printf(\u0026#34;Copied %d bytes from %s to %s\\n\u0026#34;, n, source, destination) if err := src.Close(); err != nil { return err } return dst.Close() } 我们添加了一个新的函数，叫做 fileCopy。在这个函数中，我们首先打开我们要复制的源文件。我们检查我们是否收到了一个打开文件的错误。如果是的话，我们 return 错误并退出该函数。否则，我们 defer 关闭我们刚刚打开的源文件。\n接下来我们创建目标文件。再次，我们检查我们是否收到了创建文件的错误。如果是的话，我们 return 该错误并退出该函数。否则，我们也 defer 目标文件的 Close()。我们现在有两个 defer 函数，当函数退出其作用域时将被调用。\n现在我们已经打开了两个文件，我们将Copy() 数据从源文件到目标文件。如果成功的话，我们将尝试关闭两个文件。如果我们在试图关闭任何一个文件时收到错误，我们将 return 错误并退出函数作用域。\n注意，我们为每个文件明确地调用 Close()，尽管 defer 也将调用 Close()。这是为了确保如果关闭文件时出现错误，我们会报告这个错误。这也确保了如果因为任何原因函数提前退出，例如我们在两个文件之间复制失败，每个文件仍将尝试从延迟调用中正确关闭。\n总结 # 在这篇文章中，我们了解了 defer 语句，以及如何使用它来确保我们在程序中正确清理系统资源。正确地清理系统资源将使你的程序使用更少的内存，表现更好。要了解更多关于 defer 的使用，请阅读处理恐慌的文章，或者探索我们整个如何在 Go 中编码系列。\n"},{"id":29,"href":"/How-To-Code-in-Go/docs/30-Understanding_init_in_Go/","title":"30 Understanding Init in Go","section":"Docs","content":" 了解 Go 中的 init # 简介 # 在 Go 中，预定义的 init() 函数设置了一段代码，在你的包的任何其他部分之前运行。这段代码将在包被导入后立即执行，当你需要你的应用程序在一个特定的状态下初始化时，例如你有一个特定的配置或一组资源，你的应用程序需要用它来启动。它也可以在导入副作用时使用，这是一种通过导入特定包来设置程序状态的技术。这经常被用于 register 一个包和另一个包，以确保程序考虑任务的正确代码。\n尽管 init() 是一个有用的工具，但它有时会使代码难以阅读，因为难以找到的 init() 实例会大大影响代码的运行顺序。正因为如此，对于刚接触 Go 的开发者来说，了解这个函数的方方面面是非常重要的，这样他们在写代码时就能确保以可读的方式使用 init()。\n在本教程中，你将学习 init() 如何用于设置和初始化特定包的变量、一次性计算，以及注册一个包以便与另一个包一起使用。\n先决条件 # 对于本文中的一些例子，你将需要：\n按照 如何安装 Go 和设置本地编程环境设置的 Go 工作空间。本教程将使用以下文件结构： . ├── bin │ └── src └── github.com └── gopherguides 定义 init() # 只要你定义一个 init() 函数，Go 就会在该包的其他东西之前加载并运行它。为了证明这一点，本节将介绍如何定义一个 init() 函数，并展示对包的运行的影响。\n首先，让我们以下面这个没有 init() 函数的代码为例：\npackage main import \u0026#34;fmt\u0026#34; var weekday string func main() { fmt.Printf(\u0026#34;Today is %s\u0026#34;, weekday) } 在这个程序中，我们声明了一个全局变量，叫做 weekday。默认情况下，weekday 的值是一个空字符串。\n让我们运行这段代码：\ngo run main.go 因为 weekday 的值是空的，当我们运行程序时，我们将得到以下输出：\nToday is 我们可以通过引入一个 init() 函数，将 weekday 的值初始化为当前日期，来填补这个空白变量。在 main.go 中加入以下高亮行：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var weekday string func init() { weekday = time.Now().Weekday().String() } func main() { fmt.Printf(\u0026#34;Today is %s\u0026#34;, weekday) } 在这段代码中，我们导入并使用了 time 包来获取当前的星期（Now().Weekday().String()），然后使用 init() 用这个值来初始化 weekday。 现在当我们运行该程序时，它将打印出当前的工作日：\nToday is Monday 虽然这说明了 init() 是如何工作的，但 init() 更典型的使用情况是在导入软件包时使用它。当你在使用软件包之前需要在软件包中进行特定的设置任务时，这就很有用。为了证明这一点，让我们创建一个程序，该程序需要一个特定的初始化，以便包能够如期工作。\n导入时初始化软件包 # 首先，我们将写一些代码，从切片中选择一个随机的生物并打印出来。然而，我们不会在初始程序中使用 init()。这将更好地展示我们的问题，以及 init() 将如何解决我们的问题。\n在你的 src/github.com/gopherguides/ 目录中，用以下命令创建一个名为 creature 的文件夹。\nmkdir creature 在 creature 文件夹下，创建一个名为 creature.go 的文件：\nnano creature/creature.go 在这个文件中，添加以下内容：\npackage creature import ( \u0026#34;math/rand\u0026#34; ) var creatures = []string{\u0026#34;shark\u0026#34;, \u0026#34;jellyfish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;dolphin\u0026#34;} func Random() string { i := rand.Intn(len(creatures)) return creatures[i] } 这个文件定义了一个叫做 creatures 的变量，它有一组初始化为数值的海洋生物。它还有一个exported Random 函数，将从 creatures 变量中返回一个随机值。\n保存并退出这个文件。\n接下来，让我们创建一个 cmd 包，我们将用它来编写 main() 函数并调用 creature 包。\n在我们创建 creature 文件夹的同一文件层，用以下命令创建一个 cmd 文件夹：\nmkdir cmd 在 cmd 文件夹中，创建一个名为 main.go 的文件：\nnano cmd/main.go 在文件中添加以下内容：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gopherguides/creature\u0026#34; ) func main() { fmt.Println(creature.Random()) fmt.Println(creature.Random()) fmt.Println(creature.Random()) fmt.Println(creature.Random()) } 这里我们导入了 creature 包，然后在 main() 函数中，使用 creature.Random() 函数来检索一个随机生物并打印出来四次。\n保存并退出 main.go。\n我们现在已经写好了我们的整个程序。然而，在我们运行这个程序之前，我们还需要创建几个配置文件，以便我们的代码能够正常工作。Go 使用Go Modules来配置导入资源的软件包依赖性。这些模块是放置在你的包目录中的配置文件，告诉编译器从哪里导入包。虽然对模块的学习超出了本文的范围，但我们只需写几行配置就可以让这个例子在本地运行。\n在 cmd 目录下，创建一个名为 go.mod 的文件：\nnano cmd/go.mod 文件打开后，放入以下内容：\nmodule github.com/gopherguides/cmd replace github.com/gopherguides/creature =\u0026gt; ../creature 这个文件的第一行告诉编译器，我们创建的 cmd 包实际上是 github.com/gopherguides/cmd。第二行告诉编译器，github.com/gopherguides/creature可以在磁盘上的 .../creature 目录下找到。 保存并关闭该文件。接下来，在 creature 目录下创建一个 go.mod 文件。\nnano creature/go.mod 在文件中添加以下一行代码：\nmodule github.com/gopherguides/creature 这告诉编译器，我们创建的 creature 包实际上是 github.com/gopherguides/creature 包。没有这个，cmd 包就不知道从哪里导入这个包。 保存并退出该文件。\n现在你应该有以下的目录结构和文件布局：\n├── cmd │ ├── go.mod │ └── main.go └── creature ├── go.mod └── creature.go 现在我们已经完成了所有的配置，我们可以用下面的命令运行 main 程序：\ngo run cmd/main.go 这将输出：\njellyfish squid squid dolphin 当我们运行这个程序时，我们收到了四个数值并打印出来。如果我们多次运行这个程序，我们会注意到，我们总是得到相同的输出，而不是预期的随机结果。这是因为 rand 包创建了伪随机数，对于单一的初始状态会持续产生相同的输出。为了实现更多的随机数，我们可以用 seed 包，或者设置一个不断变化的源，这样每次运行程序时的初始状态都会不同。在 Go 中，通常使用当前时间作为 rand 包的种子。 由于我们想让 creature 包来处理随机功能，所以打开这个文件。\nnano creature/creature.go 在 creature.go 文件中添加以下高亮行：\npackage creature import ( \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) var creatures = []string{\u0026#34;shark\u0026#34;, \u0026#34;jellyfish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;dolphin\u0026#34;} func Random() string { rand.Seed(time.Now().UnixNano()) i := rand.Intn(len(creatures)) return creatures[i] } 在这段代码中，我们导入了 time 包，并使用当前时间作为 Seed() 的种子。保存并退出该文件。 现在，当我们运行该程序时，我们将得到一个随机的结果：\ngo run cmd/main.go jellyfish octopus shark jellyfish 如果你继续反复运行该程序，你将继续得到随机结果。然而，这还不是我们代码的理想实现，因为每次调用 creature.Random() 时，也会通过再次调用 rand.Seed(time.Now().UnixNano() 来重新播种 rand 包。如果内部时钟没有改变，重新播种会增加用相同初始值播种的机会，这将导致随机模式可能的重复，或者会因为让你的程序等待时钟改变而增加 CPU 处理时间。 为了解决这个问题，我们可以使用一个 init() 函数。让我们更新 creature.go 文件：\nnano creature/creature.go 添加以下几行代码：\npackage creature import ( \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) var creatures = []string{\u0026#34;shark\u0026#34;, \u0026#34;jellyfish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;dolphin\u0026#34;} func init() { rand.Seed(time.Now().UnixNano()) } func Random() string { i := rand.Intn(len(creatures)) return creatures[i] } 添加 init() 函数告诉编译器，当 creature 包被导入时，它应该运行一次 init() 函数，为随机数生成提供一个种子。这确保了我们不会超过必须的时间来运行代码。现在，如果我们运行该程序，我们将继续得到随机结果：\ngo run cmd/main.go dolphin squid dolphin octopus 在这一节中，我们已经看到使用 init() 可以确保在使用包之前进行适当的计算或初始化。接下来，我们将看到如何在一个包中使用多个 init() 语句。\n多个 init() 实例 # 与只能声明一次的 main() 函数不同，init() 函数可以在一个包中多次声明。然而，多个 init() 会使我们很难知道哪个函数比其他函数有优先权。在本节中，我们将展示如何保持对多个 init() 语句的控制。\n在大多数情况下，init()函数将按照你遇到它们的顺序执行。让我们以下面的代码为例：\nmain.go\npackage main import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;First init\u0026#34;) } func init() { fmt.Println(\u0026#34;Second init\u0026#34;) } func init() { fmt.Println(\u0026#34;Third init\u0026#34;) } func init() { fmt.Println(\u0026#34;Fourth init\u0026#34;) } func main() {} 如果我们用以下命令运行该程序：\ngo run main.go 我们将收到以下输出：\nFirst init Second init Third init Fourth init 注意，每个 init() 都是按照编译器遇到它的顺序来运行的。然而，要确定 init() 函数的调用顺序可能并不总是那么容易。 让我们看看一个更复杂的包结构，其中我们有多个文件，每个文件都有自己的 init() 函数声明。为了说明这一点，我们将创建一个程序，共享一个名为 message 的变量并将其打印出来。\n删除前面的 creature 和 cmd 目录及其内容，用下面的目录和文件结构取代它们：\n├── cmd │ ├── a.go │ ├── b.go │ └── main.go └── message └── message.go 现在我们来添加每个文件的内容。在 a.go 中，添加以下几行：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gopherguides/message\u0026#34; ) func init() { fmt.Println(\u0026#34;a -\u0026gt;\u0026#34;, message.Message) } 这个文件包含一个 init() 函数，打印出 message 包中 message.Message 的值。\n接下来，在 b.go 中添加以下内容：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gopherguides/message\u0026#34; ) func init() { message.Message = \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;b -\u0026gt;\u0026#34;, message.Message) } 在 b.go 中，我们有一个 init() 函数，将 message.Message 的值设置为 Hello 并打印出来。\n接下来，创建 main.go，看起来像下面这样：\npackage main func main() {} 这个文件什么也不做，但为程序的运行提供了一个入口点。\n最后，创建你的 message.go 文件，如下所示：\npackage message var Message string 我们的 message 包声明了导出的 Message 变量。\n要运行该程序，在 cmd 目录下执行以下命令：\ngo run *.go 因为我们在 cmd 文件夹中有多个 Go 文件组成 main 包，我们需要告诉编译器，cmd 文件夹中所有的 .go 文件都应该被编译。使用 *.go 告诉编译器加载 cmd 文件夹中所有以 .go 结尾的文件。如果我们发出 go run main.go 的命令，程序将无法编译，因为它看不到 a.go 和 b.go 文件中的代码。\n这将得到以下输出：\na -\u0026gt; b -\u0026gt; Hello 根据 Go 语言对包初始化的规范，当一个包中遇到多个文件时，会按字母顺序处理。正因为如此，我们第一次从 a.go 中打印出 message.Message 时，其值是空白的。在运行 b.go 的 init() 函数之前，该值没有被初始化。 如果我们把 a.go 的文件名改为 c.go，我们会得到一个不同的结果：\nb -\u0026gt; Hello a -\u0026gt; Hello 现在编译器先遇到了 b.go，因此，当遇到 c.go 中的 init() 函数时，message.Message 的值已经被初始化为 Hello。\n这种行为可能会在你的代码中产生一个可能的问题。在软件开发中，改变文件名是很常见的，由于 init() 的处理方式，改变文件名可能改变 init() 的处理顺序。这可能会产生改变你的程序输出的不良后果。为了确保可重复的初始化行为，我们鼓励构建系统以词法文件名的顺序向编译器展示属于同一软件包的多个文件。确保所有 init() 函数按顺序加载的一个方法是在一个文件中声明它们。这将防止即使文件名被改变，顺序也不会改变。\n除了确保你的 init() 函数的顺序不发生变化外，你还应该尽量避免使用全局变量来管理包中的状态，即在包中任何地方都可以访问的变量。在前面的程序中， message.Message 变量对整个包都是可用的，并保持着程序的状态。由于这种访问，init() 语句能够改变该变量并破坏你的程序的可预测性。为了避免这种情况，尽量在受控的空间内处理变量，在允许程序工作的同时，尽可能减少访问。\n我们已经看到，你可以在一个包中有多个 init() 声明。然而，这样做可能会产生不想要的效果，使你的程序难以阅读或预测。避免多个 init() 声明或将它们全部放在一个文件中，将确保当文件被移动或名称被改变时，你的程序的行为不会改变。\n接下来，我们将检查 init() 是如何被用来导入产生副作用的。\n使用 init() 的副作用 # 在 Go 中，有时导入一个包并不是为了它的内容，而是为了导入包后产生的副作用。这通常意味着在导入的代码中有一个 init() 语句，在其他代码之前执行，允许开发者操纵他们程序开始的状态。这种技术被称为导入的副作用。\n为副作用而导入的一个常见用例是在你的代码中注册功能，这让包知道你的程序需要使用哪部分代码。例如，在 image 包中，image.Decode 函数在执行前需要知道它要解码的图像格式（jpg，png，gif，等等）。你可以通过首先导入一个有 init() 语句副作用的特定程序来完成这个任务。\n假设你试图在一个.png 文件上使用 image.Decode，代码片段如下：\n. . . func decode(reader io.Reader) image.Rectangle { m, _, err := image.Decode(reader) if err != nil { log.Fatal(err) } return m.Bounds() } . . . 使用这段代码的程序仍然可以编译，但任何时候我们试图对 png 图像进行解码时，都会出现错误。\n为了解决这个问题，我们需要首先为 image.Decode 注册一个图像格式。幸运的是，image/png 包包含以下 init() 语句：\nfunc init() { image.RegisterFormat(\u0026#34;png\u0026#34;, pngHeader, Decode, DecodeConfig) } 因此，如果我们将 image/png 导入我们的解码片段，那么 image/png 中的 image.RegisterFormat() 函数将在我们任何代码之前运行：\n. . . import _ \u0026#34;image/png\u0026#34; . . . func decode(reader io.Reader) image.Rectangle { m, _, err := image.Decode(reader) if err != nil { log.Fatal(err) } return m.Bounds() } 这将设置状态并注册我们需要 image.Decode() 的 png 版本。这个注册将作为导入 image/png 的一个副作用发生。 你可能已经注意到了在image/png之前的空白标识符(_) 。 这是有必要的，因为 Go 不允许你导入那些在整个程序中不使用的包。通过包括空白标识符，导入本身的值被丢弃了，所以只有导入的副作用才会出现。这意味着，即使我们在代码中从未调用 image/png 包，我们仍然可以导入它的副作用。\n当你需要导入一个包的时候，知道它的副作用是很重要的。如果没有适当的注册，你的程序很可能会被编译，但在运行时却不能正常工作。标准库中的包会在其文档中声明需要这种类型的导入。如果你写了一个需要导入副作用的包，你也应该确保你所使用的 init() 语句是有文档的，这样导入你的包的用户就能正确使用它。\n总结 # 在本教程中，我们了解到 init() 函数是在你的包中的其他代码被加载之前加载的，它可以为一个包执行特定的任务，如初始化一个期望的状态。我们还了解到，编译器执行多个 init() 语句的顺序取决于编译器加载源文件的顺序。如果你想了解更多关于 init() 的信息，请查看官方的Golang 文档，或者阅读Go 社区中关于该函数的讨论。\n你可以通过我们的如何在 Go 中定义和调用函数文章阅读更多关于函数的信息，或者探索整个 Go 中如何编程系列。\n"},{"id":30,"href":"/How-To-Code-in-Go/docs/31-Customizing_Go_Binaries_with_Build_Tags/","title":"31 Customizing Go Binaries With Build Tags","section":"Docs","content":" 用构建标签定制 Go 二进制文件 # 简介 # 在 Go 中，构建标签 或 构建约束 是添加到一段代码中的标识符，它决定了该文件在 build 过程中何时应被包含在一个包中。这允许你从同一源代码中构建不同版本的 Go 应用程序，并以快速和有组织的方式在它们之间进行切换。许多开发者使用构建标签来改善构建跨平台兼容的应用程序的工作流程，例如需要修改代码以考虑不同操作系统之间的差异的程序。构建标签还可用于集成测试，允许你在集成代码和带有Mock 服务的代码之间快速切换，并用于应用程序内不同级别的功能集。\n让我们以不同的客户功能集的问题为例。在编写一些应用程序时，你可能想控制在二进制文件中包括哪些功能，例如一个提供免费、专业和企业级别的应用程序。当客户在这些应用程序中增加他们的订阅级别时，更多的功能将被解锁并可用。为了解决这个问题，你可以维护独立的项目，并试图通过使用 import 语句来保持它们的同步性。虽然这种方法可行，但随着时间的推移，它将变得乏味和容易出错。另一种方法是使用构建标签。\n在本文中，您将使用 Go 中的构建标签来生成不同的可执行二进制文件，这些文件提供了一个示例应用程序的免费、专业和企业功能集。每一个都有不同的功能集，其中免费版本是默认的。\n先决条件 # 要遵循本文的例子，你将需要：\n按照 如何安装 Go 和设置本地编程环境设置的 Go 工作区。 构建免费版本 # 让我们从构建应用程序的免费版本开始，因为当运行 go build 而没有任何构建标签时，它将是默认的。稍后，我们将使用构建标签来有选择地将其他部分添加到我们的程序中。\n在 src 目录下，用你的应用程序的名字创建一个文件夹。本教程将使用app：\nmkdir app 移动到这个文件夹中：\ncd app 接下来，在你选择的文本编辑器中建立一个新的文本文件，名为 main.go：\nnano main.go 现在，我们将定义该应用程序的免费版本。在以下内容中加入main.go：\npackage main import \u0026#34;fmt\u0026#34; var features = []string{ \u0026#34;Free Feature #1\u0026#34;, \u0026#34;Free Feature #2\u0026#34;, } func main() { for _, f := range features { fmt.Println(\u0026#34;\u0026gt;\u0026#34;, f) } } 在这个文件中，我们创建了一个程序，声明了一个名为 features 的切片，它容纳了两个字符串，代表我们免费版本的应用程序的特征。应用程序中的 main() 函数使用一个 for 循环 range 遍历 features 切片，并将所有可用的功能打印到屏幕上。\n保存并退出该文件。现在这个文件已经保存了，在文章的其余部分，我们将不再需要编辑它。相反，我们将使用构建标签来改变我们将从中构建的二进制文件的功能特性。\n构建和运行程序：\ngo build ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 该程序已经打印出我们的两个免费功能，完成了我们应用程序的免费版本。 到目前为止，你创建了一个具有非常基本功能集的应用程序。接下来，你将建立一种方法，在构建时向应用程序添加更多的功能。\n用 go build 添加专业功能 # 到目前为止，我们避免了对 main.go 的修改，模拟了一个常见的生产环境，在这个环境中，需要在不改变和可能破坏主代码的情况下增加代码。由于我们不能编辑 main.go 文件，我们需要使用另一种机制，使用构建标签将更多的功能注入到 features 切片中。\n让我们创建一个名为 pro.go 的新文件，该文件将使用 init() 函数将更多的特特性追加到 features 切片中：\nnano pro.go 一旦编辑器打开了该文件，添加以下几行：\npackage main func init() { features = append(features, \u0026#34;Pro Feature #1\u0026#34;, \u0026#34;Pro Feature #2\u0026#34;, ) } 在这段代码中，我们使用 init() 在我们应用程序的 main() 函数前运行代码，然后使用 append() 将专业功能添加到 features切片中。保存并退出该文件。\n编译并运行应用程序，使用 go build:\ngo build 由于现在我们的当前目录中有两个文件（ pro.go 和 main.go ），go build将从这两个文件创建一个二进制文件。执行这个二进制文件：\n./app 这将为你提供以下功能组合：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 该应用程序现在同时包括专业版和免费版的功能。然而，这并不可取：由于版本之间没有区别，免费版现在包括了本应只有专业版才有的功能。为了解决这个问题，你可以加入更多的代码来管理应用程序的不同层级，或者你可以使用构建标签来告诉 Go 工具链哪些.go文件需要构建，哪些需要忽略。让我们在下一步中添加构建标签。\n添加构建标签 # 你现在可以使用构建标签来区分你的应用程序的专业版本和免费版本。\n让我们先来看看构建标签是什么样子的：\n// +build tag_name 将这行代码作为软件包的第一行，并将 tag_name 替换为你的构建标签的名称，你将把这个软件包标记为可以选择性地包含在最终二进制文件中的代码。让我们来看看这个操作，在 pro.go 文件中添加一个构建标签，告诉 go build 命令忽略它，除非指定标签。在你的文本编辑器中打开该文件：\nnano pro.go 然后添加以下突出显示的一行：\n// +build pro package main func init() { features = append(features, \u0026#34;Pro Feature #1\u0026#34;, \u0026#34;Pro Feature #2\u0026#34;, ) } 在 pro.go 文件的顶部，我们添加了 // +build pro，后面是一个空白的换行。这个尾部的换行是必须的，否则 Go 会将其解释为一个注释。构建标签的声明也必须在 .go 文件的最顶端。任何东西，甚至是评论，都不能在构建标签之上。 +build 声明告诉 go build 命令，这不是一个注释，而是一个构建标签。第二部分是 pro 标签。通过在 pro.go 文件的顶部添加这个标签，go build 命令现在将只包括有 pro 标签的 pro.go 文件。\n编译并再次运行应用程序：\ngo build ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 由于 pro.go 文件需要有 pro 标签，所以该文件被忽略，应用程序在没有标签的情况下进行编译。 当运行 go build 命令时，我们可以使用 -tags 标志，通过添加标签本身作为参数，有条件地将代码纳入编译后的源代码中。让我们对 pro 标签这样做：\ngo build -tags pro 这将输出以下内容：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 现在，我们只有在使用 pro 构建标签构建应用程序时才能获得额外的功能。 如果只有两个版本，这很好，但当你加入更多标签时，事情就变得复杂了。为了在下一步添加我们应用程序的企业版，我们将使用多个构建标签，用布尔逻辑连接起来。\n构建标签布尔逻辑 # 当一个 Go 包中有多个构建标签时，这些标签会使用布尔逻辑相互作用。为了证明这一点，我们将同时使用 pro 标签和 enterprise 标签来添加我们应用程序的企业级。\n为了建立一个企业级二进制文件，我们将需要包括默认功能、专业级功能和一套新的企业级功能。首先，打开一个编辑器并创建一个新文件，enterprise.go，它将添加新的企业级功能：\nnano enterprise.go enterprise.go 的内容将看起来与 pro.go几乎相同，但将包含新的功能。在该文件中添加以下几行：\npackage main func init() { features = append(features, \u0026#34;Enterprise Feature #1\u0026#34;, \u0026#34;Enterprise Feature #2\u0026#34;, ) } 保存并退出该文件。\n目前 enterprise.go 文件没有任何构建标签，正如你在添加 pro.go 时了解到的，这意味着这些功能将在执行 go build 时被添加到免费版本中。对于 pro.go，你在文件的顶部添加了 // +build pro 和一个换行符，以告诉 go build 只有在使用 tags pro 时才应包含它。在这种情况下，你只需要一个构建标记就能达到目的。然而，当添加新的企业版功能时，你首先必须同时拥有专业版功能。\n让我们先在 enterprise.go 中添加对 pro 构建标签的支持。用你的文本编辑器打开该文件：\nnano enterprise.go 接下来，在 package main 声明前添加构建标签，并确保在构建标签后包含一个换行符：\n// +build pro package main func init() { features = append(features, \u0026#34;Enterprise Feature #1\u0026#34;, \u0026#34;Enterprise Feature #2\u0026#34;, ) } 保存并退出该文件。 编译并运行没有任何标签的应用程序：\ngo build ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 企业版的功能在免费版中不再显示。现在让我们添加 pro 构建标签，再次构建并运行该应用程序：\ngo build -tags pro ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Enterprise Feature #1 \u0026gt; Enterprise Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 这仍然不完全是我们需要的。现在，当我们试图构建专业版时，企业版的功能出现了。为了解决这个问题，我们需要使用另一个构建标签。但与 pro 标签不同的是，我们现在需要确保 pro 和 enterprise 功能都是可用的。 Go 构建系统通过允许在构建标签系统中使用一些基本的布尔逻辑来说明这种情况。\n让我们再次打开 enterprise.go:\nnano enterprise.go 在pro标签的同一行添加另一个构建标签，enterprise:\n// +build pro enterprise package main func init() { features = append(features, \u0026#34;Enterprise Feature #1\u0026#34;, \u0026#34;Enterprise Feature #2\u0026#34;, ) } 保存并关闭该文件。 现在让我们用新的 enterprise 构建标签来编译和运行该应用程序。\ngo build -tags enterprise ./app 这将得到以下信息：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Enterprise Feature #1 \u0026gt; Enterprise Feature #2 现在我们已经失去了专业功能。这是因为当我们在 .go 文件中的同一行放置多个构建标签时，go build 会将它们解释为使用 OR 逻辑。 加上 // +build pro enterprise一行，如果存在 pro 构建标签或 enterprise 构建标签，enterprise.go 文件将被构建。 我们需要正确设置构建标签，要求两个同时，并使用 AND 逻辑来代替。 如果我们不把这两个标签放在同一行，而是把它们放在不同的行上，那么 go build 将使用 AND 逻辑来解释这些标签。\n再次打开 enterprise.go，让我们把构建标签分成多行。\n// +build pro // +build enterprise package main func init() { features = append(features, \u0026#34;Enterprise Feature #1\u0026#34;, \u0026#34;Enterprise Feature #2\u0026#34;, ) } 现在用新的 enterprise 构建标签编译和运行应用程序：\ngo build -tags enterprise ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 仍然没有达到目的。因为 AND 语句需要两个元素都被认为是 true，我们需要同时使用 pro 和 enterprise 构建标签。 让我们再试一次：\ngo build -tags \u0026#34;enterprise pro\u0026#34; ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Enterprise Feature #1 \u0026gt; Enterprise Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 现在，我们的应用程序可以从同一个源树中以多种方式构建，并相应地解锁应用程序的功能。 在这个例子中，我们使用了一个新的 // +build 标签来表示 AND 逻辑，但也有其他方法可以用构建标签表示布尔逻辑。下表是构建标签的其他语法格式的一些例子，以及它们的布尔等价物：\n构建标签语法 构建标签示例 布尔声明 空格分隔的元素 // +build pro enterprise pro OR enterprise 逗号分隔的元素 // +build pro,enterprise pro AND enterprise 感叹号元素 // +build !pro NOT pro 总结 # 在本教程中，你使用构建标签来控制你的哪些代码被编译到二进制中。首先，你声明了构建标签并使用它们与 go build，然后你用布尔逻辑组合了多个标签。然后，你建立了一个程序，代表了免费版、专业版和企业版的不同功能集，显示了构建标签对项目的强大控制能力。\n如果你想了解更多关于构建标签的信息，请看一下 Golang 的相关文档，或者继续探索我们的如何在 Go 中编码系列。\n"},{"id":31,"href":"/How-To-Code-in-Go/docs/32-Understanding_Pointers_in_Go/","title":"32 Understanding Pointers in Go","section":"Docs","content":" 了解 Go 中的指针 # 简介 # 当你用 Go 编写软件时，你会编写函数和方法。你将数据作为 参数 传递给这些函数。有时，函数会需要一个数据的本地拷贝，你希望原始数据保持不变。例如，如果你是一家银行，你有一个函数可以根据用户选择的储蓄计划来显示他们的余额变化，你不想在客户选择计划之前改变他们的实际余额，而只想用它来做计算。这被称为 按值传递，因为你是在向函数发送变量的值，而不是变量本身。\n其他时候，你可能希望函数能够改变原始变量中的数据。例如，当银行客户向其账户存款时，你希望存款函数能够访问实际的余额，而不是一个副本。在这种情况下，你不需要向函数发送实际数据， 而只需要告诉函数数据在内存中的位置。一个叫做 指针 的数据类型持有数据的内存地址，但不是数据本身。内存地址告诉函数在哪里可以找到数据，而不是数据的值。你可以把指针传给函数而不是实际的数据，然后函数就可以在原地改变原始变量的值。这被称为 通过引用传递，因为变量的值并没有传递给函数，而是传递了它指向的位置。\n在这篇文章中，你将创建并使用指针来分享对一个变量的内存空间的访问。\n定义和使用指针 # 当你使用一个指向变量的指针时，有几个不同的语法元素你需要了解。第一个是与号（\u0026amp;）的使用。如果你在一个变量名称前面加一个与号，你就说明你想获得 地址，或者说是该变量的一个指针。第二个语法元素是使用星号（*）或 引用 操作符。当你声明一个指针变量时，你在变量名后面加上指针指向的变量类型，前面加一个*，像这样：\nvar myPointer *int32 = \u0026amp;someint 这将创建 myPointer 作为一个指向 int32 变量的指针，并以 someint 的地址初始化该指针。指针实际上并不包含一个 int32，而只是一个地址。\n让我们来看看一个指向 string 的指针。下面的代码既声明了一个字符串的值，又声明了一个指向字符串的指针：\npackage main import \u0026#34;fmt\u0026#34; func main() { var creature string = \u0026#34;shark\u0026#34; var pointer *string = \u0026amp;creature fmt.Println(\u0026#34;creature =\u0026#34;, creature) fmt.Println(\u0026#34;pointer =\u0026#34;, pointer) } 用以下命令运行该程序：\ngo run main.go 当你运行程序时，它将打印出变量的值，以及该变量的存储地址（指针地址）。内存地址是一个十六进制的数字，并不是为了让人看懂。在实践中，你可能永远不会输出内存地址来查看它。我们给你看是为了说明问题。因为每个程序运行时都是在自己的内存空间中创建的，所以每次运行时指针的值都会不同，也会与下面显示的输出不同：\ncreature = shark pointer = 0xc0000721e0 我们定义的第一个变量名为 creature，并将其设置为一个 string，其值为 shark 。然后我们创建了另一个名为 pointer 的变量。这一次，我们将 pointer 变量的值设置为 creature 变量的地址。我们通过使用与号（\u0026amp;）符号将一个值的地址存储在一个变量中。这意味着 pointer 变量存储的是 creature 变量的 地址 ，而不是实际值。 这就是为什么当我们打印出 pointer 的值时，我们收到的值是 0xc0000721e0 ，这是 creature 变量目前在计算机内存中的地址。\n如果你想打印出 pointer 变量所指向的变量的值，你需要 解引用 该变量。下面的代码使用 * 操作符来解除对 pointer 变量的引用并检索其值。\npackage main import \u0026#34;fmt\u0026#34; func main() { var creature string = \u0026#34;shark\u0026#34; var pointer *string = \u0026amp;creature fmt.Println(\u0026#34;creature =\u0026#34;, creature) fmt.Println(\u0026#34;pointer =\u0026#34;, pointer) fmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer) } 如果你运行这段代码，你会看到以下输出：\ncreature = shark pointer = 0xc000010200 *pointer = shark 我们添加的最后一行现在解除了对 pointer 变量的引用，并打印出了存储在该地址的值。 如果你想修改存储在 pointer 变量位置的值，你也可以使用解除引用操作：\npackage main import \u0026#34;fmt\u0026#34; func main() { var creature string = \u0026#34;shark\u0026#34; var pointer *string = \u0026amp;creature fmt.Println(\u0026#34;creature =\u0026#34;, creature) fmt.Println(\u0026#34;pointer =\u0026#34;, pointer) fmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer) *pointer = \u0026#34;jellyfish\u0026#34; fmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer) } 运行这段代码可以看到输出：\ncreature = shark pointer = 0xc000094040 *pointer = shark *pointer = jellyfish 我们通过在变量名称前使用星号（*）来设置 pointer 变量所指的值，然后提供一个 jellyfish 的新值。正如你所看到的，当我们打印解引用的值时，它现在被设置为 jellyfish 。 你可能没有意识到，但实际上我们也改变了 creature 变量的值。这是因为 pointer 变量实际上是指向 creature 变量的地址。这意味着如果我们改变了 pointer 变量所指向的值，同时我们也会改变 creature 变量的值。\npackage main import \u0026#34;fmt\u0026#34; func main() { var creature string = \u0026#34;shark\u0026#34; var pointer *string = \u0026amp;creature fmt.Println(\u0026#34;creature =\u0026#34;, creature) fmt.Println(\u0026#34;pointer =\u0026#34;, pointer) fmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer) *pointer = \u0026#34;jellyfish\u0026#34; fmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer) fmt.Println(\u0026#34;creature =\u0026#34;, creature) } 输出看起来像这样：\ncreature = shark pointer = 0xc000010200 *pointer = shark *pointer = jellyfish creature = jellyfish 虽然这段代码说明了指针的工作原理，但这并不是你在 Go 中使用指针的典型方式。更常见的是在定义函数参数和返回值时使用它们，或者在定义自定义类型的方法时使用它们。让我们看看如何在函数中使用指针来共享对一个变量的访问。 同样，请记住，我们正在打印 pointer 的值，是为了说明它是一个指针。在实践中，你不会使用指针的值，除了引用底层的值来检索或更新该值之外。\n函数指针接收器 # 当你写一个函数时，你可以定义参数，以 值 或 引用 的方式传递。通过 值 传递意味着该值的副本被发送到函数中，并且在该函数中对该参数的任何改变 只 在该函数中影响该变量，而不是从哪里传递。然而，如果你通过 引用 传递，意味着你传递了一个指向该参数的指针，你可以在函数中改变该值，也可以改变传递进来的原始变量的值。你可以在我们的如何在 Go 中定义和调用函数中阅读更多关于如何定义函数的信息。\n什么时候传递一个指针，什么时候发送一个值，都取决于你是否希望这个值发生变化。如果你不希望数值改变，就把它作为一个值来发送。如果你希望你传递给你的变量的函数能够改变它，那么你就把它作为一个指针传递。\n为了看到区别，让我们先看看一个通过 值 传递参数的函数：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Species string } func main() { var creature Creature = Creature{Species: \u0026#34;shark\u0026#34;} fmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) changeCreature(creature) fmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) } func changeCreature(creature Creature) { creature.Species = \u0026#34;jellyfish\u0026#34; fmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 输出看起来像这样：\n1) {Species:shark} 2) {Species:jellyfish} 3) {Species:shark} 首先我们创建了一个名为 Creature 的自定义类型。它有一个名为 Species 的字段，它是一个字符串。在 main 函数中，我们创建了一个名为Creature 的新类型实例，并将Species 字段设置为shark 。然后我们打印出变量，以显示存储在 creature 变量中的当前值。 接下来，我们调用 changeCreature，并传入 creature 变量的副本。\nchangeCreature 被定义为接受一个名为 creature 的参数，并且它是我们之前定义的 Creature 类型的函数。然后我们将Species 字段的值改为 jellyfish 并打印出来。注意在 changeCreature 函数中，Species 的值现在是 jellyfish，并且打印出 2) {Species:jellyfish}。这是因为我们被允许在我们的函数范围内改变这个值。\n然而，当 main 函数的最后一行打印出 creature 的值时，Species 的值仍然是 shark 。值没有变化的原因是我们通过 值 传递变量。这意味着在内存中创建了一个值的副本，并传递给 changeCreature 函数。这允许我们有一个函数，可以根据需要对传入的任何参数进行修改，但不会影响函数之外的任何变量。\n接下来，让我们改变 changeCreature 函数，使其通过 引用 接受一个参数。我们可以通过使用星号（*）操作符将类型从 Creature 改为指针来做到这一点。我们现在传递的不是一个 Creature，而是一个指向 Creature 的指针，或者是一个 *Creature。在前面的例子中，creature 是一个 struct，它的 Species 值为 shark。*creature 是一个指针，不是一个结构体，所以它的值是一个内存位置，这就是我们传递给 changeCreature() 真正的东西。\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Species string } func main() { var creature Creature = Creature{Species: \u0026#34;shark\u0026#34;} fmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) changeCreature(\u0026amp;creature) fmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) } func changeCreature(creature *Creature) { creature.Species = \u0026#34;jellyfish\u0026#34; fmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 运行这段代码可以看到以下输出：\n1) {Species:shark} 2) \u0026amp;{Species:jellyfish} 3) {Species:jellyfish} 注意，现在当我们在 changeCreature 函数中把 Species 的值改为 jellyfish 时，它也改变了 main 函数中定义的原始值。这是因为我们通过 引用 传递了 creature 变量，它允许访问内存里的原始值并可以根据需要改变它。 因此，如果你想让一个函数能够改变一个值，你需要通过引用来传递它。要通过引用传递，你就需要传递变量的指针，而不是变量本身。\n然而，有时你可能没有为一个指针定义一个实际的值。在这些情况下，有可能在程序中出现恐慌。让我们来看看这种情况是如何发生的，以及如何对这种潜在的问题进行规划。\n空指针 # Go 中的所有变量都有一个零值。即使对指针来说也是如此。如果你声明了一个类型的指针，但是没有赋值，那么零值将是 nil。nil 是一种表示变量 \u0026ldquo;没有被初始化\u0026rdquo; 的方式。\n在下面的程序中，我们定义了一个指向 Creature 类型的指针，但是我们从来没有实例化过 Creature 的实际实例，也没有将它的地址分配给 creature 指针变量。该值将是 nil，因此我们不能引用任何定义在 Creature 类型上的字段或方法：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Species string } func main() { var creature *Creature fmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) changeCreature(creature) fmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) } func changeCreature(creature *Creature) { creature.Species = \u0026#34;jellyfish\u0026#34; fmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 输出看起来像这样：\n1) \u0026lt;nil\u0026gt; panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x8 pc=0x109ac86] goroutine 1 [running]: main.changeCreature(0x0) /Users/corylanou/projects/learn/src/github.com/gopherguides/learn/_training/digital-ocean/pointers/src/nil.go:18 +0x26 main.main() /Users/corylanou/projects/learn/src/github.com/gopherguides/learn/_training/digital-ocean/pointers/src/nil.go:13 +0x98 exit status 2 当我们运行程序时，它打印出了 creature 变量的值，该值是 \u0026lt;nil\u0026gt;。然后我们调用 changeCreature 函数，当该函数试图设置 Species 字段的值时，它 panics(恐慌) 了。这是因为实际上没有创建 creature 变量的实例。正因为如此，程序没有地方可以实际存储这个值，所以程序就恐慌了。 在 Go 中很常见的是，如果你以指针的形式接收一个参数，在对它进行任何操作之前，你要检查它是否为 nil，以防止程序恐慌。\n这是检查 nil 的一种常见方法：\nif someVariable == nil { // print an error or return from the method or fuction } 实际上，你想确保你没有一个 nil 指针被传入你的函数或方法。如果有的话，你可能只想返回，或者返回一个错误，以表明一个无效的参数被传递到函数或方法中。下面的代码演示了对 nil 的检查：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Species string } func main() { var creature *Creature fmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) changeCreature(creature) fmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) } func changeCreature(creature *Creature) { if creature == nil { fmt.Println(\u0026#34;creature is nil\u0026#34;) return } creature.Species = \u0026#34;jellyfish\u0026#34; fmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 我们在 changeCreature 中添加了一个检查，看 creature 参数的值是否为 nil。如果是，我们打印出 \u0026ldquo;creature is nil\u0026rdquo;，并返回函数。否则，我们继续并改变 Species 字段的值。如果我们运行该程序，我们现在将得到以下输出：\n1) \u0026lt;nil\u0026gt; creature is nil 3) \u0026lt;nil\u0026gt; 请注意，虽然我们仍然为 creature 变量设置了 nil 值，但我们不再恐慌，因为我们正在检查这种情况。 最后，如果我们创建一个 Creature 类型的实例，并将其赋值给 creature 变量，程序现在将按照预期改变值：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Species string } func main() { var creature *Creature creature = \u0026amp;Creature{Species: \u0026#34;shark\u0026#34;} fmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) changeCreature(creature) fmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) } func changeCreature(creature *Creature) { if creature == nil { fmt.Println(\u0026#34;creature is nil\u0026#34;) return } creature.Species = \u0026#34;jellyfish\u0026#34; fmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 现在我们有了一个 Creature 类型的实例，程序将运行，我们将得到以下预期输出：\n1) \u0026amp;{Species:shark} 2) \u0026amp;{Species:jellyfish} 3) \u0026amp;{Species:jellyfish} 当你在使用指针时，程序有可能会出现恐慌。为了避免恐慌，你应该在试图访问任何字段或定义在其上的方法之前，检查一个指针值是否为 nil。 接下来，让我们看看使用指针和值是如何影响在一个类型上定义方法的。\n方法指针接收器 # Go 中的 接收器 是指在方法声明中定义的参数。看一下下面的代码：\ntype Creature struct { Species string } func (c Creature) String() string { return c.Species } 这个方法的接收器是 c Creature。它说明 c 的实例属于 Creature 类型，你将通过该实例变量引用该类型。\n方法跟函数一样，也是根据你送入的参数是指针还是值而有不同的行为。最大的区别是，如果你用一个值接收器定义一个方法，你就不能对该方法所定义的那个类型的实例进行修改。\n有的时候，你希望你的方法能够更新你所使用的变量的实例。为了实现这一点，你会想让接收器成为一个指针。\n让我们给我们的 Creature 类型添加一个 Reset 方法，将 Species字段设置为一个空字符串：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Species string } func (c Creature) Reset() { c.Species = \u0026#34;\u0026#34; } func main() { var creature Creature = Creature{Species: \u0026#34;shark\u0026#34;} fmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) creature.Reset() fmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 如果我们运行该程序，我们将得到以下输出：\n1) {Species:shark} 2) {Species:shark} 注意到即使在 Reset 方法中我们将 Species 的值设置为空字符串，当我们在 main 函数中打印出 creature 变量的值时，该值仍然被设置为 shark 。这是因为我们定义的 Reset 方法有一个 值 接收器。这意味着该方法只能访问 creature 变量的 副本。 如果我们想在方法中修改 creature 变量的实例，我们需要将它们定义为有一个 指针 接收器：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Species string } func (c *Creature) Reset() { c.Species = \u0026#34;\u0026#34; } func main() { var creature Creature = Creature{Species: \u0026#34;shark\u0026#34;} fmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) creature.Reset() fmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 注意，我们现在在定义 Reset 方法时，在 Creature 类型前面添加了一个星号（*）。这意味着传递给 Reset 方法的 Creature 实例现在是一个指针，因此当我们进行修改时，将影响到该变量的原始实例。\n1) {Species:shark} 2) {Species:} 现在 Reset 方法已经改变了 Species 字段的值。\n总结 # 将一个函数或方法定义为通过 值 或通过 引用，将影响你的程序的哪些部分能够对其他部分进行修改。控制该变量何时能被改变，将使你能写出更健壮和可预测的软件。现在你已经了解了指针，你也可以看到它们是如何在接口中使用的。\n"},{"id":32,"href":"/How-To-Code-in-Go/docs/33-Defining_Structs_in_Go/","title":"33 Defining Structs in Go","section":"Docs","content":" 在 Go 中定义结构体 # 简介 # 围绕具体的细节建立抽象，是编程语言能给开发者的最大工具。结构体使我们可以谈论 Address 而不是通过描述 Street, City, 或 PostalCode 字符串来进行推断。它们作为文档的一个自然纽带，致力于告诉未来的开发者（包括我们自己）哪些数据对我们的 Go 程序是重要的，以及未来的代码应该如何正确使用这些数据。结构体可以用几种不同的方式来定义和使用。在本教程中，我们将会逐一看下这些技术。\n定义结构体 # 结构体的工作方式类似于你可能正在使用的纸质表格，例如用来报税的表单。纸质表格可能有文本信息的字段，比如你的名字和姓氏。除了文本字段外，表单可能还有复选框来表示布尔值，如“已婚”或“单身”，或表示出生日期的日期字段。同样，结构体将不同数据收集在一起，并通过不同的字段名组织它们。当你用一个新的结构体初始化一个变量时，就好像你影印了一张表格并准备填写。\n要创建一个新的结构体，你必须首先给 Go 定义一个蓝图来描述结构体所包含的字段。这个结构定义通常以关键字 type 开始，紧跟着结构体的名称。随后，使用 struct 关键字，后面跟着一对大括号 {}，在这里声明结构体将包含的字段。一旦你定义了结构体，就可以声明使用该结构体定义的变量。本例定义了一个结构并使用它。\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Name string } func main() { c := Creature{ Name: \u0026#34;Sammy the Shark\u0026#34;, } fmt.Println(c.Name) } 当你运行这段代码时，会看到这样的输出：\noutput Sammy the Shark 在这个例子中，我们首先定义了一个 Creature 结构体，包含一个字符串类型的 Name 字段。在 main 方法中，我们通过在 Creature 类型名称后添加一对大括号来创建一个 Creature 实例，然后为该实例的字段设定值。c 实例的 Name 字段将被设置为 “Sammy the Shark”。在 fmt.Println 方法的调用中，我们通过在实例变量后加点号与我们想访问的字段名来检索实例的字段值。例如，c.Name 在本例中返回 Name 字段值。\n当你声明一个新的结构体实例时，通常会列举字段名和它们的值，就像上一个例子。此外，如果每个字段的值都会在结构的实例化过程中提供，也可以省略字段名，如本例。\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Name string Type string } func main() { c := Creature{\u0026#34;Sammy\u0026#34;, \u0026#34;Shark\u0026#34;} fmt.Println(c.Name, \u0026#34;the\u0026#34;, c.Type) } 输出结果与上一个例子相同：\noutput Sammy the Shark 我们为 Creature 增加了一个额外的字段，用字符串类型来追踪生物 Type 。当在 main 方法中实例化 Creature 时，我们选择使用较短的实例化方式，即按顺序为每个字段提供值，并省略其字段名。在 Creature{\u0026quot;Sammy\u0026quot;, \u0026quot;Shark\u0026quot;} 的声明中，因为 Name 在类型声明中首先出现，然后为Type，所以Name 字段取值为 Sammy，Type 字段取值为 Shark。\n这种较短的声明方式有一些缺点，导致 Go 社区在大多数情况下都倾向于采用较长的方式。使用简短声明时，你必须为结构体中的每个字段提供值，而不能省略你并不关心的字段。这很快就会导致包含很多字段的结构体短声明变得混乱。出于这个原因，简短声明通常用于字段少的结构体。\n到目前为止，例子中的字段名都是以大写字母开头。这并不仅是风格上的偏好，而是在字段名中使用大写或小写字母会影响到你的字段名是否能被其他包中运行的代码所访问。\n结构体字段导出 # 结构体的字段遵循与 Go 编程语言中其他标识符相同的导出规则。如果字段名以大写字母开头，则该字段可被定义该结构体的包之外的代码读写。如果字段以小写字母开头，则只有该结构体包内的代码才可以读写该字段。这个例子定义了可导出和不可导出的字段：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Name string Type string password string } func main() { c := Creature{ Name: \u0026#34;Sammy\u0026#34;, Type: \u0026#34;Shark\u0026#34;, password: \u0026#34;secret\u0026#34;, } fmt.Println(c.Name, \u0026#34;the\u0026#34;, c.Type) fmt.Println(\u0026#34;Password is\u0026#34;, c.password) } 这将输出：\noutput Sammy the Shark Password is secret 我们在之前的例子中添加了一个额外的字段，secret。secret 是一个未导出的字符串类型字段，这意味着任何试图实例化 Creature 的其他包将无法访问或设置其 secret 字段。在同一个包内，我们能够访问这些字段，正如本例所做的那样。由于 main 方法也在 main 包中，它能够引用 c.password 并检索所存储的值。在结构中拥有未导出的字段是很常见的，对它们的访问由导出的方法来进行配置。\n内联结构体 # 除了定义一个新的类型来表示一个结构体外，你还可以定义一个内联结构。在为结构类型想一个新的名称会造成浪费的情况下，这些即时创建的结构定义(不需要命名的 struct)会非常有用。例如，测试经常使用一个结构体来定义构成一个特定测试案例的所有参数。当该结构只会在一个地方使用时，想出 CreatureNamePrintingTestCase 这样的新名字会很麻烦。\n内联结构定义出现在变量赋值的右侧。你必须立即使用一对额外的大括号进行实例化并为定义的每个字段赋值。下面的例子显示了一个内联结构定义：\npackage main import \u0026#34;fmt\u0026#34; func main() { c := struct { Name string Type string }{ Name: \u0026#34;Sammy\u0026#34;, Type: \u0026#34;Shark\u0026#34;, } fmt.Println(c.Name, \u0026#34;the\u0026#34;, c.Type) } 这个例子的输出结果将是：\noutput Sammy the Shark 本例没有使用 type 关键字定义一个新的类型来描述我们的结构体，而是通过将 struct 定义放在短赋值运算符 := 之后定义一个内联结构。我们像之前的例子一样定义了结构体的字段，但是必须立即提供一对大括号和每个字段将赋的值。现在我们可以和以前完全一样使用这个结构体，用点符号来访问字段名。内联结构最常用于测试过程中声明，因为经常会需要用到一次性结构体来定义包含特定测试案例的数据和预期测试结果。\n总结 # 结构体是开发者为组织信息而定义的各种各样的数据的集合。大多数程序都要处理大量的数据，如果没有结构体，就很难记住哪些 string 或 int 变量相关，哪些无关。下一次，当你发现自己在组织一些变量时，问问自己，也许这些变量用 struct 来分组会更好。这些变量可能一直都在描述更高层级的概念。\n"},{"id":33,"href":"/How-To-Code-in-Go/docs/34-Defining_Methods_in_Go/","title":"34 Defining Methods in Go","section":"Docs","content":" 在 Go 中定义方法 # 简介 # 函数允许你将逻辑组织成可重复的程序，每次运行时可以使用不同的参数。在定义函数的过程中，你常常会发现，可能会有多个函数每次对同一块数据进行操作。Go 可以识别这种模式，并允许您定义特殊的函数，称为方法，其目的是对某些特定类型（称为接收器）的实例进行操作。将方法添加到类型中，不仅可以传达数据是什么，还可以传达如何使用这些数据。\n定义一个方法 # 定义一个方法的语法与定义一个函数的语法很相似。唯一的区别是在 func 关键字后面增加了一个额外的参数，用于指定方法的接收器。接收器是你希望定义的方法的类型声明。下面的例子为一个结构体类型定义了一个方法。\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Name string Greeting string } func (c Creature) Greet() { fmt.Printf(\u0026#34;%s says %s\u0026#34;, c.Name, c.Greeting) } func main() { sammy := Creature{ Name: \u0026#34;Sammy\u0026#34;, Greeting: \u0026#34;Hello!\u0026#34;, } Creature.Greet(sammy) } 如果你运行这段代码，输出将是：\nOutput Sammy says Hello! 我们创建了一个名为 Creature 的结构，包含字符串类型的 Name 和 Greeting 字段。这个 Creature 结构体有一个定义的方法，即 Greet。在接收器声明中，我们将 Creature 的实例分配给变量 c，以便我们在 fmt.Printf 中打印问候信息时可以引用 Creature 字段。\n在其他编程语言中，方法调用的接收器通常用一个关键字来表示（例如：this 或 self）。Go 认为接收器和其他变量一样，是一个变量，所以你可以自由地命名。社区对这个参数的首选风格是接收器类型小写版本的第一个字符。在这个例子中，我们使用了 c，因为接收器的类型是 Creature。\n在 main 方法中，我们创建了一个 Creature 实例，并为其 Name 和 Greeting 字段进行赋值。我们在这里调用了 Greet 方法，用 . 连接类型名和方法名，并提供 Creature 实例作为第一个参数。\nGo 提供了另一种更简洁的方式来调用结构体实例的方法，如本例所示：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Name string Greeting string } func (c Creature) Greet() { fmt.Printf(\u0026#34;%s says %s\u0026#34;, c.Name, c.Greeting) } func main() { sammy := Creature{ Name: \u0026#34;Sammy\u0026#34;, Greeting: \u0026#34;Hello!\u0026#34;, } sammy.Greet() } 如果你运行这个，输出将与前面的例子相同：\nOutput Sammy says Hello! 这个例子与前一个例子相同，但这次我们使用点号来调用 Greet 方法，使用存储在 sammy 变量中的 Creature 作为接收器，这是对第一个例子中的方法调用的简化。标准库和 Go 社区更喜欢这种风格，以至于你很少看到前面所示的方法调用风格。\n下一个例子展示了使用点号比较普遍的一个原因：\npackage main import \u0026#34;fmt\u0026#34; type Creature struct { Name string Greeting string } func (c Creature) Greet() Creature { fmt.Printf(\u0026#34;%s says %s!\\n\u0026#34;, c.Name, c.Greeting) return c } func (c Creature) SayGoodbye(name string) { fmt.Println(\u0026#34;Farewell\u0026#34;, name, \u0026#34;!\u0026#34;) } func main() { sammy := Creature{ Name: \u0026#34;Sammy\u0026#34;, Greeting: \u0026#34;Hello!\u0026#34;, } sammy.Greet().SayGoodbye(\u0026#34;gophers\u0026#34;) Creature.SayGoodbye(Creature.Greet(sammy), \u0026#34;gophers\u0026#34;) } 如果你运行这段代码，输出看起来像这样：\nOutput Sammy says Hello!! Farewell gophers ! Sammy says Hello!! Farewell gophers ! 我们修改了前面的例子，引入了另一个名为 SayGoodbye 的方法，并将 Greet 改为返回一个 Creature，这样我们就可以对该实例调用更多的方法。在 main 方法中，我们首先使用点号调用 sammy 变量上的 Greet 和 SayGoodbye 方法，然后使用函数式调用方式。\n两种风格输出的结果相同，但使用点号的例子更易读。点号调用链路还会告诉我们方法被调用的顺序，而函数式则颠倒了这个顺序。在 SayGoodbye 的调用中增加了一个参数，进一步模糊了方法调用的顺序。点号调用的清晰性是 Go 中调用方法的首选风格，无论是在标准库中还是在整个 Go 生态的第三方包中都是如此。\n相对于定义对某些值进行操作的方法，为类型定义方法对 Go 编程语言还有其他特殊意义，方法是接口背后的核心概念。\n接口 # 当你在 Go 中为任何类型定义方法时，该方法会被添加到该类型的方法集中。方法集是与该类型相关联的方法的集合，并被 Go 编译器用来确定某种类型是否可以分配给具有接口类型的变量。接口类型是一种方法的规范，被编译器用来保证一个类型会实现这些方法。任何具有与接口定义中相同名称、相同参数与相同返回值的方法类型都被称为实现了该接口，并允许被分配给具有该接口类型的变量。下面是标准库中 fmt.Stringer 接口的定义。\ntype Stringer interface { String() string } 一个类型要实现 fmt.Stringer 接口，需要提供一个返回 string 的 String() 方法。实现了这个接口，当你把你的类型实例传递给 fmt 包中定义的函数时，你的类型就可以完全按照你的意愿被打印出来（有时称为 “pretty-printed”）。下面的例子定义了一个实现了这个接口的类型：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) type Ocean struct { Creatures []string } func (o Ocean) String() string { return strings.Join(o.Creatures, \u0026#34;, \u0026#34;) } func log(header string, s fmt.Stringer) { fmt.Println(header, \u0026#34;:\u0026#34;, s) } func main() { o := Ocean{ Creatures: []string{ \u0026#34;sea urchin\u0026#34;, \u0026#34;lobster\u0026#34;, \u0026#34;shark\u0026#34;, }, } log(\u0026#34;ocean contains\u0026#34;, o) } 当你运行该代码时，你会看到这样的输出：\nOutput ocean contains : sea urchin, lobster, shark 这个例子定义了一个名为 Ocean 的新结构体类型。Ocean 实现了 fmt.Stringer 接口，因为 Ocean 定义了一个名为 String 的方法，该方法不需要参数，返回一个 string。在 main 方法中，我们定义了一个新的 Ocean，并把它传递给一个 log 函数，该函数首先接收一个 string 来打印，然后是任何实现 fmt.Stringer 的参数。Go 编译器允许我们在这里传递 o，因为 Ocean 实现了 fmt.Stringer 所要求的所有方法。在 log 中，我们使用 fmt.Println ，当它遇到 fmt.Stringer 作为其参数之一时，会调用 Ocean 的 String 方法。\n如果 Ocean 没有实现 String() 方法，Go 会产生一个编译错误，因为 log 方法要求一个 fmt.Stringer 作为其参数。这个错误看起来像这样：\nOutput src/e4/main.go:24:6: cannot use o (type Ocean) as type fmt.Stringer in argument to log: Ocean does not implement fmt.Stringer (missing String method) Go 还将确保提供的 String() 方法与 fmt.Stringer 接口所要求的方法完全一致。如果不匹配，就会产生一个类似这样的错误：\nOutput src/e4/main.go:26:6: cannot use o (type Ocean) as type fmt.Stringer in argument to log: Ocean does not implement fmt.Stringer (wrong type for String method) have String() want String() string 在到目前为止的例子中，我们已经在值接收器上定义了方法。也就是说，如果我们使用方法的功能调用，第一个参数（指的是方法所定义的类型）将是一个该类型的值，而不是一个指针。因此，我们对方法实例所做的任何修改都会在方法执行完毕后被丢弃，因为收到的值是数据的副本。此外，我们也可以在一个类型的指针接收器上定义方法。\n指针接收器 # 在指针接收器上定义方法的语法与在值接收器上定义方法的语法几乎相同。不同的是在接收器声明中用星号（*）作为类型名称的前缀。下面的例子在指针接收器上定义了一个类型的方法：\npackage main import \u0026#34;fmt\u0026#34; type Boat struct { Name string occupants []string } func (b *Boat) AddOccupant(name string) *Boat { b.occupants = append(b.occupants, name) return b } func (b Boat) Manifest() { fmt.Println(\u0026#34;The\u0026#34;, b.Name, \u0026#34;has the following occupants:\u0026#34;) for _, n := range b.occupants { fmt.Println(\u0026#34;\\t\u0026#34;, n) } } func main() { b := \u0026amp;Boat{ Name: \u0026#34;S.S. DigitalOcean\u0026#34;, } b.AddOccupant(\u0026#34;Sammy the Shark\u0026#34;) b.AddOccupant(\u0026#34;Larry the Lobster\u0026#34;) b.Manifest() } 当你运行这个例子时，你会看到以下输出：\nOutput The S.S. DigitalOcean has the following occupants: Sammy the Shark Larry the Lobster 这个例子定义了一个包含 Name 和 occupants 的 Boat 类型。我们想规定其他包中的代码只用 AddOccupant 方法来添加乘员，所以我们通过小写字段名的第一个字母使 occupants 字段不被导出。我们还想确保调用 AddOccupant 会导致 Boat 实例被修改，这就是为什么我们通过指针接收器定义 AddOccupant。指针作为一个类型的特定实例的引用，而不是该类型的副本。AddOccupant 将使用 Boat 类型的指针调用，可以保证任何修改都是持久的。\n在 main 方法中，我们定义了一个新的变量 b，它将持有一个指向 Boat（*Boat）的指针。我们在这个实例上调用了两次 AddOccupant 方法来增加两名乘客。Manifest 方法是在Boat 值上定义的，因为在其定义中，接收器被指定为（b Boat）。在 main 方法中，我们仍然能够调用 Manifest，因为 Go 能够自动解引用指针以获得 Boat 值。b.Manifest()在这里等同于 (*b).Manifest()。\n当试图为接口类型的变量赋值时，一个方法是定义在一个指针接收器上还是定义在一个值接收器上有重要的影响。\n指针接收器和接口 # 当你为一个接口类型的变量赋值时，Go 编译器会检查被赋值类型的方法集，以确保它实现了所有接口方法。指针接收器和值接收器的方法集是不同的，因为接收指针的方法可以修改其接收器，而接收值的方法则不能。\n下面的例子演示了定义两个方法：一个在一个类型的指针接收器上，一个在它的值接收器上。然而，只有指针接收器能够满足本例中也定义的接口：\npackage main import \u0026#34;fmt\u0026#34; type Submersible interface { Dive() } type Shark struct { Name string isUnderwater bool } func (s Shark) String() string { if s.isUnderwater { return fmt.Sprintf(\u0026#34;%s is underwater\u0026#34;, s.Name) } return fmt.Sprintf(\u0026#34;%s is on the surface\u0026#34;, s.Name) } func (s *Shark) Dive() { s.isUnderwater = true } func submerge(s Submersible) { s.Dive() } func main() { s := \u0026amp;Shark{ Name: \u0026#34;Sammy\u0026#34;, } fmt.Println(s) submerge(s) fmt.Println(s) } 当你运行该代码时，你会看到这样的输出：\nOutput Sammy is on the surface Sammy is underwater 这个例子定义了一个叫做 Submersible 的接口，它要求类型实现一个 Dive() 方法。然后我们定义了一个包含 Name 字段 和 isUnderwater 方法的 Shark 类型来跟踪 Shark 的状态。我们在 Shark 的指针接收器上定义了一个 Dive() 方法，将 isUnderwater 修改为 true。我们还定义了值接收器的 String() 方法，这样它就可以使用 fmt.Println 干净利落地打印出 Shark 的状态，方法使用我们之前看过的 fmt.Println 所接收的 fmt.Stringer 接口。我们还使用了一个函数 submerge，它接受一个 Submersible 参数。\n使用 Submersible 接口而不是 *Shark 允许 submerge 方法只依赖于一个类型所提供的行为。这使得 submerge 方法更容易重用，因为你不必为 Submarine、Whale 或任何其他我们还没有想到的未来水生居民编写新的 submerge 方法。只要它们定义了一个 Dive() 方法，就可以和 submerge 方法一起使用。\n在 main 方法中，我们定义了一个变量 s，它是一个指向 Shark 的指针，并立即用 fmt.Println 打印了 s。这展示了输出的第一部分，Sammy is on the surface。我们把 s 传给submerge，然后再次调用 fmt.Println，以 s 为参数，看到输出的第二部分，Sammy is underwater。\n如果我们把 s 改成 Shark而不是 *Shark，Go 编译器会产生错误：\nOutput cannot use s (type Shark) as type Submersible in argument to submerge: Shark does not implement Submersible (Dive method has pointer receiver) Go 编译器很好心地告诉我们，Shark 确实有一个 Dive 方法，它只在指针接收器上定义。当你在自己的代码中看到这条信息时，解决方法是在分配值类型的变量前使用 \u0026amp; 操作符，传递一个指向接口类型的指针。\n总结 # 在 Go 中声明方法与定义接收不同类型变量的函数本质上没有区别。同样，使用指针规则也适用。Go 为这种极其常见的函数定义提供了一些便利，并将这些方法收集到可以通过接口类型进行要求的方法集中。有效地使用方法可以让你在代码中使用接口来提高可测试性，并为你的代码的未来读者留下更好的结构。\n如果你想了解更多关于 Go 编程语言的一般信息，请查看我们的 How To Code in Go 系列。\n"},{"id":34,"href":"/How-To-Code-in-Go/docs/35-How_To_Build_and_Install_Go_Programs/","title":"35 How to Build and Install Go Programs","section":"Docs","content":" 如何构建和安装 Go 程序 # 简介 # 到目前为止，在我们的 How To Code in Go 系列中，你已经使用了go run 命令来自动编译你的源代码并生成可执行文件。虽然这个命令对于在命令行上测试你的代码很有用，但是分发或部署你的应用程序则需要将你的代码构建成一个可共享的二进制可执行文件，或者一个包含机器字节码的单一文件来运行你的应用程序。要做到这一点，你可以使用 Go 工具链来构建和安装你的程序。\n在 Go 中，将源代码转译成二进制可执行文件的过程被称为构建。一旦这个可执行文件被构建，它将不仅包含你的应用程序，还包含在目标平台上执行二进制文件所需的所有支持代码。这意味着 Go 二进制文件不需要 Go 工具链等系统依赖就可以在新系统上运行。将这些可执行文件放在自己系统的可执行文件路径中，就可以在系统的任何地方运行程序，这与把程序安装到你的操作系统上是一样的。\n在本教程中，你将使用 Go 工具链来运行、构建和安装一个示例 Hello, World! 程序，让你有效地使用、分发和部署未来的应用程序。\n前置条件 # 要遵循本文的例子，你将需要：\n按照如何安装 Go 与设置本地编程环境设置的 Go 工作区。 第 1 步 - 设置和运行 Go 二进制文件 # 首先，创建一个应用程序，作为演示 Go 工具链的例子。要做到这一点，你将使用如何用 Go 写第一个程序教程中的经典程序 \u0026ldquo;Hello, World!\u0026quot;。\n在你的 src 目录下创建一个名为 greeter 的目录：\nmkdir greeter 接下来，进入新创建的目录，在你选择的文本编辑器中创建 main.go 文件：\ncd greeter nano main.go 打开文件，添加以下内容：\n# src/greeter/main.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 当程序运行时，这个程序将在控制台打印 Hello, World! 这句话，然后程序将成功退出。\n保存并退出该文件。\n要测试这个程序，使用 go run 命令，就像你在之前的教程中做的那样：\ngo run main.go 你会收到以下输出：\nOutput Hello, World! 如前文所述，go run 命令将你的源文件构建成可执行的二进制文件，然后运行编译后的程序。然而，本教程的目的是以一种可以随意分享和分发的方式来构建二进制文件。要做到这一点，你将在下一步使用 go build 命令。\n第 2 步 \u0026ndash; 创建 Go 模块，建立 Go 二进制文件 # Go 程序和库是围绕着模块的核心概念建立的。一个模块包含了你的程序所使用的库的信息，以及要使用这些库的什么版本。\n为了告诉 Go 这是一个 Go 模块，你需要使用 go mod 命令创建一个 Go 模块：\ngo mod init greeter 这将创建 go.mod 文件，其中包含模块的名称和用于构建模块的 Go 的版本。\nOutput go: creating new go.mod: module greeter go: to add module requirements and sums: go mod tidy Go 会提示你运行 go mod tidy，以便在将来该模块的需求发生变化时更新它，现在运行它不会有额外的效果。\n第 3 步 - 用 go build 构建 Go 二进制文件 # 使用 go build，你可以为我们的示例 Go 应用程序生成可执行的二进制文件，以便在任何你想要的地方分发和部署该程序。\n在 main.go 尝试一下，在你的 greeter 目录下，运行以下命令：\ngo build 如果你没有给这个命令提供参数，go build 将自动编译你当前目录下的 main.go 程序。该命令将包括该目录中所有的 *.go 文件。它还将编译所有支持代码，以便能够在任何具有相同系统结构的计算机上执行二进制文件，无论该系统是否有 .go 源文件，甚至是否安装了 Go。\n在这种情况下，你把你的 greeter 程序构建在一个可执行文件中，并被添加到你的当前目录中。通过运行 ls 命令来检查：\nls 如果你运行的是 macOS 或 Linux 系统，你会发现一个以你构建程序的目录命名的新可执行文件：\nOutput greeter main.go go.mod 注：在Windows上，你的可执行文件将是 greeter.exe。 默认情况下，go build 将为当前平台和架构生成一个可执行文件。例如，如果在 linux/386 系统上构建，可执行文件将与任何其他 linux/386 系统兼容，即使并没有安装 Go。Go 支持为其他平台和架构进行构建，你可以在我们的为不同操作系统和架构构建 Go 应用程序文章中了解更多信息。\n现在，你已经创建了你的可执行文件，运行它以确保二进制文件已被正确构建。在 macOS 或 Linux 上，运行以下命令：\n./greeter 在 Windows 上，运行：\ngreeter.exe 二进制文件的输出将与你用 go run 运行程序时的输出一致：\nOutput Hello, World! 现在你已经创建了一个单一的可执行二进制文件，它不仅包含你的程序，还包含运行该二进制文件所需的所有系统代码。因为这个文件将始终运行同一个程序，你现在可以将这个程序分发到新的系统中，或者将其部署到服务器上。\n在下一节中，本教程将解释二进制文件是如何命名的，以及你如何改变它，以便你能更好地控制程序的构建过程。\n第 4 步 - 改变二进制名称 # 现在你知道了如何生成可执行文件，下一步则是确定 Go 如何为二进制文件选择一个名字，并为你的项目定制这个名字。\n当你运行 go build 时，默认情况下 Go 会自动决定生成的可执行文件的名称。它通过使用你之前创建的模块来实现这一目的。当运行 go mod init greeter 命令时，它创建了名为 greeter 的模块，这就是为什么生成的二进制文件被命名为 greeter。\n让我们仔细看看这个模块方法。如果你的项目中有一个 go.mod 文件，其中有一个 module 声明，像下面这样：\n# go.mod module github.com/sammy/shark 那么生成的可执行文件默认名称将是 shark。\n在需要特定命名规则的更复杂的程序中，这些默认值并不总是你命名二进制文件的最佳选择。在这些情况下，最好用 -o 标识来定制你的输出。\n为了测试这一点，把你在上一节中制作的可执行文件的名称改为 hello，并把它放在一个名为 bin 的子文件夹中。你不需要创建这个文件夹，Go 会在构建过程中自行完成。\n运行以下带有 -o 标志的 go build 命令：\ngo build -o bin/hello -o 标志使 Go 将命令的输出与你选择的任何参数相匹配。在本例中，结果是在一个名为 bin 的子文件夹中产生一个名为 hello 的新可执行文件。\n要测试新的可执行文件，请切换到新目录并运行二进制文件:\ncd bin ./hello 你将收到以下输出:\nOutput Hello, World! 现在你可以自定义你的可执行文件名称，以适应项目需要，这完成了我们对如何在 Go 中构建二进制文件的调研。但是使用 go build，你仍然只限于在当前目录下运行你的二进制文件。为了在系统的任何地方使用新建立的可执行文件，你可以用 go install 来安装它们。\n第 5 步 - 用 go install 安装 Go 程序 # 到目前为止，在这篇文章中，我们已经讨论了如何从我们的 .go 源文件中生成可执行二进制文件。这些可执行文件有助于分发、部署和测试，但它们还不能在其源文件目录之外执行。如果你想在 shell 脚本或其他工作流程中使用你的程序，这将是一个问题。为了使这些程序更容易使用，你可以把它们安装到你的系统中，并从任何地方访问它们。\n为了理解这一点的含义，你将使用 go install 命令来安装你的示例程序。\ngo install 命令与 go build 几乎相同，但它不是将可执行文件留在当前目录或由 o 标志编译到指定的目录中，而是将可执行文件放到 $GOPATH/bin 目录中。\n要找到你的 $GOPATH 目录的位置，请运行以下命令：\ngo env GOPATH 你收到的输出会有所不同，但默认是你的 $HOME 目录下的 go 目录：\nOutput $HOME/go 由于 go install 会将生成的可执行文件放入 $GOPATH 的一个子目录，名为 bin，这个目录必须被添加到 $PATH 环境变量中。这在先决条件文章如何安装 Go 和设置本地编程环境的创建 Go 工作空间步骤中有所涉及。\n设置好 $GOPATH/bin 目录后，切回你的 greeter 目录：\ncd .. 现在运行安装命令：\ngo install 这将构建你的二进制文件并将其放在 $GOPATH/bin 中。要测试这一点，请运行以下程序：\nls $GOPATH/bin 这将列出 $GOPATH/bin 的内容：\nOutput greeter 注：`go install` 命令不支持 `-o` 标记，所以它将使用前面描述的默认名称来命名可执行文件。 安装好二进制文件后，测试一下程序是否能从其源目录外运行，切回你的主目录：\ncd $HOME 使用以下方法来运行该程序：\ngreeter 这将产生以下结果：\nOutput Hello, World! 现在，你可以把你编写的程序安装到你的系统中，让你在任何地方、任何时候都能使用它们。\n总结 # 在本教程中，你演示了 Go 工具链是如何从源代码中轻松构建可执行二进制文件的。这些二进制文件可以分发到其他系统上运行，甚至是那些没有 Go 工具链和环境的系统。你还使用 go install 自动构建并将程序作为可执行文件安装在系统的 $PATH 中。有了 go build 和 go install，你现在可以随意分享和使用你的应用程序。\n现在你了解了 go build 的基础知识，你可以通过用 Build 标签定制 Go 二进制文件教程来探索如何制作模块化的源代码，或者通过为不同的操作系统和架构构建 Go 应用程序来探索如何为不同的平台构建。如果你想了解更多关于 Go 编程语言的信息，请查看整个How To Code in Go 系列。\n"},{"id":35,"href":"/How-To-Code-in-Go/docs/36-How_To_Use_Struct_Tags_in_Go/","title":"36 How to Use Struct Tags in Go","section":"Docs","content":" 如何在 Go 中使用结构体标签 # 简介 # 结构，或称结构体，被用来将多个信息聚合在一个单元中。这些信息集合被用来描述更高层次的概念，例如由 Street、City、State 和 PostalCode 组成的 Address。当你从数据库或 API 等系统中读取这些信息时，你可以使用结构体标签来控制这些信息如何被分配到结构体的字段中。结构体标签是附加在结构体字段上的小块元数据，为与该结构体一起工作的其他 Go 代码提供指示。\n结构体标签是怎么样的 # Go 结构体标签是出现在 Go 结构声明中类型后的注释，每个标签都由与一些相应的值相关的短字符串组成。\n一个结构体的标签看起来像这样，标签的偏移量为 ` 字符：\ntype User struct { Name string `example:\u0026#34;name\u0026#34;` } 其他 Go 代码就能够检查这些结构并提取分配给它所要求的特定键的值。如果没有其他代码对其进行检查，结构体标签对你的代码运行没有任何影响。\n试试这个例子，看看结构体标签是怎么样的，如果没有来自另一个包的代码，它们将没有任何作用。\npackage main import \u0026#34;fmt\u0026#34; type User struct { Name string `example:\u0026#34;name\u0026#34;` } func (u *User) String() string { return fmt.Sprintf(\u0026#34;Hi! My name is %s\u0026#34;, u.Name) } func main() { u := \u0026amp;User{ Name: \u0026#34;Sammy\u0026#34;, } fmt.Println(u) } 这将输出：\nOutput Hi! My name is Sammy 这个例子定义了一个带有 Name 字段的 User 类型。Name 字段被赋了一个结构体标签 example: \u0026quot;name\u0026quot;。我们把这个特定的标签称为 “example 结构体标签”，因为它使用 “example”这个词作为它的键。example 结构体标签的 Name 字段值是 \u0026quot;name\u0026quot;。在 User 类型中，我们还定义了 fmt.Stringer 接口要求的 String() 方法。当我们将该类型传递给 fmt.Println 时，该方法将被自动调用，并使我们可以生成一个格式化的结构体版本。\n在 main 方法中，我们创建了一个新的 User 类型实例，并将其传递给 fmt.Println。尽管这个结构体有一个结构体标签，但我们可以看到它对这个 Go 代码的操作没有影响。如果不存在结构标签，它的行为也会完全一样。\n要使用结构标签来完成某些事，必须编写其他 Go 代码在运行时检查结构体。标准库中有一些包将结构体标签作为其操作的一部分，其中最受欢迎的是 encoding/json 包。\n编码 JSON # JavaScript 对象符号（JSON）是一种文本格式，用于编码根据不同字符串键组织的数据集合。它通常用于不同程序之间的数据通信，因为这种格式足够简单，以至于许多不同的语言都有库对其进行解码，下面是一个 JSON 的例子：\n{ \u0026#34;language\u0026#34;: \u0026#34;Go\u0026#34;, \u0026#34;mascot\u0026#34;: \u0026#34;Gopher\u0026#34; } 这个 JSON 对象包含两个键，language 和 mascot。这些键后面是相关的值，language 键的值为 Go，mascot 则为 Gopher。\n标准库中的 JSON 编码器利用结构体标签作为注解，向编码器表明你想在 JSON 输出中如何命名你的字段。这些 JSON 编码和解码机制可以在 encoding/json 包中找到。\n试试这个例子，看看没有结构体标签的 JSON 是如何编码的：\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name string Password string PreferredFish []string CreatedAt time.Time } func main() { u := \u0026amp;User{ Name: \u0026#34;Sammy the Shark\u0026#34;, Password: \u0026#34;fisharegreat\u0026#34;, CreatedAt: time.Now(), } out, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { log.Println(err) os.Exit(1) } fmt.Println(string(out)) } 这将打印以下输出：\nOutput { \u0026#34;Name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;, \u0026#34;Password\u0026#34;: \u0026#34;fisharegreat\u0026#34;, \u0026#34;CreatedAt\u0026#34;: \u0026#34;2019-09-23T15:50:01.203059-04:00\u0026#34; } 我们定义了一个描述用户的结构，其字段包括用户的姓名、密码和用户的创建时间。在 main 方法中，我们为所有字段提供了值，除了 PreferredFish（Sammy 喜欢所有的鱼），从而创建了这个用户的实例。然后我们把 User 实例传递给 json.MarshalIndent 方法。这样我们可以更容易地看到 JSON 的输出，而不需要使用外部格式化工具。这个调用可以用 json.Marshal(u) 代替，以接收没有任何额外空白的 JSON。json.MarshalIndent 的两个额外参数控制输出的前缀（我们用空字符串省略了），以及缩进使用的字符，这里是两个空格字符。任何由 json.MarshalIndent 产生的错误都会被记录下来，程序使用 os.Exit(1) 终止。最后，我们将从 json.MarshalIndent 返回的 []byte 转换为 string，并将生成的字符串交给 fmt.Println 处理以便在终端打印。\n该结构的字段完全按照我们的命名出现。这不是您所期望的典型的 JSON 风格，它使用了字段名的骆驼字母大小写。在接下来的例子中，你将改变字段的名称，使其遵循骆驼大写的风格。正如你在运行这个例子时看到的，这不会起作用，因为想要的字段名与 Go 导出字段名的规则相冲突。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) type User struct { name string password string preferredFish []string createdAt time.Time } func main() { u := \u0026amp;User{ name: \u0026#34;Sammy the Shark\u0026#34;, password: \u0026#34;fisharegreat\u0026#34;, createdAt: time.Now(), } out, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { log.Println(err) os.Exit(1) } fmt.Println(string(out)) } 这将呈现以下输出：\nOutput {} 在这个版本中，我们把字段的名字改成了驼峰式。现在 Name 是 name，Password 是 password，最后 CreatedAt 是 createdAt。在 main 方法中，我们改变了结构的实例化，以使用这些新的名称。然后我们像以前一样将结构体传递给 json.MarshalIndent 函数。这次输出是一个空的 JSON 对象，{}。\n骆驼对字段的正确命名要求第一个字符必须是小写的。虽然 JSON 并不关心你如何命名你的字段，但 Go 关心，因为它表示字段在包外的可见性。由于 encoding/json 包与我们使用的 main 包是互相独立的，我们必须将第一个字符大写，以使其对 encoding/json 可见。看来我们陷入了僵局，我们需要一些方法来向 JSON 编码器传达我们希望这个字段被命名成什么。\n使用结构体标签来控制编码 # 你可以修改前面的例子，通过给每个字段注解一个结构体标签，使导出的字段用驼峰大写的字段名进行正确编码。encoding/json 识别的结构体标签有一个 json 的键和一个控制输出的值。通过将字段名的驼峰版本作为 json 键的值，编码器将使用该名称代替。这个例子修正了前两次的尝试：\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name string `json:\u0026#34;name\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` PreferredFish []string `json:\u0026#34;preferredFish\u0026#34;` CreatedAt time.Time `json:\u0026#34;createdAt\u0026#34;` } func main() { u := \u0026amp;User{ Name: \u0026#34;Sammy the Shark\u0026#34;, Password: \u0026#34;fisharegreat\u0026#34;, CreatedAt: time.Now(), } out, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { log.Println(err) os.Exit(1) } fmt.Println(string(out)) } 这将输出：\nOutput { \u0026#34;name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;fisharegreat\u0026#34;, \u0026#34;preferredFish\u0026#34;: null, \u0026#34;createdAt\u0026#34;: \u0026#34;2019-09-23T18:16:17.57739-04:00\u0026#34; } 我们把字段名改回来了，通过把名字的第一个字母大写来让其他包看到。然而，这次我们以 json: \u0026quot;name\u0026quot; 的形式添加了结构体标签，其中 \u0026quot;name\u0026quot; 是我们希望 json.MarshalIndent 将结构体打印成 JSON 时使用的名称。\n我们现在已经成功地正确格式化了我们的 JSON。然而，请注意，一些我们没有设置值的字段也被打印了出来。如果你愿意，JSON 编码器也可以省略这些字段。\n删除空的 JSON 字段 # 最常见的是，我们想省略输出 JSON 中未设置的字段。由于 Go 中的所有类型都有一个“零值”，即它们被设置成的一些默认值，encoding/json 包需要额外的信息，以便能够告诉某些字段在赋这个零值时应该被视为未设置。在任何 json 结构体标签的值部分，你可以在你的字段的所需名称后面加上 ,omitempty 来告诉 JSON 编码器，当字段被设置为零值时，省略这个字段的输出。下面的例子修正了之前的例子，不再输出空字段：\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name string `json:\u0026#34;name\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` PreferredFish []string `json:\u0026#34;preferredFish,omitempty\u0026#34;` CreatedAt time.Time `json:\u0026#34;createdAt\u0026#34;` } func main() { u := \u0026amp;User{ Name: \u0026#34;Sammy the Shark\u0026#34;, Password: \u0026#34;fisharegreat\u0026#34;, CreatedAt: time.Now(), } out, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { log.Println(err) os.Exit(1) } fmt.Println(string(out)) } 这个例子将输出：\nOutput { \u0026#34;name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;fisharegreat\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2019-09-23T18:21:53.863846-04:00\u0026#34; } 我们修改了前面的例子，使 PreferredFish 字段现在有结构体标签 json:\u0026quot;preferredFish,omitempty\u0026quot;。,omitempty 的存在使 JSON 编码器跳过该字段，因为我们决定不设置它。在我们以前的例子的输出中，它的值是 null。\n这个输出看起来好多了，但我们仍然打印出了用户的密码。encoding/json 包提供了另一种方法，让我们完全忽略私有字段。\n忽略私有字段 # 有些字段必须从结构体中导出，以便其他包可以正确地与该类型交互。然而，这些字段的性质可能是敏感的，所以在这些情况下，即使它被设置了值，我们仍希望 JSON 编码器能够完全忽略该字段。这可以用特殊值 \u0026quot;-\u0026quot; 作为 json: 结构体标签的值参数来实现。\n这个例子修正了暴露用户密码的问题。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) type User struct { Name string `json:\u0026#34;name\u0026#34;` Password string `json:\u0026#34;-\u0026#34;` CreatedAt time.Time `json:\u0026#34;createdAt\u0026#34;` } func main() { u := \u0026amp;User{ Name: \u0026#34;Sammy the Shark\u0026#34;, Password: \u0026#34;fisharegreat\u0026#34;, CreatedAt: time.Now(), } out, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { log.Println(err) os.Exit(1) } fmt.Println(string(out)) } 当你运行这个例子时，你会看到这样的输出：\nOutput { \u0026#34;name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2019-09-23T16:08:21.124481-04:00\u0026#34; } 这个例子与之前的例子相比，唯一的变化是密码字段。现在使用了特殊的 \u0026quot;-\u0026quot; 作为其 json: 结构体标签的值。我们看到，在这个例子的输出中，password 字段不再存在了。\nencoding/json 包的这些特征，,omitempty 和 \u0026quot;-\u0026quot;，并不是标准。一个包决定对结构体标签的值做什么取决于它的实现。因为 encoding/json 包是标准库的一部分，其他包也以同样的方式实现这些功能，这是一个惯例。然而，很重要的一点是阅读任何使用结构体标签的第三方软件包的文档，以了解哪些是支持的，哪些是不支持的。\n总结 # 结构体标签提供了一种强大的手段来拓展了使用你定义的结构体代码的功能。许多标准库和第三方包提供了通过使用结构体标签来定制其操作的方法。在你的代码中有效地使用它们，既能提供这种定制行为，又能为未来的开发者简要记录这些字段的使用方法。\n"},{"id":36,"href":"/How-To-Code-in-Go/docs/37-How_To_Use_Interfaces_in_Go/","title":"37 How to Use Interfaces in Go","section":"Docs","content":" 如何在 Go 使用 interface # 简述 # 编写灵活的、可重复使用的、模块化的代码对于开发多功能的程序至关重要。以这种方式开发，可以避免在多个地方做同样的修改，从而确保代码更容易维护。如何完成这个目标，不同语言有不同的实现方法来完成这个目标。例如，继承是一种常见的方法，在 Java、C++、C#等语言中都有使用。\n开发者们也可以通过组合实现这个设计目标。组合是一个将多个对象和数据类型组合到一个复杂的结构体中的方式。这个是 Go 用来促进代码复用，模块化和灵活性的方法。在 Go 中 intrerface 提供了一个方法用于构建复杂的组合，学习使用它们，将会使你创建通用的可重复使用的代码。\n在这篇文章中，我们将会学习如何构建那些有相同行为的自定义类型，用于复用代码。 我们还将学习如何为我们自己的自定义类型实现 interface，以满足在另一个包中定义的接口。\n定义一个行为 # 组合实现的核心之一是使用 interface。一个 interface 定义一个类型的行为。Go 标准库中最常用的 interface 之一是fmt.Stringer 接口：\ntype Stringer interface { String() string } 第一行代码定义一个type叫Stringer。然后表明它是一个interface。就好像定义一个结构体，Go 使用大括号({})来囊括 interface 的定义。跟结构体的定义相比，我们只定义interface的行为，就是“这个类型可以做什么”\n对这个Stringer接口的例子来说，唯一的行为就是String()这个方法。这个方法没有参数。\n接着，让我们看一些代码，这些代码有fmt.Stringer的行为：\npackage main import \u0026#34;fmt\u0026#34; type Article struct { Title string Author string } func (a Article) String() string { return fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) } func main() { a := Article{ Title: \u0026#34;Understanding Interfaces in Go\u0026#34;, Author: \u0026#34;Sammy Shark\u0026#34;, } fmt.Println(a.String()) } 第一件事是我们创建了一个新的类型叫做Article。这个类型有一个Title和一个Author字段，两个都是 string 的 数据类型:\n... type Article struct { Title string Author string } ... 接着，我们为 Article 类型定义了一个叫做 String 的 方法。String方法将会返回一个用于表示Article类型的字符串：\n... func (a Article) String() string { return fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) } ... 然后，在我们的mainfunction里，我们创建一个Article类型的实例，并且将它赋值给一个变量叫a。我们给Title字段设置了一个值，为\u0026quot;理解Go中的Interfaces\u0026quot;，给Author字段赋值\u0026quot;Sammy Shark\u0026quot;：\n... a := Article{ Title: \u0026#34;Understanding Interfaces in Go\u0026#34;, Author: \u0026#34;Sammy Shark\u0026#34;, } ... 紧接着，我们通过调用fmt.Println并传入调用a.String()后的结果，打印出String方法的结果：\n... fmt.Println(a.String()) 随后运行程序，你会发现如下输出：\nOutput The \u0026#34;Understanding Interfaces in Go\u0026#34; article was written by Sammy Shark. 至此，我们还没有使用 interface，但是我们创建了一个具备一个行为的类型。这个行为匹配fmt.Stringer接口。随后，让我们看看如何利用这种行为来使我们的代码更容易重复使用。\n定义一个 interface # 现在，我们已经用所需的行为定义了我们的类型，我们可以看看如何使用该行为。\n然而，在这之前，让我们看看如果我们想在一个函数中从Article类型中调用String方法，我们需要做什么：\npackage main import \u0026#34;fmt\u0026#34; type Article struct { Title string Author string } func (a Article) String() string { return fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) } func main() { a := Article{ Title: \u0026#34;Understanding Interfaces in Go\u0026#34;, Author: \u0026#34;Sammy Shark\u0026#34;, } Print(a) } func Print(a Article) { fmt.Println(a.String()) } 这段代码中，我们添加了一个名为Print的新函数，该函数接收一个Article作为参数。请注意，Print函数唯一做的事情是调用String方法。正因为如此，我们则可以定义一个接口来传递给函数。\npackage main import \u0026#34;fmt\u0026#34; type Article struct { Title string Author string } func (a Article) String() string { return fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) } type Stringer interface { String() string } func main() { a := Article{ Title: \u0026#34;Understanding Interfaces in Go\u0026#34;, Author: \u0026#34;Sammy Shark\u0026#34;, } Print(a) } func Print(s Stringer) { fmt.Println(s.String()) } 这里我们创建了一个 interface 叫做Stringer：\n... type Stringer interface { String() string } ... Stringerinterface 只有一个方法，叫做String()，返回一个string。method是一个特殊的函数，在 Go 中被限定于一个特殊类型。不像函数，一个方法只能从它所定义的类型的实例中被调用。\n然后我们更新Print方法的签名来接收一个Stringer，而不是一个Article的具体类型。因为编译器知道Stringer接口定义了String方法，所以它只接收也有String方法的类型。\n现在我们可以对任何满足Stringer接口的东西使用Print方法。让我们创建另一个类型来证明这一点：\npackage main import \u0026#34;fmt\u0026#34; type Article struct { Title string Author string } func (a Article) String() string { return fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) } type Book struct { Title string Author string Pages int } func (b Book) String() string { return fmt.Sprintf(\u0026#34;The %q book was written by %s.\u0026#34;, b.Title, b.Author) } type Stringer interface { String() string } func main() { a := Article{ Title: \u0026#34;Understanding Interfaces in Go\u0026#34;, Author: \u0026#34;Sammy Shark\u0026#34;, } Print(a) b := Book{ Title: \u0026#34;All About Go\u0026#34;, Author: \u0026#34;Jenny Dolphin\u0026#34;, Pages: 25, } Print(b) } func Print(s Stringer) { fmt.Println(s.String()) } 现在，我们添加了第二个类型叫Book。它同样也有定义String方法。这表示它也满足Stringer接口。因此，我们也可以传递它到Print函数：\nOutput The \u0026#34;Understanding Interfaces in Go\u0026#34; article was written by Sammy Shark. The \u0026#34;All About Go\u0026#34; book was written by Jenny Dolphin. It has 25 pages. 到目前为止，我们已经演示了如何只使用一个 interface。然而，一个 interface 可以有不止一个行为的定义。接下来，我们将看到如何通过声明更多的方法来使我们的 interface 更加通用。\n多行为 interface # 编写 Go 代码的核心原则之一是编写小而简洁的类型，并将它们组成更大，更复杂的类型。组合 interface 也是一样的。为了了解我们是如何建立一个 interface 的，我们先从只定义一个 interface 开始。我们将会定义 2 个形状，一个Circle和一个Square，然后他们都会定义一个方法叫Area。这个方法会返回它们对应形状的几何面积：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Circle struct { Radius float64 } func (c Circle) Area() float64 { return math.Pi * math.Pow(c.Radius, 2) } type Square struct { Width float64 Height float64 } func (s Square) Area() float64 { return s.Width * s.Height } type Sizer interface { Area() float64 } func main() { c := Circle{Radius: 10} s := Square{Height: 10, Width: 5} l := Less(c, s) fmt.Printf(\u0026#34;%+v is the smallest\\n\u0026#34;, l) } func Less(s1, s2 Sizer) Sizer { if s1.Area() \u0026lt; s2.Area() { return s1 } return s2 } 因为每个类型都定义了Area方法，我们可以创建一个 interface 来定义这个行为。我们创建如下的Sizerinterface:\n... type Sizer interface { Area() float64 } ... 然后定义一个函数叫做Less，传入 2 个Sizer并返回最小的那一个：\n... func Less(s1, s2 Sizer) Sizer { if s1.Area() \u0026lt; s2.Area() { return s1 } return s2 } ... 注意到我们不仅接收 2 个都为Sizer的类型，而且返回的结果也用Sizer。这意味着我们不再返回一个Square或者一个Circle，而是Sizerinterface。\n最后，我们打印出哪一个是最小的面积：\nOutput {Width:5 Height:10} is the smallest 接着，让我们给每个类型添加另一个行为。这次我们添加String()方法，返回一个 string。这个满足fmt.Stringerinterface:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Circle struct { Radius float64 } func (c Circle) Area() float64 { return math.Pi * math.Pow(c.Radius, 2) } func (c Circle) String() string { return fmt.Sprintf(\u0026#34;Circle {Radius: %.2f}\u0026#34;, c.Radius) } type Square struct { Width float64 Height float64 } func (s Square) Area() float64 { return s.Width * s.Height } func (s Square) String() string { return fmt.Sprintf(\u0026#34;Square {Width: %.2f, Height: %.2f}\u0026#34;, s.Width, s.Height) } type Sizer interface { Area() float64 } type Shaper interface { Sizer fmt.Stringer } func main() { c := Circle{Radius: 10} PrintArea(c) s := Square{Height: 10, Width: 5} PrintArea(s) l := Less(c, s) fmt.Printf(\u0026#34;%v is the smallest\\n\u0026#34;, l) } func Less(s1, s2 Sizer) Sizer { if s1.Area() \u0026lt; s2.Area() { return s1 } return s2 } func PrintArea(s Shaper) { fmt.Printf(\u0026#34;area of %s is %.2f\\n\u0026#34;, s.String(), s.Area()) } 因为Circle和Square类型都同时实现了Area和String方法，我们现在可以创建另一个 interface 来描述这些更广泛的行为。为了实现这个，我们创建了一个 interface 叫做Shaper。这个Shaper将由Sizerinterface 和fmt.Stringerinterface 组成：\n... type Shaper interface { Sizer fmt.Stringer } ... **注意：**基于习惯，尝试以er结尾来给你的 interface 命名，例如fmt.Stringer，io.Writer等等。这也是为什么我们用Shaper来命名我们的 interface，而不是Shape。\n现在我们可以创建一个名为PrintArea的函数，该函数以Shaper为参数。这意味着我们可以对传入的值调用Area和String这两个方法：\n... func PrintArea(s Shaper) { fmt.Printf(\u0026#34;area of %s is %.2f\\n\u0026#34;, s.String(), s.Area()) } 如果我们运行程序，将会收到如下输出：\nOutput area of Circle {Radius: 10.00} is 314.16 area of Square {Width: 5.00, Height: 10.00} is 50.00 Square {Width: 5.00, Height: 10.00} is the smallest 我们现在已经看到了我们如何创建较小的 interface，并根据需要将它们建立成较大的 interface。虽然我们可以从较大的 interface 开始，并将其传递给我们所有的函数，但最好的做法是只将最小的 interface 发送给需要的函数。这通常会使代码更加清晰，因为任何接收特定的较小的 interface 的东西都只打算执行其定义的行为。\n例如，如果我们将Shaper传递给Less函数，我们可能会认为它要同时调用Area和String方法。然而，由于我们只打算调用Area方法，这使得Less函数很清楚，因为我们知道我们只能调用传递给它的任何参数的Area方法。\n总结 # 我们已经看到，创建较小的 interface 并将其构建为较大的 interface，可以让我们只分享我们需要的函数或方法。我们还了解到，我们可以从其他 interface 中组成我们的 interface，包括从其他包中定义的 interface，而不仅仅是我们的包。\n"},{"id":37,"href":"/How-To-Code-in-Go/docs/38-Building_Go_Applications_for_Different_Operating_Systems_and_Architectures/","title":"38 Building Go Applications for Different Operating Systems and Architectures","section":"Docs","content":" 在不同的操作系统和架构编译 Go 应用 # 在软件开发中，重要的是要考虑你想为之编译二进制的操作系统和底层处理器架构。因为在不同的操作系统/架构平台上运行一个二进制文件通常很慢或不可能，所以通常的做法是为许多不同的平台编译你最终的二进制文件，以最大化你的程序的受众。然而，这通常是很困难的，当你开发软件的平台和你想要部署的平台不是同一个的时候。例如，在过去，在 Windows 上开发一个程序并将其部署到 Linux 或 macOS 机器上，需要为每一个你想要的二进制文件的环境设置构建机器。你还需要保持你的工具同步，此外还有其他考虑因素，这些因素会增加成本，使协作测试和分布式更加困难。\nGo 通过在go build工具中直接建立对多平台的支持，以及 Go 工具链的其他部分解决了这个问题。通过使用环境变量和构建标签，你可以控制你最终的二进制文件是为哪个操作系统和架构构建的，此外还可以把一个工作流程放在一起，在不改变你的代码库的情况下快速切换对平台依赖的代码。\n在本教程中，你将把一个将strings连接成文件路径的示例应用程序放在一起，创建并有选择地包括与平台有关的片段，并在你自己的系统上为多个操作系统和系统架构构建二进制文件，向你展示如何使用 Go 编程语言的这一强大能力。\n前期准备 # 为了跟随本文的例子，你将需要：\n按照如何安装 Go 和设置本地程序环境设置的 Go 的 workspace GOOS和GOARCH可能支持的平台 # 在展示如何控制构建过程为不同的平台构建二进制文件之前，让我们先了解一下 Go 能够为哪些类型的平台进行构建，以及 Go 如何使用环境变量GOOS和GOARCH关联这些平台。\nGo 工具有一个命令，可以打印出 Go 可以构建的平台的列表。这个列表会随着每一个新的 Go 版本而改变，所以这里讨论的组合在另一个版本的 Go 中可能不一样。当下写这个教程的时候，Go release 版本是 1.13.\n为了找到适用的平台，执行如下命令：\ngo tool dist list 你将会收到如下相似的输出：\nOutput aix/ppc64 freebsd/amd64 linux/mipsle openbsd/386 android/386 freebsd/arm linux/ppc64 openbsd/amd64 android/amd64 illumos/amd64 linux/ppc64le openbsd/arm android/arm js/wasm linux/s390x openbsd/arm64 android/arm64 linux/386 nacl/386 plan9/386 darwin/386 linux/amd64 nacl/amd64p32 plan9/amd64 darwin/amd64 linux/arm nacl/arm plan9/arm darwin/arm linux/arm64 netbsd/386 solaris/amd64 darwin/arm64 linux/mips netbsd/amd64 windows/386 dragonfly/amd64 linux/mips64 netbsd/arm windows/amd64 freebsd/386 linux/mips64le netbsd/arm64 windows/arm 输出是一些以/分割的键值对。键值对的第一个部分，在/之前的是操作系统。在 Go 里面，这些操作系统会是环境变量GOOS的值，发音像“goose”，代表Go Operation System。第二部分，在/之后的，是架构。如前所述，这些都是环境变量GOARCH可能的值。这个发音\u0026quot;gore-ch\u0026quot;，代表Go Architecture。\n让我们以linux/386为例，对其中的一个组合进行分解，了解它的含义和工作原理。键值对以GOOS开始，在这个例子中是linux，指的是Linux 操作系统。这里的GOARCH应该是386，它代表英特尔 80386 微处理器。\n有许多平台可以使用go build命令，但大多数情况下，你最终会使用linux , windows或darwin作为 GOOS 的值。这些涵盖了三大操作系统平台： Linux、Windows和macOS，后者是基于Darwin Operating system的，因此被称为darwin。然而，Go 也可以覆盖不太主流的平台，如nacl，它代表了谷歌的本地客户端。\n当你运行go build这样的命令时，Go 使用当前平台的GOOS和GOARCH来决定如何构建二进制文件。要想知道你的平台是什么组合，你可以使用go env命令，并将GOOS和GOARCH作为参数：\ngo env GOOS GOARCH 在测试这个例子时，我们在一台AMD64 架构的机器上的 macOS 上运行这个命令，所以我们将收到以下输出：\nOutput darwin amd64 这个命令的输出告诉我们系统的 GOOS 是 darwin，GOARCH 是 amd64。\n你现在知道了 Go 中的GOOS和GOARCH是什么，以及它们的可能值。接下来，你将编写一个程序，作为如何使用这些环境变量和构建标签为其他平台构建二进制文件的例子。\n用filepath.Join编写一个平台依赖的应用程序 # 在你开始构建其他平台的二进制前，让我们先构建一个范例程序。出于这个目的，一个好的例子可以用 Go 标准库中的path/filepath包内的Join函数。这个函数以多个 string 为传参，并返回一个用正确文件路径分隔符拼接的 string。\n这是一个很好的范例程序，因为该程序的运行取决于它在哪个操作系统上运行。在 Windows 上，路径分隔符是反斜杠，\\，而基于 Unix 的系统使用正斜杠，/。\n让我们从构建一个使用filepath.Join()的应用程序开始，稍后，你将编写你自己的Join()函数的实现，将代码定制为特定平台的二进制文件。\n首先，在你的src目录下创建一个文件夹，用你的应用程序的名字命名：\nmkdir app 进入目录：\ncd app 接下来，在你选择的文本编辑器中创建一个名为main.go的新文件。在本教程中，我们将使用 Nano。\nnano main.go 文件打开后，添加如下代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { s := filepath.Join(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) fmt.Println(s) } 在这个文件的main()函数用filepath.Join()将三个strings用正确的，平台依赖的路径分隔符连接起来。\n保存并退出文件，然后运行程序：\ngo run main.go 当运行这个程序时，你将收到不同的输出，这取决于你所使用的平台。在 Windows 上，你会看到用\\分隔的字符串。\nOutput a\\b\\c 在 MacOS 和 Linux 等 Unix 系统上，你将收到以下内容。\nOutput a/b/c 这表明，由于这些操作系统使用的文件系统协议不同，程序将不得不为不同的平台构建不同的代码。但由于它已经根据操作系统使用了不同的文件分隔符，所有我们知道filepath.Join()已经考虑了平台的差异。这是因为 Go 工具链会自动检测你的机器的GOOS和GOARCH，并使用这些信息来使用具有正确构建标签和文件分隔符的代码片段。\n让我们思考一下filepath.Join()函数的分隔符是从哪里来的。运行以下命令来查看 Go 标准库中的相关片段：\nless /usr/local/go/src/os/path_unix.go 这将显示path_unix.go的内容。寻找该文件的如下部分：\n. . . // +build aix darwin dragonfly freebsd js,wasm linux nacl netbsd openbsd solaris package os const ( PathSeparator = \u0026#39;/\u0026#39; // OS-specific path separator PathListSeparator = \u0026#39;:\u0026#39; // OS-specific path list separator ) . . . 这一段为 Go 为支持的所有类 Unix 系统定义了 PathSeparator。 注意顶部的所有构建标签，它们是与 Unix 相关的每一个可能的 Unix GOOS平台。当GOOS与这些名词匹配时，你的程序将产生 Unix 风格的文件路径分隔符。\n按q返回到命令行。\n接下来，打开定义在 Windows 上使用filepath.Join()时的行为的文件。\nless /usr/local/go/src/os/path_windows.go 你会看到如下内容：\n. . . package os const ( PathSeparator = \u0026#39;\\\\\u0026#39; // OS-specific path separator PathListSeparator = \u0026#39;;\u0026#39; // OS-specific path list separator ) . . . 虽然PathSeparator的值在这里是\\\\，但代码将呈现 Windows 文件路径所需的单一反斜杠（\\），因为第一个反斜杠只需要作为转义字符。\n请注意，与 Unix 文件不同，它的顶部没有构建标签。这是因为GOOS和GOARCH可以通过在文件后缀加上分隔符和环境变量的值来作为参数传递给go build，这个我们将会在使用 GOOS 和 GOARCH 文件后缀名做更多的研究。这里，path_windows.go的_windows部分使文件的行为就像它在文件的顶部有 build 标签//+build windows。因为这个，但你程序在 windows 上运行时，它将使用path_windows.go代码片段中的PathSeparator和PathListSeparator常量。\nTo return to the command line, quit less by pressing q.\n要返回到命令行，按q键退出less。\n在这一步，你建立了一个程序，展示了 Go 如何将GOOS和GOARCH自动转换为构建标签。考虑到这一点，你现在可以更新你的程序，编写你自己的filepath.Join()的实现，使用构建标签为 Windows 和 Unix 平台手动设置正确的PathSeparator。\n实现一个平台特定函数 # 现在你已经知道 Go 的标准库是如何实现特定平台的代码的，你可以使用构建标签在你自己的应用程序中做到这一点。要做到这一点，你将编写你自己的filepath.Join()的实现。\n打开你的main.go文件：\nnano main.go 用你自己的函数Join()替换main.go的内容，如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func Join(parts ...string) string { return strings.Join(parts, PathSeparator) } func main() { s := Join(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) fmt.Println(s) } Join 函数接收若干parts，并使用strings 包中的strings.Join()方法将它们连接起来，使用PathSeparator将各部分连接起来。\n你还没有定义PathSeparator，所以现在在另一个文件中做。保存并退出main.go，打开你喜欢的编辑器，创建一个名为path.go的新文件。\nnano path.go 定义PathSeparator，并将其设置为 Unix 文件路径分隔符，/。\npackage main const PathSeparator = \u0026#34;/\u0026#34; 编译并运行该应用程序：\ngo build ./app 你将会收到如下输出：\nOutput a/b/c 这样运行成功，得到一个 Unix 风格的文件路径。但这还不是我们想要的：无论在什么平台上运行，输出总是 a/b/c。为了添加创建 Windows 风格文件路径的功能，你需要添加一个 Windows 版本的PathSeparator，并告诉go build命令使用哪个版本。在下一节中，你将使用构建标签来完成这个任务。\n使用GOOS或GOARCH构建标签 # 为了考虑到 Windows 平台，你现在将创建一个替代文件到path.go，并使用构建标签来确保代码片段只在GOOS和GOARCH是合适的平台时运行。\n但首先，在path.go中添加一个构建标签，告诉它除 Windows 之外的所有东西都可以进行构建。打开该文件：\nnano path.go 加入如下高亮构建标签到文件：\n// +build !windows package main const PathSeparator = \u0026#34;/\u0026#34; Go 构建标签允许反转，也就是说，你可以指示 Go 为除 Windows 之外的任何平台构建此文件。 要反转一个构建标签，请在标签前加上一个!。\n保存并退出文件。\n现在，如果你要在 Windows 上运行这个程序，你会得到以下错误：\nOutput ./main.go:9:29: undefined: PathSeparator 在这种情况下，Go 将无法通过引入path.go来定义变量PathSeparator。\n现在你已经确保当GOOS是 Windows 时，path.go不会运行，添加一个新的文件，windows.go：\nnano windows.go 在windows.go中，定义 Windows 的PathSeparator，以及一个构建标签让go build命令知道它是 Windows 的实现：\n// +build windows package main const PathSeparator = \u0026#34;\\\\\u0026#34; 保存文件并从文本编辑器中退出。该应用程序现在可以以一种方式为 Windows 编译，另一种方式为所有其他平台编译。\n虽然现在二进制文件可以在其他平台正确编译，但你必须做进一步的修改，以便为你无法访问的平台进行编译。要做到这一点，你将在下一步改变你的本地GOOS和GOARCH环境变量。\n使用你本地GOOS和GOARCH环境变量 # 在前面，你通过执行go env GOOS GOACH指令来找到你正在工作的平台是哪个操作系统和架构。当你执行go env指令时，它会去找 2 个环境变量GOOS和GOARCH；如果找到，他们就会使用环境变量，如果找不到，Go 就会用当前平台的信息来设置它们。这意味着你可以改变GOOS或GOARCH，所以它们不是根据你的操作系统和架构默认设置的。\ngo build命令的行为方式与go env命令类似。你可以设置GOOS或GOARCH的环境变量，用go build为不同的平台进行编译。\n如果你没有使用Windows系统，可以在运行go build命令时将GOOS环境变量设置为windows，从而构建应用程序windows 下的二进制版本：\nGOOS=windows go build 现在列出你当前目录中的文件：\nls 列出目录文件的输出项显示在项目目录中现在有一个app.exe的 Windows 可执行文件：\nOutput app app.exe main.go path.go windows.go 使用file命令，你可以得到关于这个文件的更多信息，确认它的构建构建信息：\nfile app.exe 你将会看到如下信息：\nOutput app.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows 你也可以在构建时设置一个，或两个环境变量。运行如下命令：\nGOOS=linux GOARCH=ppc64 go build 你的应用程序的可执行文件现在将被一个不同架构的文件所取代。在这个二进制文件上运行file命令：\nfile app 你将会收到类似如下的信息：\napp: ELF 64-bit MSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, not stripped 通过设置本地的 GOOS 和 GOARCH 环境变量，你将可以为任何兼容 Go 的平台构建二进制文件，而无需复杂的配置或设置。接下来，你将使用文件名的约定来保持你的文件整齐，并自动为特定平台构建，而不需要构建标签。\n使用GOOS和GOARCH文件名后缀 # 正如你之前看到的，Go 标准库大量使用构建标签，通过将不同的平台实现分离到不同的文件中来简化代码。当你打开os/path_unix.go文件时，有一个构建标签，列出了所有被认为是类 Unix 平台的可能组合。然而，os/path_windows.go文件不包含任何构建标签，因为文件名的后缀就足以告诉 Go 该文件是为哪个平台准备的。\n让我们来看看这个功能的语法。命名.go文件时，可以在文件名中按顺序添加GOOS和GOARCH作为后缀，用下划线(_)来分开这两个值。如果你有一个名为filename.go的 Go 文件，你可以通过将文件名改为 filename_GOOS_GOARCH.go来指定操作系统和架构。举个例子，如果你希望将其编译为 64 位ARM 架构的 Windows，你会将文件名定为filename_windows_arm64.go。这种命名方式有助于保持代码的整齐性。\n使用文件名后缀而非构建标签来更新你的程序。首先，重新命名path.go和windows.go文件，使用os包中使用的惯例：\nmv path.go path_unix.go mv windows.go path_windows.go 改变了这两个文件名后，你可以删除你添加到path_windows.go的构建标签：\nnano path_windows.go 移除// +build windows，所以你的文件会看起来像这样：\npackage main const PathSeparator = \u0026#34;\\\\\u0026#34; 保存并退出文件。\n因为unix不是一个有效的GOOS，_unix.go后缀对 Go 编译器没有任何意义。然而，它确实传达了文件的预期目的。 和os/path_unix.go文件一样，你的path_unix.go文件仍然需要使用构建标签，所以保持该文件不变。\n通过使用文件名惯例，你从你的源代码中删除了不需要的构建标签，并使文件系统更干净、更清晰。\n总结 # 为多个平台生成不需要依赖的二进制文件的能力是 Go 工具链的一个强大功能。在本教程中，你通过添加构建标签和文件名后缀来使用这种能力，以标记某些代码片段，使其只针对某些架构进行编译。你创建了你自己的平台依赖的程序，然后操纵GOOS和GOARCH环境变量，为你当前平台以外的平台生成二进制文件。这是一项有价值的技能，因为有一个持续集成过程，自动运行这些环境变量，为所有平台构建二进制文件，这是一个常见的做法。\n"},{"id":38,"href":"/How-To-Code-in-Go/docs/39-Using_ldflags_to_Set_Version_Information_for_Go_Applications/","title":"39 Using Ldflags to Set Version Information for Go Applications","section":"Docs","content":" 用 ldflags 设置 Go 应用程序的版本信息 # 简介 # 当把应用程序部署到生产环境中时，用版本信息和其他元数据构建二进制文件将改善你的监控、日志和调试过程，增加识别信息来帮助跟踪随着时间推移后，应用程序的构建信息。这种版本信息通常包括高度动态的数据，如构建时间、构建二进制文件的机器或用户、版本控制系统（VCS）的提交 ID，等其他更多信息。因为这些值是不断变化的，将这些数据直接编码到源代码中，并在每次新的构建之前进行修改，是很繁琐的，而且容易出错：源文件可能会移动，变量/常量在整个开发过程中可能会随着切换文件而改动，打断构建过程。\n在 Go 中解决这个问题的一个方法是在使用go build命令时加上-ldflags，在构建时将动态信息插入二进制文件中，而不需要修改源代码。在这个标志中，ld代表linker，这个程序将编译后的源代码的不同部分连接成最终的二进制文件。ldflags就代表linker 的标志。之所以这样说，是因为它向底层的 Go 工具链 linkercmd/link传递了一个标志，允许你在构建时从命令行中改变导入的包的值。\n在本教程中，你将使用-ldflags在构建时改变变量的值，并将你自己的动态信息加入二进制，用一个将版本信息打印到屏幕上的应用程序作为示例应用程序。\n前期准备 # 为了接下去在文章中的例子，你需要：\n按照如何安装 Go 和设置本地编程环境设置 Go 的 workspace。 构建你的范例应用程序 # 在使用ldflags加入动态数据之前，你首先需要一个应用程序来插入信息。在这一步，你将制作这个应用程序，在这个阶段，它将只打印静态的版本信息。现在让我们来创建这个应用程序。\n在你的src目录下，建立一个以你的应用程序命名的目录。本教程将使用叫app的应用程序：\nmkdir app 跳转你的目录到这个文件夹：\ncd app 然后，使用你喜欢的文本编辑器，在main.go创建你的程序的 entry point：\nnano main.go 现在，通过加入如下内容到你的程序内，来打印出版本信息：\npackage main import ( \u0026#34;fmt\u0026#34; ) var Version = \u0026#34;development\u0026#34; func main() { fmt.Println(\u0026#34;Version:\\t\u0026#34;, Version) } 在main()函数内，你宣告了Version变量，然后打印string类型的Version：紧跟着 tab 的字符，\\t，然后是声明的变量。\n现在，参数Version被定义为development，将作为 app 的默认版本。稍后，你将会修改这个值来符合官方版本编号，根据semantic versioning format来定义。\n保存并退出该文件。完成后，构建并运行该应用程序，来确认它打印的是正确的版本：\ngo build ./app 你将会看到如下输出：\nOutput Version:\tdevelopment 你现在有一个打印默认版本信息的应用程序，但你还没有办法在构建时传入当前版本信息。在下一步，你将使用-ldflags和go build来解决这个问题。\n在 go build中使用ldflags的方法 # 在前面提到的，ldflags代表linker 标志，用于向 Go 工具链中的底层 linker 传递标志。这是按以下语法进行的：\ngo build -ldflags=\u0026#34;-flag\u0026#34; 在这个例子中，我们向作为go build的一部分运行的go tool link命令传递了flag。这个命令在传递给ldflags的内容周围使用双引号，以避免其中字符串被分开，或者被命令行翻译为与我们想要的不同的字符。从这里，你可以传入许多不同的linker标志。为了本教程中的目的，我们将使用-X标志在链接时将信息写入变量，跟着的是参数的package路径和它的新值：\ngo build -ldflags=\u0026#34;-X \u0026#39;package_path.variable_name=new_value\u0026#39;\u0026#34; 在引号内，现在有X选项和一个键值对，代表要改变的变量和它的新值。.字符将包路径和变量名称分开，单引号用于避免键值对被断开。\n要在你的示例程序中替换Version变量，使用最后一个命令块中的语法，传入一个新的值并建立新的二进制。\ngo build -ldflags=\u0026#34;-X \u0026#39;main.Version=v1.0.0\u0026#39;\u0026#34; 在这个命令中，main是Version变量的包路径，因为这个变量在main.go文件中。Version是你要写入的变量，v1.0.0是新的值。\n为了使用ldflags，你想改变的值必须存在，并且是一个string类型的包级变量。这个变量可以是对外导出的也可以不是。变量的值不可以是const或者是需要通过调用函数后得到的结果赋值的。幸运的是，Version满足了所有的要求：它已经在main.go文件中被声明为一个变量，而且当前值(development)和期望值(v1.0.0)都是字符串。\n一旦你的新app二进制文件构建起来，运行应用程序：\n./app 你将会收到如下输出：\nOutput Version:\tv1.0.0 通过-ldflags，你成功地把Version变量的值从development改成v1.0.0。\n现在你已经在一个简单的应用程序构建时修改了一个string变量。使用ldflags，你可以在二进制文件中嵌入版本细节、许可信息等，只需使用命令行就可以发布。\n在这个例子中，你改变的变量在main程序中，减少了确定路径名称的难度。但有时这些变量的路径寻找起来比较复杂。在下一步中，你将给子包中的变量赋值，来阐述确定更复杂的包路径的最佳方法。\n锁定子包变量 # 在上一节中，你操作了Version变量，它位于应用程序的顶层包。但这不是常见的案例。通常情况下，将这些变量放在另一个包中更为实际，因为main不是一个可导入的包。为了在你的示例程序中模拟这一点，你将创建一个新的子包，app/build，它将存储关于二进制文件被构建的时间和发出构建命令的用户名称的信息。\n要添加一个新的子包，首先在你的项目中添加一个名为`build\u0026rsquo;的新目录：\nmkdir -p build 然后创建一个名为build.go的新文件来保存新的变量：\nnano build/build.go 在你的文本编辑器中，添加Time和User这两个新变量\npackage build var Time string var User string Time变量将保存二进制文件建立的时间的字符串表示。User变量将保存构建二进制文件的用户名称。由于这两个变量总是有值，你不需要像对Version那样用默认值初始化这些变量。\n保存并退出文件。\n然后，打开main.go文件添加这些变量到你的应用程序中：\nnano main.go 在main.go中，添加如下高亮代码：\npackage main import ( \u0026#34;app/build\u0026#34; \u0026#34;fmt\u0026#34; ) var Version = \u0026#34;development\u0026#34; func main() { fmt.Println(\u0026#34;Version:\\t\u0026#34;, Version) fmt.Println(\u0026#34;build.Time:\\t\u0026#34;, build.Time) fmt.Println(\u0026#34;build.User:\\t\u0026#34;, build.User) } 在这些代码里，你第一次引用app/build包，然后用打印Version的方式打印build.Time和build.User。\n保存文件，然后从你的文本编辑器退出。\n接下来，为了用ldflags锁定这些变量，你可以使用导入路径app/build，然后是.User或.Time，因为你已经知道导入的路径。 然而，为了模拟一种更复杂的情况，即不知道变量的导入路径，让我们改用 Go 工具链中的nm命令。\ngo tool nm命令将输出在给定的可执行文件、对象文件或存档中涉及的符号。在这种情况下，符号指的是代码中的一个对象，例如一个定义的或导入的变量或函数。通过使用nm生成一个符号表，并使用grep搜索一个变量，你可以快速找到其路径信息。\n注意：如果软件包名称中有任何非ASCII字符，或者有\u0026quot;或%字符，nm命令将不能帮助你找到变量的路径，因为这是工具本身的限制。\n要使用这个命令，首先要为app构建二进制文件：\ngo build 现在app已经构建好了，将nm工具指向它，并在输出中搜索：\ngo tool nm ./app | grep app 当运行时，nm工具将输出大量的数据。因为如此，前面的命令使用|将输出的数据输送给grep命令，然后搜索标题中带有一级app的数据。\n你将会收到类似如下的输出：\nOutput 55d2c0 D app/build.Time 55d2d0 D app/build.User 4069a0 T runtime.appendIntStr 462580 T strconv.appendEscapedRune . . . 在这种情况下，结果集的前两行包含你要找的两个变量的路径。app/build.Time和app/build.User。\n现在你知道了路径，再次构建应用程序，这次在构建时改变版本、用户和时间。要做到这一点，需要向-ldflags传递多个-X标志：\ngo build -v -ldflags=\u0026#34;-X \u0026#39;main.Version=v1.0.0\u0026#39; -X \u0026#39;app/build.User=$(id -u -n)\u0026#39; -X \u0026#39;app/build.Time=$(date)\u0026#39;\u0026#34; 这里你传入了id -u -n Bash 命令来列出当前用户，以及date命令来列出当前日期。\n构建好了可执行文件，运行该程序：\n./app 该命令在 Unix 系统上运行时，将产生与下面类似的输出：\nOutput Version:\tv1.0.0 build.Time:\tFri Oct 4 19:49:19 UTC 2019 build.User:\tsammy 现在你有一个包含版本和构建信息的二进制文件，在生产中解决问题时可以提供重要帮助。\n总结 # 这个教程展示了，如果应用得当，ldflags可以成为一个强大的工具，在构建时向二进制文件注入有价值的信息。这样，你可以控制功能标志、环境信息、版本信息等等，而不需要对你的源代码进行修改。通过添加ldflags到你当前的构建工作流程中，你可以最大限度地发挥 Go 自成一体的二进制的发布格式的优势。\n"},{"id":39,"href":"/How-To-Code-in-Go/docs/40-How_To_Use_the_Flag_Package_in_Go/","title":"40 How to Use the Flag Package in Go","section":"Docs","content":" 在 Go 里面如何使用 Flag 包 # 简介 # 命令行工具很少在没有额外配置的情况下开箱即用。好的默认值固然很重要，但有用的工具需要接受用户的配置。在大多数平台上，命令行工具通过接收标志来指定命令的执行。标志是以键值分隔的字符串，加在命令的名称后面。Go 让你通过使用标准库中的 flag 包来制作接受标志的命令行工具。\n在本教程中，你将探索使用 flag 包来建立不同种类的命令行工具的各种方法。你将使用一个标志来控制程序输出，引入位置参数，在这里你将混合标志和其他数据，然后实现子命令。\n用 Flag 来改变程序的行为 # 使用 flag 包包括三个步骤：首先，定义变量以捕获标志值，然后定义你的 Go 应用程序将使用的标志，最后解析执行时提供给应用程序的标志。flag包内的大多数函数都与定义标志和将它们与你定义的变量绑定有关。解析阶段由Parse()函数处理。\n为了阐述这一点，你将创建一个程序，定义一个 Boolean标志，改变这个标志将会把信息打印到标准输出上。如果提供一个-color标志，程序会用蓝色来打印消息。如果没有这个标志，则打印消息不会有颜色。\n创建一个叫boolean.go的文件：\nnano boolean.go 添加如下代码到文件里面来创建程序：\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) type Color string const ( ColorBlack Color = \u0026#34;\\u001b[30m\u0026#34; ColorRed = \u0026#34;\\u001b[31m\u0026#34; ColorGreen = \u0026#34;\\u001b[32m\u0026#34; ColorYellow = \u0026#34;\\u001b[33m\u0026#34; ColorBlue = \u0026#34;\\u001b[34m\u0026#34; ColorReset = \u0026#34;\\u001b[0m\u0026#34; ) func colorize(color Color, message string) { fmt.Println(string(color), message, string(ColorReset)) } func main() { useColor := flag.Bool(\u0026#34;color\u0026#34;, false, \u0026#34;display colorized output\u0026#34;) flag.Parse() if *useColor { colorize(ColorBlue, \u0026#34;Hello, DigitalOcean!\u0026#34;) return } fmt.Println(\u0026#34;Hello, DigitalOcean!\u0026#34;) } 这个例子使用ANSI 逃逸序列来指示终端显示彩色输出。这些是专门的 character 序列，所以为它们定义一个新的类型是有意义的(L8)。在这个例子中，我们称该类型为color，并将该类型定义为string。然后我们定义了一个调色板，在后面的 const 块中使用。定义在const块之后的colorize函数接受Color常量其中之一和一个string，用于对信息进行着色。然后它指示终端改变颜色，首先打印所要求的颜色的转义序列，然后打印信息，最后要求终端通过打印特殊的颜色重置序列来重置其颜色。\n在main中，我们使用flag.Bool函数来定义一个名为color的 Boolean 标志。这个函数的第二个参数，false，在没有提供这个标志的情况下，设置这个标志的默认值。与你可能有的期望相反，将其设置为true并不会颠倒行为，如提供一个标志会导致它变成 false。因此，这个参数的值在布尔标志下几乎总是false。\n最后一个参数是一个可以作为使用信息打印出来的文档 string。从这个函数返回的值是一个指向bool的指针。下一行的flag.Parse函数使用这个指针，然后根据用户传入的标志，设置bool变量。 然后我们就可以通过取消引用这个指针来检查这个bool指针的值。更多关于指针变量的信息可以在指针教程找到。使用这个 Boolean，我们就可以在设置-color标志时调用colorize，而在没有这个标志时调用fmt.Println变量。\n保存文件，并在未传入没有任何标志的情况下运行该程序：\ngo run boolean.go 你将会看到如下输出：\nOutput Hello, DigitalOcean! 现在带上-color标志再跑一遍程序：\ngo run boolean.go -color 输出文本会是一样的，只不过这时候颜色时蓝色的。\n标志不是传递给命令的唯一参数。你也能发送文件名或其他数据。\n使用位置参数 # 通常情况下，命令会接受一些参数，这些参数作为命令的重点对象。例如，打印文件第一行的head命令经常被以head example.txt调用。文件example.txt是调用head命令时的一个位置参数。\nParse()函数将一直解析它所遇到的标志，直到它检测到一个非标志参数。flag包通过Args()和Arg()函数使这些参数可用。\n为了阐述这一点，你将重新实现一个简化的head命令，它显示一个给定文件的前几行：\n创建一个新的文件称为head.go，然后添加如下代码：\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { var count int flag.IntVar(\u0026amp;count, \u0026#34;n\u0026#34;, 5, \u0026#34;number of lines to read from the file\u0026#34;) flag.Parse() var in io.Reader if filename := flag.Arg(0); filename != \u0026#34;\u0026#34; { f, err := os.Open(filename) if err != nil { fmt.Println(\u0026#34;error opening file: err:\u0026#34;, err) os.Exit(1) } defer f.Close() in = f } else { in = os.Stdin } buf := bufio.NewScanner(in) for i := 0; i \u0026lt; count; i++ { if !buf.Scan() { break } fmt.Println(buf.Text()) } if err := buf.Err(); err != nil { fmt.Fprintln(os.Stderr, \u0026#34;error reading: err:\u0026#34;, err) } } 首先，我们定义了一个count变量，用来保存程序应该从文件中读取的行数。然后，我们使用flag.IntVar定义-n标志，模拟原始head程序的行为。 这个函数允许我们将自己的pointer传递给一个变量，与没有Var后缀的标志函数相反。除了这个区别之外，flag.IntVar的其他参数与flag.Int对应的参数相同：标志名称、默认值和描述。 和前面的例子一样，我们随后调用flag.Parse()来处理用户的输入。\n下一节读取文件。我们首先定义一个io.Reader变量，该变量将被设置为用户请求的文件，或传递给程序的标准输入。在if语句中，我们使用flag.Arg函数来访问所有标志之后的第一个位置参数。如果用户提供了文件名，这个位置参数会被设置。否则，它将为空 string(\u0026quot;\u0026quot;)。当文件名提供时，我们使用os.Open函数来打开该文件，并将我们之前定义的io.Reader设置为该文件。否则，我们使用os.stdin来读取标准输入。\n最后一节使用一个用bufio.NewScanner创建的*bufio.Scanner从io.Reader变量in中读取行数据。我们使用forloop遍历到 count 的值，如果用buf.Scan扫描该行结果为false，则调用break，表示行数少于用户要求的数量。\n运行这个程序，用head.go作为文件参数，显示你刚才写的文件的内容：\ngo run head.go -- head.go --分隔符是一个被flag包识别的特殊标志，它表示后面没有更多的 flag 参数。当你运行这个命令时，你会收到以下输出：\nOutput package main import ( \u0026#34;bufio\u0026#34; \u0026#34;flag\u0026#34; 使用你定义的-n标志来调整输出的数量：\ngo run head.go -n 1 head.go 这只输出包的声明：\nOutput package main 最后，当程序检测到没有提供位置参数时，它从标准输入中读取输入，就像head一样。试着运行这个命令：\necho \u0026#34;fish\\nlobsters\\nsharks\\nminnows\u0026#34; | go run head.go -n 3 你将会看到如下输出：\nOutput fish lobsters sharks 到目前为止，你所看到的flag函数的行为仅限于检查整个命令的调用。你并不总是想要这种行为，特别是当你在编写一个支持子命令的命令行工具时。\n用 FlagSet 来实现子命令 # 现代的命令行应用程序经常实现 \u0026ldquo;子命令\u0026rdquo;，将一套工具捆绑在一个命令之下。使用这种模式的最著名的工具是git。 当检查像git init这样的命令时，git是命令，init是 git 的子命令。子命令的一个显著特点是，每个子命令可以有自己的标志集合。\nGo 应用程序可以使用flag.(*FlagSet)类型支持具有自己的标志集的子命令。为了阐述这一点，创建一个程序，使用两个具有不同标志的子命令来实现一个命令。\n创建一个名为subcommand.go的新文件，并在该文件中添加以下内容：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func NewGreetCommand() *GreetCommand { gc := \u0026amp;GreetCommand{ fs: flag.NewFlagSet(\u0026#34;greet\u0026#34;, flag.ContinueOnError), } gc.fs.StringVar(\u0026amp;gc.name, \u0026#34;name\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;name of the person to be greeted\u0026#34;) return gc } type GreetCommand struct { fs *flag.FlagSet name string } func (g *GreetCommand) Name() string { return g.fs.Name() } func (g *GreetCommand) Init(args []string) error { return g.fs.Parse(args) } func (g *GreetCommand) Run() error { fmt.Println(\u0026#34;Hello\u0026#34;, g.name, \u0026#34;!\u0026#34;) return nil } type Runner interface { Init([]string) error Run() error Name() string } func root(args []string) error { if len(args) \u0026lt; 1 { return errors.New(\u0026#34;You must pass a sub-command\u0026#34;) } cmds := []Runner{ NewGreetCommand(), } subcommand := os.Args[1] for _, cmd := range cmds { if cmd.Name() == subcommand { cmd.Init(os.Args[2:]) return cmd.Run() } } return fmt.Errorf(\u0026#34;Unknown subcommand: %s\u0026#34;, subcommand) } func main() { if err := root(os.Args[1:]); err != nil { fmt.Println(err) os.Exit(1) } } 这个程序分为几个部分：main函数，root函数，以及实现子命令的各个函数。main函数处理从命令返回的错误。如果任何函数返回错误，if语句将捕捉到它，打印出错误，程序将以1的状态码退出，向操作系统的其他部分表明发生了错误。在main中，我们将程序被调用的所有参数传递给root。我们通过先将os.Args切片来删除第一个参数，也就是程序的名称（在前面的例子中是./subcommand）。\nroot函数定义了[]Runner，所有的子命令都会在这里定义。Runner是一个子命令的 interface ，允许root使用Name()获取子命令的名称，并将其与变量subcommand内容进行比较。一旦在遍历cmds变量后找到了正确的子命令，我们就用其余的参数初始化子命令，并调用该命令的Run()方法。\n我们只定义了一个子命令，尽管这个框架很容易让我们创建其他子命令。GreetCommand是使用NewGreetCommand实例化的，在这里我们使用flag.NewFlagSet创建一个新的*flag.FlagSet。flag.NewFlagSet需要两个参数：一个标志集的名称，和一个报告解析错误的策略。用flag.(*FlagSet).Name方法获取*flag.FlagSet的名称。我们在(*GreetCommand).Name()方法中使用这个方法，所以子命令的名字与我们给*flag.FlagSet的名字一致。 NewGreetCommand也用了类似于以前的例子的方式定义了一个-name标志，但它改为从*GreetCommand的*flag.FlagSet字段中调用这个方法，gc.fs。当root调用*GreetCommand的Init()方法时，我们将传入的参数传递给*flag.FlagSet字段的Parse方法。\n如果你构建这个程序，然后运行它，就会更容易看到子命令。建立该程序：\ngo build subcommand.go 现在运行该程序，没有参数：\n./subcommand 你会看到如下输出：\nOutput You must pass a sub-command 现在用greet子命令运行该程序。\n./subcommand greet 这会输出如下内容：\nOutput Hello World ! 现在使用-name标志和greet来指定一个名字：\n./subcommand greet -name Sammy 你会看到程序给出的这个输出：\nOutput Hello Sammy ! 这个例子说明了在 Go 中如何构建大型命令行应用程序的一些原则。 FlagSets的设计是为了给开发者提供更多的控制权，使其能够通过 flag 解析逻辑，分析flag的位置和处理方式。\n总结 # 标记使你的应用程序在更多情景下更有用，因为它们让你的用户控制程序的执行方式。给用户提供有用的默认值很重要，但你应该让他们有机会覆盖那些不适合他们情况的设置。你已经看到，flag包提供了灵活的选择，向你的用户展示配置选项。你可以选择一些简单的标志，或者建立一套可扩展的子命令。 无论是哪种情况，在过去长久历史沉淀的风格下，使用flag包都可以帮助你按照灵活的、可编写脚本的命令行工具。\n"},{"id":40,"href":"/How-To-Code-in-Go/docs/41-How_to_Use_Go_Modules/","title":"41 How to Use Go Modules","section":"Docs","content":" 如何使用 Go 模块 # 简介 # 在 1.13 版本，Go 的作者增加了一种管理 Go 项目依赖库的新方法，称之为 Go 模块。Go 模块的加入是为了满足日益增长的需求，使开发者更容易维护其依赖的各种版本，同时也为开发者在计算机上组织项目的方式上，增加了更多的灵活性。Go 模块通常由一个项目或库组成，并包含一系列的 Go 包，然后一起发布。Go 模块解决了原始系统 GOPATH 的许多问题，它允许用户将项目代码放在他们选择的目录中，并为每个模块指定依赖的版本。\n在本教程中，你将创建你自己的公共 Go module，并为你的新模块添加一个包。此外，你还将把别人的公共模块添加到你自己的项目中，以及把该模块的一个特定版本添加到你的项目中。\n前期准备 # 要遵循本教程，你将需要：\n安装1.16 或更高版本的 Go。如何安装 Go ，请根据你的操作系统遵循 如何安装Go 教程。 熟悉用 Go 编写软件包。要了解更多，请遵循 如何用 Go 编写包 教程。 创建一个新的模块 # 乍看之下，Go模块与 Go包 有些相似。一个模块有许多实现包的功能的 Go 代码文件，但它在根部还有两个额外的重要文件：go.mod 文件和 go.sum 文件。这些文件包含了 go 工具用来跟踪你的模块配置的信息，通常由工具维护，所以你不需要维护。\n首先要做的是决定模块所处的目录。随着 Go 模块的引入，Go 项目有可能位于文件系统的任何地方，而不仅仅是 Go 定义的特定目录。你可能已经有了一个存放项目的目录，但在本教程中，你将创建一个名为 projects 的目录，新模块将被称为 mymodule。你可以通过 IDE 或者命令行来创建 projects 目录。\n如果你使用的是命令行，首先新建 projects目录并进入其中：\nmkdir projects cd projects 接下来，你将创建模块目录本身。通常，模块的顶层目录名称与模块名称相同，这使得模块配置的信息更容易被追踪。在你的 projects 目录下，运行以下命令来创建 mymodule 目录：\nmkdir mymodule 一旦你创建了模块目录，目录结构将看起来像这样：\n└── projects └── mymodule 下一步是在 mymodule 目录下创建一个 go.mod 文件来定义 Go 模块本身。要做到这一点，你要使用 go 工具的 mod init 命令，并向它提供模块的名称，在这个例子中是 mymodule。现在通过在 mymodule 目录下运行 go mod init 来创建模块，并向它提供模块的名称 mymodule：\ngo mod init mymodule 该命令在创建模块时将返回以下输出：\nOutput go: creating new go.mod: module mymodule 随着模块的创建，你的目录结构现在看起来会是这样：\n└── projects └── mymodule └── go.mod 现在你已经创建了一个模块，让我们看一下 go.mod 文件的内容，看看 go mod init 命令做了什么。\n了解 go.mod 文件 # 当你用 go 工具运行命令时，go.mod 文件是一个非常重要的部分。它是包含模块名称和你自己模块所依赖的其他模块的版本的文件。它还可以包含其他指令，如 replace，这对同时进行多个模块的开发很有帮助。\n在 mymodule 目录下，用 nano 或你喜欢的文本编辑器打开 go.mod 文件：\nnano go.mod 内容将看起来与此类似，这并不重要：\nprojects/mymodule/go.mod\nmodule mymodule go 1.16 第一行，module 指令，告诉 Go 你的模块名称，这样当它在包中寻找 import 路径时，它就不会在其他地方寻找 mymodule。mymodule 的值来自你传递给 go mod init 的参数：\nmodule mymodule 文件中的另外一行，即 go 指令，告诉 Go 模块所针对的语言版本。在本例中，由于该模块是用 Go 1.16 创建的，所以 go 指令显示为 1.16 ：\ngo 1.16 随着更多的信息被添加到模块中，这个文件将被扩展，但现在看看它是个好主意，看看它是如何随着依赖关系的进一步添加而变化的。\n现在你已经用 go mod init 创建了一个 Go 模块，并查看了初始 go.mod 文件的内容，但你的模块还没有做任何事情。现在是时候让你的模块更进一步，添加一些代码了。\n在你的模块中添加Go代码 # 为了确保模块被正确创建，并添加代码以便你能运行你的第一个 Go 模块，你将在 mymodule 目录下创建一个 main.go 文件。main.go 文件在 Go 程序中通常用来表示程序的起始点。该文件的名称并不像里面的 main 函数那么重要，但两者的匹配使其更容易被找到。在本教程中，main 函数在运行时将打印出 Hello, Modules!。\n要创建这个文件，用 nano 或你喜欢的文本编辑器打开 main.go 文件：\nnano main.go 在 main.go 文件中，添加以下代码来定义你的 main 包，导入 fmt 包，然后在 main 函数中打印出 Hello, Modules!信息：\nprojects/mymodule/main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, Modules!\u0026#34;) } 在 Go 中，每个目录都被视为自己的包，每个文件都有自己的 package 声明行。在你刚刚创建的 main.go 文件中，包 被命名为 main。通常情况下，你可以以任何方式命名包，但 main 包在 Go 中是很特别的。当 Go 看到一个包被命名为 main 时，它知道这个包应该被视为二进制文件，应该被编译成可执行文件，而不是一个旨在用于其他程序的库。\n在定义了 包 之后，import 声明说要导入 fmt 包，所以你可以使用它的 Println 函数将 \u0026quot;Hello, Modules!\u0026quot; 信息打印到屏幕上。\n最后，定义了 main 函数。main 函数是 Go 的另一个特例，与main包有关。当 Go 看到一个名为 main 的包内有一个名为 main 的函数时，它知道 main 函数是它应该运行的第一个函数。这被称为程序的入口点。\n一旦你创建了 main.go 文件，该模块的目录结构将类似于这样：\n└── projects └── mymodule └── go.mod └── main.go 如果你熟悉使用 Go 和 GOPATH ，运行模块中的代码就类似于从 GOPATH 中的一个目录中进行。（如果你不熟悉 GOPATH 也不用担心，因为使用模块可以代替它的使用。）\n在 Go 中运行可执行程序有两种常见的方法：用 go build 构建二进制文件或用 go run 运行文件。在本教程中，你将使用 go run 直接运行模块，而不是构建二进制文件，后者必须单独运行。\n用 go run 运行你创建的 main.go 文件：\ngo run main.go 运行该命令将打印代码中定义的 Hello, Modules! 文本：\nOutput Hello, Modules! 在这一节中，你为你的模块添加了一个 main.go 文件，其中的初始 main 函数打印出 Hello, Modules!。在这一点上，你的程序还没有从 Go 模块中获益—它可以是你电脑上任何地方的一个文件，用 go run 来运行。Go 模块的第一个真正好处是能够在任何目录下为你的项目添加依赖，而不仅仅是 GOPATH 目录结构。你还可以向你的模块添加包。在下一节中，你将通过在模块中创建一个额外的包来扩展你的模块。\n为你的模块添加一个包 # 类似于标准的 Go 包，一个模块可以包含任何数量的包和子包，也可以完全不包含。在这个例子中，你将在 mymodule 目录下创建一个名为 mypackage 的包。\n通过在 mymodule 目录下运行 mkdir 命令并加上 mypackage 参数来创建这个新包：\nmkdir mypackage 这将创建新的目录 mypackage 作为 mymodule 目录的一个子包：\n└── projects └── mymodule └── mypackage └── main.go └── go.mod 使用 cd 命令将当前目录改为新的 mypackage 目录，然后使用 nano ，或你喜欢的文本编辑器，创建一个 mypackage.go 文件。这个文件可以有任何名字，但使用与软件包相同的名字可以更容易找到软件包的主文件：\ncd mypackage nano mypackage.go 在 mypackage.go 文件中，添加一个名为 PrintHello 的函数，当被调用时，将打印 Hello, Modules! This is mypackage speaking! ：\nprojects/mymodule/mypackage/mypackage.go\npackage mypackage import \u0026#34;fmt\u0026#34; func PrintHello() { fmt.Println(\u0026#34;Hello, Modules! This is mypackage speaking!\u0026#34;) } 由于你希望 PrintHello 函数可以从另一个包中使用，函数名称中的大写字母 P 很重要。大写字母意味着该函数是导出的，对任何外部程序都是可用的。关于 Go 中包的可见性的更多信息，Understanding Package Visibility in Go 包括更多细节。\n现在你已经创建了带有导出函数的 mypackage 包，你将需要从 mymodule 包中 导入 它来使用它。这与你导入其他包的方法类似，比如之前的 fmt 包，只是这次你要在导入路径的开头加入你的模块名称。从 mymodule 目录下打开你的 main.go 文件，通过添加下面高亮的行来添加对 PrintHello 的调用：\nprojects/mymodule/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;mymodule/mypackage\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, Modules!\u0026#34;) mypackage.PrintHello() } 如果你仔细看一下 import 语句，你会看到新的导入以 mymodule 开始，也就是你在 go.mod 文件中设置的模块名称。后面是路径分隔符和你要导入的包，本例中是mypackage：\n\u0026#34;mymodule/mypackage\u0026#34; 在未来，如果你在 mypackage 内添加包，你也会以类似的方式将它们添加到导入路径的末尾。例如，如果你在 mypackage 内有另一个叫 extrapackage 的包，你对该包的导入路径将是 mymodule/mypackage/extrapackage。\n像以前一样，用go run 和 main.go 从 mymodule 目录中运行你的更新模块：\ngo run main.go 当你再次运行该模块时，你会看到先前的 \u0026ldquo;Hello, Modules!\u0026ldquo;信息，以及新的 mypackage 的 PrintHello 函数打印的新信息：\nOutput Hello, Modules! Hello, Modules! This is mypackage speaking! 你现在通过创建一个名为 mypackage 的目录和 PrintHello 函数，为你的初始模块添加了一个新包。随着你的模块功能的扩展，在你的模块中开始使用其他人的模块可能会很有用。在下一节中，你将添加一个远程模块作为你的模块的依赖。\n添加一个远程模块作为依赖 # Go 模块是通过版本控制库（通常是Git库）发布的。当你想添加一个新的模块作为自己的依赖时，你会使用仓库的路径作为你想使用的模块的引用方式。当 Go 看到这些模块的导入路径时，它可以根据这个仓库的路径推断出在哪里可以远程找到它。\n在这个例子中，你要在你的模块中加入对 github.com/spf13/cobra 库的依赖。Cobra 是一个常用来创建控制台应用程序的库，但我们不会在本教程中讨论这个问题。\n与你创建 mymodule 模块时类似，你将再次使用 go 工具。然而，这一次，你将在 mymodule 目录下运行 go get 命令。运行 go get 并提供你想添加的模块。在这种情况下，你会得到 github.com/spf13/cobra ：\ngo get github.com/spf13/cobra 当你运行这个命令时，go 工具将从你指定的路径查找 Cobra 仓库，并通过查看仓库的分支和标签来确定哪个版本的 Cobra 是最新的。然后，它将下载该版本，并通过在 go.mod 文件中添加模块名称和版本来跟踪它所选择的版本，以供将来参考。\n现在，打开 mymodule 目录下的 go.mod 文件，看看当你添加新的依赖时，go 工具如何更新 go.mod 文件。下面的例子可能会有变化，这取决于当前已经发布的 Cobra 版本或你使用的 Go 工具的版本，但整体的变化结构应该是相似的：\nprojects/mymodule/go.mod\nmodule mymodule go 1.16 require ( github.com/inconshreveable/mousetrap v1.0.0 // indirect github.com/spf13/cobra v1.2.1 // indirect github.com/spf13/pflag v1.0.5 // indirect ) 增加了一个使用 require 指令的新部分。这个指令告诉 Go 你想要哪个模块，比如 github.com/spf13/cobra，以及你添加的模块的版本。有时 require 指令也会包括一个//间接注释。这个注释表示，在添加 require 指令时，该模块没有在该模块的任何源文件中被直接引用。文件中还增加了一些额外的 require 行。这些行是 Cobra 所依赖的其他模块，Go 工具认为这些模块也应该被引用。\n你可能还注意到，在运行 go run 命令后，在 mymodule 目录下创建了一个新的文件，go.sum 。这是 Go 模块的另一个重要文件，包含了 Go 用来记录依赖关系的具体哈希值和版本的信息。这确保了依赖关系的一致性，即使它们被安装在不同的机器上。\n一旦你下载了依赖关系，你要用一些最小的 Cobra 代码更新你的 main.go 文件，以使用新的依赖关系。用下面的Cobra 代码更新 mymodule 目录下的 main.go 文件，以使用新的依赖性：\nprojects/mymodule/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cobra\u0026#34; \u0026#34;mymodule/mypackage\u0026#34; ) func main() { cmd := \u0026amp;cobra.Command{ Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;Hello, Modules!\u0026#34;) mypackage.PrintHello() }, } fmt.Println(\u0026#34;Calling cmd.Execute()!\u0026#34;) cmd.Execute() } 这段代码创建了一个 cobra.Command 结构，其中的 Run 函数包含你现有的 \u0026ldquo;Hello\u0026rdquo; 语句，然后将通过调用 cmd.Execute() 来执行。现在，运行更新后的代码：\ngo run main.go 你会看到下面的输出，它看起来与你之前看到的相似。不过这一次，它使用了你的新的依赖关系，如 Calling cmd.Execute()! 一行所示：\nOutput Calling cmd.Execute()! Hello, Modules! Hello, Modules! This is mypackage speaking! 使用 go get 来添加远程依赖的最新版本，例如这里的 github.com/sp13/cobra ，使你的依赖更容易保持最新的错误修复。然而，有时你可能更愿意使用一个特定版本的模块、一个版本库标签或一个版本库分支。在下一节中，你将使用 go get 来引用这些版本，当你想要这个选项时。\n使用一个模块的特定版本 # 由于 Go 模块是从版本控制库中发布的，它们可以使用版本控制功能，如标签、分支、甚至 commits 。你可以在你的依赖关系中使用@符号在模块路径的末尾加上你想使用的版本来引用这些。早些时候，当你安装最新版本的Cobra 时，你正在利用这种能力，但你不需要在命令中明确添加它。go 工具知道，如果没有用@提供特定的版本，它应该使用特殊的版本 latest 。latest 版本实际上并不在版本库中，就像 my-tag 或 my-branch 可能是一样。它作为一个辅助工具内置于 go 工具中，所以你不需要自己去搜索最新的版本。\n例如，当你最初添加你的依赖关系时，你也可以使用下面的命令获得同样的结果：\ngo get github.com/spf13/cobra@latest 现在，想象有一个你使用的模块，目前正在开发中。在这个例子中，称它为 your_domain/sammy/awesome 。这个 awesome 模块正在增加一个新的功能，工作在一个叫做 new-feature 的分支中进行。要把这个分支作为你自己的模块的依赖项，你可以向 go get 提供模块的路径，后面是@符号，再后面是分支的名称：\ngo get your_domain/sammy/awesome@new-feature 运行这个命令会使 go 连接到 your_domain/sammy/awesome 仓库，下载 new-feature 分支的当前最新提交，并将该信息添加到 go.mod 文件。\n不过，分支并不是唯一可以使用@选项的方式。这个语法可以用于标签，甚至是版本库的特定提交。例如，有时你正在使用的库的最新版本可能有一个坏的提交。在这种情况下，引用破损提交之前的提交可能会很有用。\n以你的模块所依赖的 Cobra 为例，假设你需要引用 github.com/spf13/cobra 的 07445ea 提交，因为它有一些你需要的修改，而你因为某些原因不能使用其他版本。在这种情况下，你可以在@符号后面提供提交哈希值，就像对分支或标签一样。在你的 mymodule目 录下运行go get命令，输入模块和版本来下载新版本：\ngo get github.com/spf13/cobra@07445ea 如果你再次打开你模块的 go.mod 文件，你会看到 go get 已经更新了 github.com/spf13/cobra 的require行，引用你指定的提交：\nprojects/mymodule/go.mod\nmodule mymodule go 1.16 require ( github.com/inconshreveable/mousetrap v1.0.0 // indirect github.com/spf13/cobra v1.1.2-0.20210209210842-07445ea179fc // indirect github.com/spf13/pflag v1.0.5 // indirect ) 由于提交是一个特定的时间点，与标签或分支不同，Go在 require 指令中包含了额外的信息，以确保它在未来使用正确的版本。如果你仔细看一下版本，你会发现它确实包括你提供的提交散列。v1.1.2-0.20210209210842-07445ea179fc.\nGo 模块也使用这个功能来支持发布不同版本的模块。当 Go 模块发布新版本时，一个新的标签会被添加到版本库中，并以版本号作为标签。如果你想使用一个特定的版本，你可以查看版本库中的标签列表，找到你要找的版本。如果你已经知道版本，你可能不需要在标签中搜索，因为版本标签的命名是一致的。\n再以 Cobra 为例，假设你想使用 Cobra 1.1.1 版本。你可以查看 Cobra 仓库，发现它有一个名为 v1.1.1 的标签，还有其他标签。要使用这个标记的版本，你可以在 go get 命令中使用 @ 符号，就像你使用一个非版本标记或分支。现在，通过运行以 v1.1.1 为版本的 go get 命令，更新你的模块以使用 Cobra 1.1.1：\ngo get github.com/spf13/cobra@v1.1.1 现在，如果你打开你的模块的 go.mod 文件，你会看到 go get 已经更新了 github.com/spf13/cobra 的require 行，引用你提供的版本：\nprojects/mymodule/go.mod\nmodule mymodule go 1.16 require ( github.com/inconshreveable/mousetrap v1.0.0 // indirect github.com/spf13/cobra v1.1.1 // indirect github.com/spf13/pflag v1.0.5 // indirect ) 最后，如果你正在使用一个特定版本的库，例如 07445ea 提交或早期的 v1.1.1 ，但你确定你宁愿开始使用最新版本，可以通过使用特殊的 latest 版本来实现。要将你的模块更新到最新版本的 Cobra，请再次运行 go get，输入模块路径和 latest 版本：\ngo get github.com/spf13/cobra@latest 一旦这个命令完成，go.mod 文件将更新为你引用特定版本的 Cobra 之前的样子。根据你的 Go 版本和当前最新的Cobra 版本，你的输出可能会略有不同，但你仍然应该看到 require 部分的 github.com/spf13/cobra 行再次更新为最新版本：\nmodule mymodule go 1.16 require ( github.com/inconshreveable/mousetrap v1.0.0 // indirect github.com/spf13/cobra v1.2.1 // indirect github.com/spf13/pflag v1.0.5 // indirect ) go get 命令是一个强大的工具，你可以用它来管理 go.mod 文件中的依赖关系，而不需要手动编辑它。正如你在本节中看到的，在模块名称中使用 @ 字符可以让你使用模块的特定版本，从发布版本到特定的版本库提交。它甚至可以用来回到你的依赖的 latest 版本。使用这些选项的组合将使你能够确保你的程序在未来的稳定性。\n总结 # 在本教程中，你创建了一个带有子包的 Go 模块，并在你的模块中使用该包。你还将另一个模块作为依赖关系添加到你的模块中，并探索了如何以各种方式引用模块版本。\n关于 Go 模块的更多信息，Go 项目有一系列博文介绍 Go 工具如何与模块互动和理解模块。Go 项目还在 Go模块参考 中为 Go 模块提供了非常详细的技术参考。\n本教程也是 DigitalOceanHow to Code in Go 系列教程的一部分。该系列涵盖了许多 Go 主题，从首次安装 Go 到如何使用语言本身。\n"},{"id":41,"href":"/How-To-Code-in-Go/docs/42-How_to_Distribute_Go_Modules/","title":"42 How to Distribute Go Modules","section":"Docs","content":" 如何分发 Go 模块 # 简介 # 许多现代编程语言允许开发人员分发现成的库，供他人在其程序中使用，Go 也不例外。虽然有些语言使用核心仓库来安装这些库，但 Go 从用于创建库的同一版本控制仓库中分发这些库。Go 还使用了一个称为语义版本管理的版本管理系统，向用户展示什么时候做了什么修改。这可以帮助用户知道一个模块的较新版本是否足够安全地去快速更新上去，同时有助于确保他们的软件继续与该模块一起运行下去。\n在本教程中，你将创建并发布一个新的模块，学习使用语义版本管理，并发布模块的语义版本。\n前期准备 # 安装1.16 或更高版本的 Go。如何安装 Go ，请根据你的操作系统遵循 如何安装Go 教程。 理解 Go 的模块，你可以参考如何使用Go模块的教程。 熟悉Git，你可以参考 How To Use Git: A Reference Guide 。 一个空的 GitHub 公共仓库，名为pubmodule，用于你发布的模块。开始使用前，请遵循 GitHub 创建仓库的文档。 创建一个要发布的模块 # 与许多其他编程语言不同，Go 模块直接从其所在的源代码库中发布，而不是从独立的软件包库中发布。这使用户更容易找到他们代码中引用的模块，也使模块维护者更容易发布他们模块的新版本。在本节中，你将创建一个新的模块，然后将其发布给其他用户使用。\n为了开始创建你的模块，作为先决条件的一部分，你将在你创建的空仓库上使用 git clone 下载初始仓库。这个仓库可以在你的电脑上的任何地方克隆，但许多开发者倾向于为他们的项目设置一个目录。在本教程中，你将使用一个名为 projects 的目录。\n创建 projects 目录并进入：\nmkdir projects cd projects 在 projects 目录下，运行 git clone 将你的仓库克隆到你的电脑上：\ngit clone git@github.com:your_github_username/pubmodule.git 克隆模块将下载你的空模块到 pubmodule 而不是 projects 目录。你可能会得到一个警告，说你克隆了一个空的仓库，但这并不值得担心：\nOutput Cloning into \u0026#39;pubmodule\u0026#39;... warning: You appear to have cloned an empty repository. 接下来，进入到你下载到目录：\ncd pubmodule 一旦你进入了模块目录，你将使用 go mod init 来创建你的新模块，并将仓库的位置作为模块名称传入。确保模块名称与仓库的位置一致是很重要的，因为这是在其他项目使用你的模块时，go 工具能准确找到下载位置的依据。\ngo mod init github.com/your_github_username/pubmodule Go 会确认你的模块已经创建，让你知道它已经创建了 go.mod 文件:\nOutput go: creating new go.mod: module github.com/your_github_username/pubmodule 最后，使用你喜欢的文本编辑器，如 nano ，创建并打开一个与你的仓库同名的文件：pubmodule.go。\nnano pubmodule.go 这个文件的名字可以是任何东西，但使用与包相同的名字，可以使你在处理一个不熟悉的软件包时更容易知道从哪里开始。不过，包的名字本身应该与你的仓库名称相同。这样，当有人从你的包中引用一个方法或类型时，就会与仓库相匹配，如 pubmodule.MyFunction 。这将使他们更容易知道这个包来自哪里，以备他们以后需要参考。\n接下来，给你的包添加一个 Hello 方法，它将返回字符串 Hello, You! 。这将是任何导入你的包的人都可以使用的功能。\nprojects/pubmodule/pubmodule.go\npackage pubmodule func Hello() string { return \u0026#34;Hello, You!\u0026#34; } 你现在使用 go mod init 创建了一个新模块，模块名称与你的远程仓库（github.com/your_github_username/pubmodule）一致。你还为你的模块添加了一个名为 pubmodule.go 的文件，其中有一个名为 Hello 的函数，引用模块的用户可以调用。接下来，你将发布你的模块，使其对其他人可用。\n发布模块 # 一旦你创建了一个本地模块，并准备将其提供给其他用户，就该发布你的模块了。由于 Go 模块是从它们所存放的代码库中发布的，你要把你的代码提交到你的本地Git仓库，然后推送到你的仓库github.com/your_github_username/pubmodule。\n在提交代码到本地 Git 仓库之前，最好先确定不会提交任何你不期望提交的文件，这些文件在你推送代码到 GitHub 时就会公开发布。在 pubmodule 目录下使用 git status 命令会显示所有将要提交的文件和修改：\ngit status 输出结果将类似于这样:\nOutput On branch main No commits yet Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) go.mod pubmodule.go 你应该看到 go mod init 命令创建的 go.mod 文件，以及你创建 Hello 函数的 pubmodule.go 文件。根据你创建仓库的方式，你可能有一个与此输出不同的分支名称。最常见的是，名字是 main 或 master。\n当你确定只有你要找的文件时，你就可以用 git add 将文件阶段性提交，用 git commit 将它们提交到仓库:\ngit add . git commit -m \u0026#34;Initial Commit\u0026#34; 输出结果将类似于这样：\nOutput [main (root-commit) 931071d] Initial Commit 2 files changed, 8 insertions(+) create mode 100644 go.mod create mode 100644 pubmodule.go Finally, use the git push command to push your module to the GitHub repository:\n最后，使用 git push 命令将你的模块推送到 GitHub 仓库：\ngit push 输出结果将类似于这样：\nOutput Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 8 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (4/4), 367 bytes | 367.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:your_github_username/pubmodule.git * [new branch] main -\u0026gt; main 运行 git push 命令后，你的模块将被推送到你的仓库，可以供其他人使用了。如果你没有发布任何版本，Go 将使用你的仓库的默认分支中的代码作为你的模块的代码。你的默认分支是否被命名为 main、master 或其他名称并不重要，重要的是你的仓库的默认分支被设置为什么。\n在这一节中，你把你创建的本地 Go 模块发布到 GitHub 仓库，让其他人可以使用。虽然你现在有了一个发布的模块，但维护公共模块的另一个部分是确保使用你模块的用户可以使用它的稳定版本。你很可能想在未来对你的模块进行修改和添加功能，但如果你在模块中不使用版本而进行这些修改，你可能会意外地破坏使用你的模块的人的代码。为了解决这个问题，当你在开发中达到一个新的里程碑时，你可以向你的模块添加版本。不过在添加新的版本时，一定要选择一个有意义的版本号，这样你的用户就能知道他们是否可以马上升级，是否安全。\n语义版本管理 # 一个有意义的版本号可以让您的用户了解他们所交互的公共接口或API发生了多大的变化。Go 通过一种被称为 语义版本管理 ，或简称为 SemVer 的版本方案来传达这些变化。(语义版本管理使用版本字符串来传达关于代码变化的意义，这就是语义版本管理的名字来源)。Go 的模块系统遵循 SemVer 来确定哪些版本比你当前使用的版本要新，以及某个模块的较新版本是否可以自动升级为安全版本。\n语义版本管理为版本字符串中的每个数字赋予了意义。SemVer 中的典型版本包含三个主要数字：主版本、次版本和补丁版本。这些数字中的每一个都与\u0026quot;. \u0026ldquo;组合在一起，形成版本，例如 1.2.3 。这些数字的顺序是：主要版本在前，次要版本在后，补丁版本在最后。这样，当看一个版本时，你可以看到哪个版本是较新的，因为特定位置的数字比以前的版本要高。例如，2.2.3 版本比 1.2.3 版本要新，因为主要版本更高。同样地，版本 1.4.3比 1.2.10 新，因为次要版本更高。尽管在补丁版本中 10 比 3 高，但次要版本 4 比 2 高，所以该版本优先。当版本字符串中的一个数字增加时，所有跟在它后面的其他版本部分都会重置为0。例如，增加次要版本 1.3.10 会导致 1.4.0 ，增加主要版本 2.4.1 会导致 3.0.0 。\n使用这些规则可以让 Go 在运行 go get 时决定使用哪个版本的模块。举个例子，假设你有一个项目使用 1.4.3版本的模块，github.com/your_github_username/pubmodule。如果你依赖 pubmodule 是稳定的，你可能只想自动升级补丁版本（即 .3 ）。如果你运行命令 go get -u=patch github.com/your_github_username/pubmodule ，Go 会看到你想升级模块的补丁版本，并且只会寻找以1.4作为版本主要和次要部分的新版本。\n在创建你的模块的新版本时，重要的是要考虑你的模块的公共 API 是如何变化的。语义版本字符串的每一部分都向你和你的用户传达了 API 变化的范围。这些类型的变化通常分为三个不同的类别，与版本的每个组成部分排成一列。最小的变化会增加补丁版本，中等规模的变化会增加次要版本，而最大的变化则会增加主要版本。使用这些类别来决定增加哪个版本号将帮助你避免破坏你自己的代码，以及其他依赖你的模块的人的代码。\n主要版本号 # SemVer 版本中的第一个数字是主版本号（1.4.3 ）。主版本号是模块发布新版本时，需要考虑的最重要数字。一个主要的版本变化是用来表示你的公共 API 向后不兼容的变化。一个向后不兼容的变化是指你的模块中的任何变化，如果他们在没有做任何其他改变的情况下升级，会导致别人的程序崩溃。破坏可能意味着任何事情，包括因为函数名称改变而无法构建，或者因为库的工作方式改变而导致同一方法返回 v1而不是 1。但这只适用于你的公共 API，也就是说，任何出口的类型或方法，别人都可以使用。如果这个版本只包括你的库的用户不会注意到的改进，它不需要一个主要的版本变化。记住哪些变化符合这个类别的方法是，任何被认为是 \u0026ldquo;更新 \u0026ldquo;或 \u0026ldquo;删除 \u0026ldquo;的东西都是一个主要的版本增加。\n**注意：**与 SemVer 中其他类型的数字不同，主要版本 0 有一个额外的特殊意义。主版本 0 被认为是 \u0026ldquo;开发中 \u0026ldquo;的版本。任何主版本为 0 的 SemVer 都不被认为是稳定的，任何东西都可能在 API 中发生变化。当你创建一个新模块时，最好从主版本 0 开始，只更新次版本和补丁版本，直到你完成模块的初步开发。一旦你的模块的公共 API完成了变化，并被认为对你的用户来说是稳定的，那么就可以从 1.0.0 版本开始。\n以下面的代码为例，说明一个主要的版本变化可能是什么样子的。你有一个叫做 UserAddress 的函数，目前接受一个string 作为参数，并返回一个string：\nfunc UserAddress(username string) string { // return user address as a string } 虽然该函数目前返回一个 字符串，但你可能认为如果该函数返回一个 结构体，如 *Address，对你和你的用户来说会更好。这样你就可以包括已经拆开的额外数据，如邮政编码：\ntype Address struct { Address string PostalCode string } func UserAddress(username string) *Address { // return user address and postal code struct } 这将是一个主要版本变化的例子，因为它需要你的用户对他们自己的代码进行修改才能使用它。如果你决定完全删除UserAddress 也是如此，因为你的用户需要更新他们的代码来兼容这个替换。\n另一个主要版本变化的例子是给 UserAddress 函数添加一个新的参数，即使它仍然返回一个字符串：\nfunc UserAddress(username string, uppercase bool) string { // return user address as a string, uppercase if bool is true } 由于这一变化也需要你的用户更新他们的代码，如果他们使用 UserAddress 函数的话，这也需要一个主要的版本增加。\n不过，并不是所有你对你的代码所做的改变都会如此剧烈。有时你会对你的公共 API 进行修改，增加新的函数或值，但不改变任何现有的。\n次要版本号 # SemVer 版本中的第二个数字是次要版本号（1.4.3）。次要版本的变化是用来表示你的公共 API 向后兼容的变化。向后兼容的变化是指任何不影响目前使用你的模块的代码或项目的变化。与主要版本号类似，这只影响你的公共 API。一个记住哪些变化符合这个类别的方法是，可能是任何被认为是 \u0026ldquo;增加\u0026rdquo;，但不是 \u0026ldquo;更新 \u0026ldquo;的东西。\n使用主要版本号的同一个例子，设想你有一个名为 UserAddress 的方法，返回一个 字符串：\nfunc UserAddress(username string) string { // return user address as a string } 不过这一次，你没有通过更新UserAddress来返回 *Address ，而是决定添加一个全新的方法，名为UserAddressDetail：\ntype Address struct { Address string PostalCode string } func UserAddress(username string) string { // return user address as a string } func UserAddressDetail(username string) *Address { // return user address and postal code struct } 添加这个新的UserAddressDetail功能不需要你的用户在更新到这个版本的模块时进行修改，所以这将被视为一个小的版本号增加。他们可以继续使用 UserAddress，如果他们需要使用到 UserAddressDetail 的额外信息，只需要更新他们的代码。\n不过，公共 API 的变化可能不是你发布新版本模块的唯一时机。漏洞是软件开发中不可避免的一部分，补丁版本号用来覆盖这些漏洞的升级带来的升级。\n补丁版本号 # 补丁版本号是 SemVer 版本中的最后一个数字（1.4.3）。补丁版本的变化是任何不影响模块的**公共 API **的变化。不影响模块的公共 API 的变化往往是诸如错误修复或安全修复。再次使用前面例子中的 UserAddress 函数，假设你发布的模块在函数返回的 字符串 中缺少部分地址。如果你发布一个新版本的模块来修复这个错误，它只会增加补丁的版本。这个版本不会包括对用户如何使用 UserAddress 公共 API 的任何改变，只包括返回数据的正确性。\n正如你在本节中所看到的，谨慎地选择新的版本号是赢得用户信任的一个重要方法。使用语义版本号可以向用户展示更新到新版本所需的工作量，而且你不会意外地用一个破坏他们程序的更新来给他们带来惊喜。在考虑了你对你的模块所做的修改，并确定了要使用的下一个版本号之后，你就可以发布新的版本，让你的用户使用。\n发布一个新的模块版本 # 在你发布新版本的模块之前，你需要用你计划进行的改动来更新你的模块。如果没有任何改动，你将无法确定要增加语义版本的哪一部分。对于本教程中的模块，你将增加一个新的Goodbye方法来补充Hello 方法，然后你将发布这个新版本供用户使用。\n首先，打开pubmodule.go文件，将新的 Goodbye 方法添加到你的公共API：\npubmodule/pubmodule.go\npackage pubmodule func Hello() string { return \u0026#34;Hello, You!\u0026#34; } func Goodbye() string { return \u0026#34;Goodbye for now!\u0026#34; } 一旦你保存了你的改动，你可以通过运行 git status 来检查哪些改动希望被提交：\ngit status 输出结果将与此类似，显示你的模块中唯一的变化是你在 pubmodule.go 中添加的方法。\nOutput On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: pubmodule.go no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) 接下来，将修改添加到暂存文件中，并通过 git add 和 git commit 将修改提交到本地仓库：\ngit add . git commit -m \u0026#34;Add Goodbye method\u0026#34; 输出结果将与此类似：\nOutput [main 3235010] Add Goodbye method 1 file changed, 4 insertions(+) 提交修改后，你需要把它们推送到你的 GitHub 仓库。在一个较大的软件项目中，或者在与其他开发者合作的项目中，这一步骤通常会略有不同。当开发一个新功能时，一个开发者会创建一个 Git 分支，将修改放入其中，直到新功能稳定并准备发布。 一旦发生类似的情况，另一个开发者就会擦亮眼睛审查该分支中的修改，来发现第一个开发者可能错过的bug。一旦审查完成，该分支就会被合并到默认分支（如master或main）。在两次发布之间，默认分支将积累这些类型的变化，直到发布新版本的时候。\n由于你的模块没有经历这个过程，推送你所做的修改到仓库将模拟修改的积累：\ngit push 输出结果将类似于这样：\nOutput numerating objects: 5, done. Counting objects: 100% (5/5), done. Delta compression using up to 8 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 369 bytes | 369.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:your_github_username/pubmodule.git 931071d..3235010 main -\u0026gt; main 输出显示新代码已经准备好供用户在默认分支中使用。\n到此为止，你所做的一切都与最初发布模块时一样。然而，现在发布新版本的一个重要部分出现了：选择一个新的版本号。\n如果你看一下你对模块所做的改动，对公共 API 的唯一改动（或者说是任何改动）是给你的模块添加了 Goodbye 方法。由于用户可以从只有 Hello 功能的上一个版本中进行更新，而不需要在自己身上做任何改动，因此这种改动将是一种向后兼容的改动。在语义版本管理中，对公共 API 的向后兼容的改变意味着增加次要版本号。不过，这是你的模块所发布的第一个版本，所以没有以前的版本可以增加。如果你认为 0.0.0 是 \u0026ldquo;无版本\u0026rdquo;，那么增加次要版本将导致你的模块的下一个版本为0.1.0。\n现在你有了一个版本号来发布你的模块，你可以用它和 Git 标签配对来发布一个新的版本。当开发者使用 Git 来记录他们的源代码时，即使是 Go 以外的语言，一个常见的惯例是使用 Git 的标签来记录某个特定版本的代码被发布。这样，如果他们需要对旧版本进行修改，就可以使用该标签。由于 Go 已经从源码库中下载了模块，它通过使用这些相同的版本标签来利用这种做法。\n要使用这些标签发布你自己模块的新版本，你可以用 git tag 命令来标记你要发布的代码。作为 git tag命令的一个参数，你还需要提供版本标签。要创建版本标签，以前缀 v 开始，代表版本，然后紧接着添加你的 SemVer。就你的模块而言，你的最终版本标签将是v0.1.0 。现在，运行 git tag 来给你的模块加上版本标签：\ngit tag v0.1.0 一旦版本标签被添加到本地，你仍然需要将该标签推送到你的 GitHub 仓库，你可以使用 git push 和 origin 来完成。\ngit push origin v0.1.0 在 git push 命令成功后，你会看到一个新的标签，v0.1.0，已经被创建：\nOutput Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:your_github_username/pubmodule.git * [new tag] v0.1.0 -\u0026gt; v0.1.0 上面的输出显示你的标签已经被推送，你的 GitHub 仓库有一个新的 v0.1.0 标签供你的模块用户参考。\n现在你已经用git tag发布了新版本的模块，每当用户运行go get获取你的模块的最新版本时，它将不再基于默认分支的最新提交哈希值下载版本。一旦一个模块有了发布的版本，go 工具将开始使用这些版本来决定更新模块的最佳方式。与语义上的版本控制相搭配，这使你能够迭代和改进你的模块，同时也为你的用户提供了一致和稳定的体验。\n总结 # 在本教程中，你创建了一个公共 Go 模块，并将其发布到 GitHub 仓库中，以便其他人可以使用。你还使用语义版本学来确定你的模块的最佳版本号。最后，你扩展了你的模块的功能，并使用语义版本管理，发布了新的版本，相信你再也不会破坏依赖它的程序了。\n如果你想了解有关语义版本管理的更多信息，包括如何为你的版本添加数字以外的信息，语义版本管理网站 有很详细的介绍。Go 文档中也有一个 module version numbering 页面，解释了 Go 如何具体使用 SemVer。\n关于 Go 模块的更多信息，Go 项目有一系列博文，详细介绍了 Go 工具如何与模块互动和理解模块。Go 项目还在Go模块参考中为 Go 模块提供了非常详细的技术参考。\n本教程也是DigitalOcean How to Code in Go系列的一部分。该系列涵盖了许多 Go 主题，从首次安装 Go 到如何使用该语言本身。\n"},{"id":42,"href":"/How-To-Code-in-Go/docs/43-How_to_Use_a_Private_Go_Module_in_Your_Own_Project/","title":"43 How to Use a Private Go Module in Your Own Project","section":"Docs","content":" 如何在自己的项目中使用私有的Go模块 # 简介 # Go 的生态系统的一个优势是大量的模块是开源的。由于它们是开源的，所以可以自由访问、检查、使用和学习。然而，有时出于各种原因，有必要制作一个私有的 Go 模块，例如在公司内部保留专有的商业逻辑。\n在本教程中，你将发布一个私有 Go 模块，设置访问私有模块的认证，并在项目中使用一个私有 Go 模块。\n前期准备 # 安装1.16 或更高版本的 Go。如何安装 Go ，请根据你的操作系统遵循 如何安装Go 教程。 对分发 Go 模块的理解，可以在 如何分发 Go 模块 教程中找到。 熟悉Git，你可以参考 How To Use Git: A Reference Guide 。 一个名为 mysecret 的空的 GitHub 私有仓库，用于发布你的私有模块。要开始使用，请遵循 GitHub 创建仓库的文档。 一个可以从你的仓库读取的GitHub 个人访问令牌。你将用它来允许 Go 访问你的私有仓库。 分发一个私有模块 # 与许多编程语言不同，Go 从仓库而不是中央包服务器发布模块。这种方法的一个好处是，发布私有模块与发布公共模块非常相似。Go 的私有模块不需要一个完全独立的私有包服务器，而是通过一个私有源代码库发布。由于大多数源代码托管选项都支持开箱即用，所以不需要再建立一个额外的私有服务器。\n为了使用私有模块，你需要访问一个私有 Go 模块。在本节中，你将创建并发布一个私有模块，你可以在以后的教程中使用，从另一个 Go 程序中访问一个私有模块。\n要创建新的私有 Go 模块，首先要克隆它所在的私有 GitHub 仓库。作为先决条件的一部分，你在 GitHub 账户中创建了一个名为 mysecret 的私有空仓库，这就是你将用于私有模块的仓库。这个仓库可以在你的电脑上的任何地方克隆，但许多开发者倾向于为他们的项目建立一个目录。在本教程中，你将使用一个名为 projects 的目录。\n创建 projects 目录并进入：\nmkdir projects cd projects 在projects目录下，运行git clone将你的私人 mysecret 仓库克隆到你的电脑上：\ngit clone git@github.com:your_github_username/mysecret.git Git 会确认它已经克隆了你的模块，你可能会得到一个警告，说你克隆了一个空的仓库，但这并不值得担心：\nOutput Cloning into \u0026#39;mysecret\u0026#39;... warning: You appear to have cloned an empty repository. 接下来，使用 cd 进入你克隆的 mysecret 目录，并使用 go mod init ，加上你的私有仓库的名称，创建一个新的Go模块：\ncd mysecret go mod init github.com/your_github_username/mysecret 现在你的模块已经创建，现在是时候添加一个你可以从另一个项目中使用的函数了。使用 nano，或你喜欢的文本编辑器，打开一个与你的仓库同名的文件，如 mysecret.go。这个名字并不重要，可以是任何东西，但使用与仓库相同的名字可以使你在使用新模块时，更容易确定先看哪个文件。\nnano mysecret.go 在 mysecret.go 文件中，用与你的仓库相同的名字命名软件包，然后添加一个 SecretProcess 函数，在调用时打印 Running the secret process! 这一行：\nprojects/mysecret/mysecret.go\npackage mysecret import \u0026#34;fmt\u0026#34; func SecretProcess() { fmt.Println(\u0026#34;Running the secret process!\u0026#34;) } 现在你已经创建了你的私人模块，你将把它发布到你的私人资源库，供其他人使用。由于你的私人资源库最初只允许你访问，你能够控制谁可以访问你的私人模块。你可能会限制自己的访问，但你也可以让朋友或同事访问。\n由于私有和公共 Go 模块都是源码库，发布私有 Go 模块的过程与发布公共模块的过程相同。要发布你的新模块，使用git add命令在当前目录下进行修改，然后使用 git commit 命令将这些修改提交到你的本地存储库：\ngit add . git commit -m \u0026#34;Initial private module implementation\u0026#34; 你会看到 Git 确认你的初始提交已经成功，以及提交中包含的文件的摘要：\nOutput [main (root-commit) bda059d] Initial private module implementation 2 files changed, 10 insertions(+) create mode 100644 go.mod create mode 100644 mysecret.go 现在唯一剩下的部分就是把你的改动移到你的 GitHub 仓库里。与公共模块类似，使用 git push 命令来发布你的代码：\ngit push 然后，Git 会推送你的修改，让任何能访问你的私有仓库的人都能看到这些修改：\ngit push origin main Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 8 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (4/4), 404 bytes | 404.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:your_github_username/mysecret.git * [new branch] main -\u0026gt; main 与公开的 Go 模块一样，你也可以为你的私有 Go 模块添加版本。如何发布Go模块教程中的发布新模块版本部分包含了如何做到这一点的信息。\n在这一节中，你创建了一个带有 SecretProcess 函数的新模块，并将其发布到你的私人 mysecret GitHub 仓库，使其成为一个私人 Go 模块。为了从其他 Go 程序中访问这个模块，你需要配置 Go，使它知道如何访问这个模块。\n配置 Go 访问私有模块 # 虽然 Go 模块通常从其源代码库中分发，但 Go 团队也运行一些中央 Go 模块服务，以确保模块在原始仓库发生意外时继续存在。默认情况下，Go 被配置为使用这些服务，但当你试图下载一个私有模块时，它们可能会引起问题，因为它们无法访问这些模块。要告诉 Go 某些导入路径是私有的，它不应该尝试使用中央 Go 服务，你可以使用 GOPRIVATE 环境变量。GOPRIVATE 环境变量是一个以逗号分隔的导入路径前缀列表，当遇到这种情况时，Go 工具将尝试直接访问它们，而不是通过中央服务。一个这样的例子是你刚刚创建的私有模块。\n为了使用私有模块，你将通过在 GOPRIVATE 变量中设置来告诉 Go 哪个路径是私有的。在设置 GOPRIVATE 变量值时，你可以做几个选择。一个选择是将 GOPRIVATE 设置为 github.com。但这可能不是你想要的，因为这将告诉 Go 不为任何托管在github.com上的模块使用中央服务，包括不是你的模块。\n下一个选择是将 GOPRIVATE 设置为只有你自己的用户路径，如github.com/your_github_username。这就解决了把所有 GitHub 视为私有的问题，但在某些时候，你可能会有你创建的公共模块，你想通过 Go 模块镜像下载。这样做不会造成任何问题，是一个完全合理的选择，但你也可以选择更具体的方式。\n最具体的选择是将 GOPRIVATE 设置为与你的模块的路径完全匹配，例如，github.com/your_github_username/mysecret 。这就解决了前面两个选项的问题，但也带来了一个问题，即你需要将你的每个私有仓库单独添加到 GOPRIVATE 中，如图。\nGOPRIVATE=github.com/your_github_username/mysecret,github.com/your_github_username/othersecret 选择最适合你自己的方案是一个根据自身情况权衡利弊的问题。\n由于你现在只有一个私有模块，我们将使用完整的仓库名称作为值。要在当前终端设置 GOPRIVATE=github.com/your_github_username/mysecret 环境变量，使用 export 命令：\nexport GOPRIVATE=github.com/your_github_username/mysecret 如果你想仔细检查它是否被设置，你可以使用 env 命令和 grep 来检查 GOPRIVATE 名称：\nenv | grep GOPRIVATE Output GOPRIVATE=github.com/your_github_username/mysecret 尽管 Go 现在知道你的模块是私有的，但还不能完全使用该模块。如果你试图将你的私有模块 go get 到另一个模块中，你可能会看到一个类似的错误。\ngo get github.com/your_github_username/mysecret Output go get: module github.com/your_github_username/mysecret: git ls-remote -q origin in /Users/your_github_username/go/pkg/mod/cache/vcs/2f8c...b9ea: exit status 128: fatal: could not read Username for \u0026#39;https://github.com\u0026#39;: terminal prompts disabled Confirm the import path was entered correctly. If this is a private repository, see https://golang.org/doc/faq#git_https for additional information. 这条错误信息说 Go 试图下载你的模块，但它遇到了它仍然无法访问的东西。由于 Git 被用来下载模块，它通常会要求你输入凭证。然而，在这种情况下，Go 正在为你调用 Git，无法提示你。在这一点上，要访问你的模块，你需要提供一种方法，让 Git 在不需要你立即输入的情况下检索你的凭证。\n为 HTTPS 提供私有模块凭证 # 告诉 Git 如何代表你登录的一种方法是 .netrc 文件。.netrc 文件位于用户的主目录中，包含了各种主机名称以及这些主机的登录凭证。它被许多工具广泛使用，包括 Git。\n默认情况下，当 go get 试图下载一个模块时，它将首先尝试使用 HTTPS。然而，正如前面的例子所示，它无法提示你的用户名和密码。为了给 Git 提供你的凭证，你需要在你的主目录下有一个 .netrc，其中包括 github.com。\n要在Linux、MacOS或 Windows Subsystem for Linux（WSL）上创建一个.netrc文件，在你的主目录（~/）中打开.netrc文件，这样你就可以编辑它：\nnano ~/.netrc 接下来，在该文件中创建一个新条目。machine 值应该是你要设置证书的主机名，本例中是 github.com。login 值应该是你的 GitHub用户名。最后，password 值应该是你创建的GitHub个人访问令牌。\n~/.netrc\nmachine github.com login your_github_username password your_github_access_token 如果你愿意，你也可以把整个条目放在文件中的一行:\n~/.netrc\nmachine github.com login your_github_username password your_github_access_token **注意：**如果你使用 Bitbucket 作为你的源代码托管，你可能还需要在 bitbucket.org 之外添加第二个条目 api.bitbucket.org。在过去，Bitbucket 为多种类型的版本控制提供托管服务，所以 Go 会在尝试下载之前使用 API 来检查仓库的类型。虽然现在已经不是这样了，但 API 检查仍然存在。如果你遇到这个问题，一个错误信息的例子可能是这样的：\ngo get bitbucket.org/your_github_username/mysecret: reading https://api.bitbucket.org/2.0/repositories/your_bitbucket_username/protocol?fields=scm: 403 Forbidden server response: Access denied. You must have write or admin access. 如果你在试图下载一个私有模块时看到 403 Forbidden 错误，请仔细检查 Go 试图连接的主机名。它可能表示另一个主机名，如 api.bitbucket.org，你需要添加到你的 .netrc 文件中。\n现在你的环境被设置为使用 HTTPS 认证来下载你的私有模块。尽管 HTTPS 是 Go 和 Git 尝试下载模块的默认方式，但也可以告诉 Git 使用 SSH 来代替。使用 SSH 而不是 HTTPS 很有用，这样你就可以使用推送私有模块时使用的相同 SSH 密钥。如果你不愿意创建个人访问令牌，也可以在设置 CI/CD 环境时使用 deploy keys。\n为SSH提供私有模块凭证 # 为了使用 SSH 密钥作为私有 Go 模块的认证方式而不是 HTTPS，Git 提供了一个名为 insteadOf 的配置选项。insteadOf 选项表示你说：“与其”使用 https://github.com/ 作为所有 Git 请求的 URL，你更愿意使用 ssh://git@github.com/。\n在Linux、MacOS 和 WSL 上，这个配置存在于 .gitconfig 文件中。你可能已经很熟悉这个文件了，因为你的提交邮件地址和名字也是在这里配置的。要编辑该文件，请使用 nano，或你喜欢的文本编辑器，并打开你的主目录中的 ~/.gitconfig 文件：\nnano ~/.gitconfig 一旦你打开这个文件，编辑它的 url 部分为 ssh://git@github.com/ ，如下面的例子：\n~/.gitconfig\n[user] email = your_github_username@example.com name = Sammy the Shark [url \u0026#34;ssh://git@github.com/\u0026#34;] insteadOf = https://github.com/ url 部分相对于 user 部分的顺序并不重要，如果文件中除了你刚刚添加的 url 部分外没有其他内容，你也不需要担心。email 和 name 字段在 user 部分的顺序也不重要。\n这个新的部分告诉 Git，你使用的任何以 https://github.com/ 开头的 URL 应该用 ssh://git@github.com/ 代替前缀。由于 Go 默认使用 HTTPS，这也会影响到你的 go get 命令。以你的私有模块为例，这意味着 Go 将 github.com/your_github_username/mysecret 导入路径变成 https://github.com/your_github_username/mysecret 的URL。当 Git 遇到这个 URL 时，它将看到这个 URL 与 insteadOf 引用的 https://github.com/ 前缀相匹配，并将生成的 URL 变成 ssh://git@github.com/your_github_username/mysecret。\n只要ssh://git@的 URL 对该主机也有效，这个模式也可以用于 GitHub 以外的域名。\n在本节中，你通过更新 .gitconfig 文件并添加 url 部分，配置了 Git 使用 SSH 下载 Go 模块。现在你的私有模块的认证已经设置好了，你可以访问它，在你的Go程序中使用。\n使用一个私有模块 # 在前面的章节中，您将 Go 配置为通过 HTTPS、SSH 或可能同时访问您的私有 Go 模块。现在 Go 可以访问你的私有模块，它的使用与你过去可能使用的任何公共模块相似。在本节中，你将创建一个使用你的私有模块的新 Go 模块。\n在你用于项目的目录中，如 projects，用 mkdir 命令为新项目创建一个名为 myproject 的目录:\nmkdir myproject 一旦目录创建完毕，使用 cd 进入该目录，并根据你的项目所在的仓库 URL，使用 go mod init 为你的项目初始化一个新的 Go 模块，例如 github.com/your_github_username/myproject。如果你不打算将你的项目推送到任何其他仓库，模块名称可以是 myproject，或任何其他名称，但使用完整的 URL 是很好的做法，因为大多数共享的模块都需要它们。\nOutput go: creating new go.mod: module github.com/your_github_username/myproject 现在，用nano或你喜欢的文本编辑器打开main.go，创建你项目的第一个代码文件：\nnano main.go 在该文件中，设置初始的 main 函数，你将从该函数中调用你的私有模块：\nprojects/myproject/main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;My new project!\u0026#34;) } 现在运行你的项目确保一切都设置正确，你可以使用 go run 命令并向它提供 main.go 文件：\ngo run main.go Output My new project! 接下来，使用 go get 将你的私有模块作为你的新项目的一个依赖项加入，就像你对一个公共模块的做法一样：\ngo get github.com/your_github_username/mysecret 然后 go 工具将下载你的私有模块的代码，并使用与你的最新提交哈希值和提交时间相匹配的版本字符串，将其添加为依赖关系：\nOutput go: downloading github.com/your_github_username/mysecret v0.0.0-20210920195630-bda059d63fa2 go get: added github.com/your_github_username/mysecret v0.0.0-20210920195630-bda059d63fa2 最后，再次打开 main.go 文件，更新代码，在 main 函数中添加对你的私有模块的 SecretProcess 函数的调用。你还需要更新 import 语句，把你的 github.com/your_github_username/mysecret 私有模块也作为一个导入文件。\nprojects/myproject/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/your_github_username/mysecret\u0026#34; ) func main() { fmt.Println(\u0026#34;My new project!\u0026#34;) mysecret.SecretProcess() } 要看到最终的项目与你的私有模块一起运行，再次使用 go run 命令，同时提供 main.go 文件作为参数：\ngo run main.go 你会看到原始代码中的 My new project! 一行，但现在你也会看到你导入的 mysecret 模块中的 Running the secret process! 一行：\nOutput My new project! Running the secret process! 在这一节中，你用 go init 创建了一个新的 Go 模块来访问你之前发布的私有模块。一旦你创建了这个模块，你就使用 go get来下载你的私有模块，就像你使用公共 Go 模块一样。最后，你使用 go run 来编译和运行使用私有模块的 Go 程序。\n总结 # 在本教程中，你创建并发布了一个私有 Go 模块。你还设置了 HTTPS 和 SSH 认证来访问你的私有 Go 模块。最后，你在一个新项目中使用了你的私有模块。\n关于 Go 模块的更多信息，Go 项目有一系列博文详细介绍了 Go 工具如何与模块互动和理解模块。Go 项目在Go模块参考中也有关于 Go 模块的非常详细的技术参考。\n除了 GOPRIVATE 环境变量外，还有更多的变量可以在处理私有 Go 模块时使用。它们可以在Go Modules Reference的Private Modules部分详细了解。\n如果你有兴趣更详细地了解.netrc 文件，GNU网站上的\u0026quot;.netrc\u0026quot; 包括一个所有可用关键字的列表。 git-config文档还包括更多关于你使用的 insteadOf 配置选项如何工作以及其他可用选项的信息。\n本教程也是DigitalOcean How to Code in Go系列的一部分。该系列涵盖了许多 Go 的主题，从首次安装 Go 到如何使用语言本身。\n"},{"id":43,"href":"/How-To-Code-in-Go/docs/44-How_To_Run_Multiple_Functions_Concurrently_in_Go/","title":"44 How to Run Multiple Functions Concurrently in Go","section":"Docs","content":" How To Run Multiple Functions Concurrently in Go # Introduction # One of the popular features of the Go language is its first-class support for concurrency, or the ability of a program to do multiple things at once. Being able to run code concurrently is becoming a larger part of programming as computers move from running a single stream of code faster to running more streams of code simultaneously. To run programs faster, a programmer needs to design their programs to run concurrently, so that each concurrent part of the program can be run independently of the others. Two features in Go, goroutines and channels, make concurrency easier when used together. Goroutines solve the difficulty of setting up and running concurrent code in a program, and channels solve the difficulty of safely communicating between the code running concurrently.\nIn this tutorial, you will explore both goroutines and channels. First, you will create a program that uses goroutines to run multiple functions at once. Then you will add channels to that program to communicate between the running goroutines. Finally, you’ll add more goroutines to the program to simulate a program running with multiple worker goroutines.\nPrerequisites # To follow this tutorial, you will need:\nGo version 1.16 or greater installed. To set this up, follow the How To Install Go tutorial for your operating system. Familiarity with Go functions, which you can find in the How to Define and Call Functions in Go tutorial. Running Functions at the Same Time with Goroutines # In a modern computer, the processor, or CPU, is designed to run as many streams of code as possible at the same time. These processors have one or more “cores,” each capable of running one stream of code at the same time. So, the more cores a program can use simultaneously, the faster the program will run. However, in order for programs to take advantage of the speed increase that multiple cores provide, programs need to be able to be split into multiple streams of code. Splitting a program into parts can be one of the more challenging things to do in programming, but Go was designed to make this easier.\nOne way Go does this is with a feature called goroutines. A goroutine is a special type of function that can run while other goroutines are also running. When a program is designed to run multiple streams of code at once, the program is designed to run concurrently. Typically, when a function is called, it will finish running completely before the code after it continues to run. This is known as running in the “foreground” because it prevents your program from doing anything else before it finishes. With a goroutine, the function call will continue running the next code right away while the goroutine runs in the “background”. Code is considered running in the background when it doesn’t prevent other code from running before it finishes.\nThe power goroutines provide is that each goroutine can run on a processor core at the same time. If your computer has four processor cores and your program has four goroutines, all four goroutines can run simultaneously. When multiple streams of code are running at the same time on different cores like this, it’s called running in parallel.\nTo visualize the difference between concurrency and parallelism, consider the following diagram. When a processor runs a function, it doesn’t always run it from beginning to completion all at once. Sometimes the operating system will interleave other functions, goroutines, or other programs on a CPU core when a function is waiting for something else to happen, such as reading a file. The diagram shows how a program designed for concurrency can run on a single core as well as multiple cores. It also shows how more segments of a goroutine can fit into the same timeframe (9 vertical segments, as seen in the diagram) when running in parallel than when running on a single core.\nThe left column in the diagram, labeled “Concurrency”, shows how a program designed around concurrency could run on a single CPU core by running part of goroutine1, then another function, goroutine, or program, then goroutine2, then goroutine1 again, and so on. To a user, this would seem like the program is running all the functions or goroutines at the same time, even though they’re actually being run in small parts one after the other.\nThe column on the right of the diagram, labeled “Parallelism”, shows how that same program could run in parallel on a processor with two CPU cores. The first CPU core shows goroutine1 running interspersed with other functions, goroutines, or programs, while the second CPU core shows goroutine2 running with other functions or goroutines on that core. Sometimes both goroutine1 and goroutine2 are running at the same time as each other, just on different CPU cores.\nThis diagram also shows another of Go’s powerful traits, scalability. A program is scalable when it can run on anything from a small computer with a few processor cores to a large server with dozens of cores, and take advantage of those additional resources. The diagram shows that by using goroutines, your concurrent program is capable of running on a single CPU core, but as more CPU cores are added, more goroutines can be run in parallel to speed up the program.\nTo get started with your new concurrent program, create a multifunc directory in the location of your choosing. You may already have a directory for your projects, but in this tutorial, you’ll create a directory called projects. You can create the projects directory either through an IDE or via the command line.\nIf you’re using the command line, begin by making the projects directory and navigating to it:\nmkdir projects cd projects From the projects directory, use the mkdir command to create the program’s directory (multifunc) and then navigate into it:\nmkdir multifunc cd multifunc Once you’re in the multifunc directory, open a file named main.go using nano, or your favorite editor:\nnano main.go Paste or type the following code in the main.go file to get started.\nprojects/multifunc/main.go\npackage main import ( \u0026#34;fmt\u0026#34; ) func generateNumbers(total int) { for idx := 1; idx \u0026lt;= total; idx++ { fmt.Printf(\u0026#34;Generating number %d\\n\u0026#34;, idx) } } func printNumbers() { for idx := 1; idx \u0026lt;= 3; idx++ { fmt.Printf(\u0026#34;Printing number %d\\n\u0026#34;, idx) } } func main() { printNumbers() generateNumbers(3) } This initial program defines two functions, generateNumbers and printNumbers, then runs those functions in the main function. The generateNumbers function takes the amount of numbers to “generate” as a parameter, in this case one through three, and then prints each of those numbers to the screen. The printNumbers function doesn’t take any parameters yet, but it will also print out the numbers one through three.\nOnce you’ve saved the main.go file, run it using go run to see the output:\ngo run main.go The output will look similar to this:\nOutput Printing number 1 Printing number 2 Printing number 3 Generating number 1 Generating number 2 Generating number 3 You’ll see the functions run one after the other, with printNumbers running first and generateNumbers running second.\nNow, imagine that printNumbers and generateNumbers each takes three seconds to run. When running synchronously, or one after the other like the last example, your program would take six seconds to run. First, printNumbers would run for three seconds, and then generateNumbers would run for three seconds. In your program, however, these two functions are independent of the other because they don’t rely on data from the other to run. You can take advantage of this to speed up this hypothetical program by running the functions concurrently using goroutines. When both functions are running concurrently the program could, in theory, run in half the time. If both the printNumbers and the generateNumbers functions take three seconds to run and both start at exactly the same time, the program could finish in three seconds. (The actual speed could vary due to outside factors, though, such as how many cores the computer has or how many other programs are running on the computer at the same time.)\nRunning a function concurrently as a goroutine is similar to running a function synchronously. To run a function as a goroutine (as opposed to a standard synchronous function), you only need to add the go keyword before the function call.\nHowever, for the program to run the goroutines concurrently, you’ll need to make one additional change. You’ll need to add a way for your program to wait until both goroutines have finished running. If you don’t wait for your goroutines to finish and your main function completes, the goroutines could potentially never run, or only part of them could run and not complete running.\nTo wait for the functions to finish, you’ll use a WaitGroup from Go’s sync package. The sync package contains “synchronization primitives”, such as WaitGroup, that are designed to synchronize various parts of a program. In your case, the synchronization keeps track of when both functions have finished running so you can exit the program.\nThe WaitGroup primitive works by counting how many things it needs to wait for using the Add, Done, and Wait functions. The Add function increases the count by the number provided to the function, and Done decreases the count by one. The Wait function can then be used to wait until the count reaches zero, meaning that Done has been called enough times to offset the calls to Add. Once the count reaches zero, the Wait function will return and the program will continue running.\nNext, update the code in your main.go file to run both of your functions as goroutines using the go keyword, and add a sync.WaitGroup to the program:\nprojects/multifunc/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func generateNumbers(total int, wg *sync.WaitGroup) { defer wg.Done() for idx := 1; idx \u0026lt;= total; idx++ { fmt.Printf(\u0026#34;Generating number %d\\n\u0026#34;, idx) } } func printNumbers(wg *sync.WaitGroup) { defer wg.Done() for idx := 1; idx \u0026lt;= 3; idx++ { fmt.Printf(\u0026#34;Printing number %d\\n\u0026#34;, idx) } } func main() { var wg sync.WaitGroup wg.Add(2) go printNumbers(\u0026amp;wg) go generateNumbers(3, \u0026amp;wg) fmt.Println(\u0026#34;Waiting for goroutines to finish...\u0026#34;) wg.Wait() fmt.Println(\u0026#34;Done!\u0026#34;) } After declaring the WaitGroup, it will need to know how many things to wait for. Including a wg.Add(2) in the main function before starting the goroutines will tell wg to wait for two Done calls before considering the group finished. If this isn’t done before the goroutines are started, it’s possible things will happen out of order or the code may panic because the wg doesn’t know it should be waiting for any Done calls.\nEach function will then use defer to call Done to decrease the count by one after the function finishes running. The main function is also updated to include a call to Wait on the WaitGroup, so the main function will wait until both functions call Done to continue running and exit the program.\nAfter saving your main.go file, run it using go run like you did before:\ngo run main.go The output will look similar to this:\nOutput Printing number 1 Waiting for goroutines to finish... Generating number 1 Generating number 2 Generating number 3 Printing number 2 Printing number 3 Done! Your output may differ from what is printed here, and it’s even likely to change every time you run the program. With both functions running concurrently, the output depends on how much time Go and your operating system give for each function to run. Sometimes there is enough time to run each function completely and you’ll see both functions print their entire sequences uninterrupted. Other times, you’ll see the text interspersed like the output above.\nAn experiment you can try is removing the wg.Wait() call in the main function and running the program a few times with go run again. Depending on your computer, you may see some output from the generateNumbers and printNumbers functions, but it’s also likely you won’t see any output from them at all. When you remove the call to Wait, the program will no longer wait for both functions to finish running before it continues. Since the main function ends soon after the Wait function, there’s a good chance that your program will reach the end of the main function and exit before the goroutines finish running. When this happens, you’ll see a few numbers printed out, but you won’t see all three from each function.\nIn this section, you created a program that uses the go keyword to run two goroutines concurrently and print a sequence of numbers. You also used a sync.WaitGroup to make your program wait for those goroutines to finish before exiting the program.\nYou may have noticed that the generateNumbers and printNumbers functions do not have return values. In Go, goroutines aren’t able to return values like a standard function would. You can still use the go keyword to call a function that returns values, but those return values will be thrown out and you won’t be able to access them. So, what do you do when you need data from one goroutine in another goroutine if you can’t return values? The solution is to use a Go feature called “channels”, which allow you to send data from one goroutine to another.\nCommunicating Safely Between Goroutines with Channels # One of the more difficult parts of concurrent programming is communicating safely between different parts of the program that are running simultaneously. If you’re not careful, you might run into problems that are only possible with concurrent programs. For example, a data race can happen when two parts of a program are running concurrently, and one part tries to update a variable while the other part is trying to read it at the same time. When this happens, the reading or writing can happen out of order, leading to one or both parts of the program using the wrong value. The name “data race” comes from both parts of the program “racing” each other to access the data.\nWhile it’s still possible to run into concurrency issues like data races in Go, the language is designed to make it easier to avoid them. In addition to goroutines, channels are another feature that makes concurrency safer and easier to use. A channel can be thought of like a pipe between two or more different goroutines that data can be sent through. One goroutine puts data into one end of the pipe and another goroutine gets that same data out. The difficult part of making sure the data gets from one to the other safely is handled for you.\nCreating a channel in Go is similar to how you would create a slice, using the built-in make() function. The type declaration for a channel uses the chan keyword followed by the type of data you want to send on the channel. For example, to create a channel for sending int values, you would use the type chan int. If you wanted a channel for sending []byte vaules, it would be chan []byte, like so:\nbytesChan := make(chan []byte) Once a channel is created, you can send or receive data on the channel by using the arrow-looking \u0026lt;- operator. The position of the \u0026lt;- operator in relation to the channel variable determines whether you’re reading from or writing to the channel.\nTo write to a channel, begin with the channel variable, followed by the \u0026lt;- operator, then the value you want to write to the channel:\nintChan := make(chan int) intChan \u0026lt;- 10 To read a value from a channel, begin with the variable you want to put the value into, either = or := to assign a value to the variable, followed by the \u0026lt;- operator, and then the channel you want to read from:\nintChan := make(chan int) intVar := \u0026lt;- intChan To keep these two operations straight, it can be helpful to remember that the \u0026lt;- arrow always points to the left (as opposed to -\u0026gt;), and the arrow points to where the value is going. In the case of writing to a channel, the arrow points the value to the channel. When reading from a channel, the arrow points the channel to the variable.\nLike a slice, a channel can also be read using the range keyword in a for loop. When a channel is read using the range keyword, each iteration of the loop will read the next value from the channel and put it into the loop variable. It will then continue reading from the channel until the channel is closed or the for loop is exited in other ways, such as a break:\nintChan := make(chan int) for num := range intChan { // Use the value of num received from the channel if num \u0026lt; 1 { break } } In some cases, you may want only to allow a function to read from or write to a channel, but not both. To do this, you would add the \u0026lt;- operator onto the chan type declaration. Similar to reading and writing from a channel, the channel type uses the \u0026lt;- arrow to allow variables to constrain a channel to only reading, only writing, or both reading and writing. For example, to define a read-only channel of int values, the type declaration would be \u0026lt;-chan int:\nfunc readChannel(ch \u0026lt;-chan int) { // ch is read-only } If you wanted the channel to be write-only, you would declare it as chan\u0026lt;- int:\nfunc writeChannel(ch chan\u0026lt;- int) { // ch is write-only } Notice that the arrow is pointing out of the channel for reading, and pointing into the channel for writing. If the declaration doesn’t have an arrow, as in the case of chan int, the channel can be used for both reading and writing.\nFinally, once a channel is no longer being used it can be closed using the built-in close() function. This step is essential because when channels are created and then left unused many times in a program, it can lead to what’s known as a memory leak. A memory leak is when a program creates something that uses up memory on a computer, but doesn’t release that memory back to the computer once it’s done using it. This leads to the program slowly (or sometimes not so slowly) using up more memory over time, like a water leak. When a channel is created with make(), some of the computer’s memory is used up for the channel, then when close() is called on the channel, that memory is given back to the computer to be used for something else.\nNow, update the main.go file in your program to use a chan int channel to communicate between your goroutines. The generateNumbers function will generate numbers and write them to the channel while the printNumbers function will read those numbers from the channel and print them to the screen. In the main function, you’ll create a new channel to pass as a parameter to each of the other functions, then use close() on the channel to close it because it will no longer be used. The generateNumbers function should also not be a goroutine any more because once that function is done running, the program will have finished generating all the numbers it needs to. This way, the close() function is only called on the channel before both functions have finished running.\nprojects/multifunc/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func generateNumbers(total int, ch chan\u0026lt;- int, wg *sync.WaitGroup) { defer wg.Done() for idx := 1; idx \u0026lt;= total; idx++ { fmt.Printf(\u0026#34;sending %d to channel\\n\u0026#34;, idx) ch \u0026lt;- idx } } func printNumbers(ch \u0026lt;-chan int, wg *sync.WaitGroup) { defer wg.Done() for num := range ch { fmt.Printf(\u0026#34;read %d from channel\\n\u0026#34;, num) } } func main() { var wg sync.WaitGroup numberChan := make(chan int) wg.Add(2) go printNumbers(numberChan, \u0026amp;wg) generateNumbers(3, numberChan, \u0026amp;wg) close(numberChan) fmt.Println(\u0026#34;Waiting for goroutines to finish...\u0026#34;) wg.Wait() fmt.Println(\u0026#34;Done!\u0026#34;) } In the parameters for generateNumbers and printNumbers, you’ll see that the chan types are using the read-only and write-only types. Since generateNumbers only needs to be able to write numbers to the channel, it’s a write-only type with the \u0026lt;- arrow pointing into the channel. printNumbers only needs to be able to read numbers from the channel, so it’s a read-only type with the \u0026lt;- arrow pointing away from the channel.\nEven though these types could be a chan int, which would allow both reading and writing, it can be helpful to constrain them to only what the function needs to avoid accidentally causing your program to stop running from something known as a deadlock. A deadlock can happen when one part of a program is waiting for another part of the program to do something, but that other part of the program is also waiting for the first part of the program to finish. Since both parts of the program are waiting on each other, the program will never continue running, almost like when two gears seize.\nThe deadlock can happen due to the way channel communication works in Go. When part of a program is writing to a channel, it will wait until another part of the program reads from that channel before continuing on. Similarly, if a program is reading from a channel it will wait until another part of the program writes to that channel before it continues. A part of a program waiting on something else to happen is said to be blocking because it’s blocked from continuing until something else happens. Channels block when they are being written to or read from. So if you have a function where you’re expecting to write to a channel but accidentally read from the channel instead, your program may enter a deadlock because the channel will never be written to. Ensuring this never happens is one reason to use a chan\u0026lt;- int or a \u0026lt;-chan int instead of just a chan int.\nOne other important aspect of the updated code is using close() to close the channel once it’s done being written to by generateNumbers. In this program, close() causes the for ... range loop in printNumbers to exit. Since using range to read from a channel continues until the channel it’s reading from is closed, if close isn’t called on numberChan then printNumbers will never finish. If printNumbers never finishes, the WaitGroup’s Done method will never be called by the defer when printNumbers exits. If the Done method is never called from printNumbers, the program itself will never exit because the WaitGroup’s Wait method in the main function will never continue. This is another example of a deadlock because the main function is waiting on something that will never happen.\nNow, run your updated code using the go run command on main.go again.\ngo run main.go Your output may vary slightly from what’s shown below, but overall it should be similar:\nOutput sending 1 to channel sending 2 to channel read 1 from channel read 2 from channel sending 3 to channel Waiting for functions to finish... read 3 from channel Done! The output from the program shows that the generateNumbers function is generating the numbers one through three while writing them to the channel shared with printNumbers. Once printNumbers receives the number, it then prints it to the screen. After generateNumbers has generated all three numbers it will exit, allowing the main function to close the channel and wait until printNumbers is finished. Once printNumbers finishes printing out the last number, it calls Done on the WaitGroup and the program exits. Similar to previous outputs, the exact output you see will depend on various outside factors, such as when the operating system or Go runtime choose to run specific goroutines, but it should be relatively close.\nThe benefit of designing your programs using goroutines and channels is that once you’ve designed your program to be split up, you can scale it up to more goroutines. Since generateNumbers is just writing to a channel, it doesn’t matter how many other things are reading from that channel. It will just send numbers to anything that reads the channel. You can take advantage of this by running more than one printNumbers goroutine, so each of them will read from the same channel and handle the data concurrently.\nNow that your program is using channels to communicate, open the main.go file again and update your program so it starts multiple printNumbers goroutines. You will need to tweak the call to wg.Add so it adds one for every goroutine you start. You don’t need to worry about adding one to the WaitGroup for the call to generateNumbers any more because the program won’t continue without finishing the whole function, unlike when you were running it as a goroutine. To ensure it doesn’t reduce the WaitGroup count when it finishes, you should remove the defer wg.Done() line from the function. Next, adding the number of the goroutine to printNumbers makes it easier to see how the channel is read by each of them. Increasing the amount of numbers being generated is also a good idea so that it’s easier to see the numbers being spread out:\nprojects/multifunc/main.go\n... func generateNumbers(total int, ch chan\u0026lt;- int, wg *sync.WaitGroup) { for idx := 1; idx \u0026lt;= total; idx++ { fmt.Printf(\u0026#34;sending %d to channel\\n\u0026#34;, idx) ch \u0026lt;- idx } } func printNumbers(idx int, ch \u0026lt;-chan int, wg *sync.WaitGroup) { defer wg.Done() for num := range ch { fmt.Printf(\u0026#34;%d: read %d from channel\\n\u0026#34;, idx, num) } } func main() { var wg sync.WaitGroup numberChan := make(chan int) for idx := 1; idx \u0026lt;= 3; idx++ { wg.Add(1) go printNumbers(idx, numberChan, \u0026amp;wg) } generateNumbers(5, numberChan, \u0026amp;wg) close(numberChan) fmt.Println(\u0026#34;Waiting for goroutines to finish...\u0026#34;) wg.Wait() fmt.Println(\u0026#34;Done!\u0026#34;) } Once your main.go is updated, you can run your program again using go run with main.go. Your program should start three printNumbers goroutines before continuing on to generating numbers. Your program should also now generate five numbers instead of three to make it easier to see the numbers spread out among each of the three printNumbers goroutines:\ngo run main.go The ouput may look similar to this (although your output might vary quite a bit):\nOutputsending 1 to channel sending 2 to channel sending 3 to channel 3: read 2 from channel 1: read 1 from channel sending 4 to channel sending 5 to channel 3: read 4 from channel 1: read 5 from channel Waiting for goroutines to finish... 2: read 3 from channel Done! When you look at your program output this time, there’s a good chance it will vary greatly from the output you see above. Since there are three printNumbers goroutines running, there’s an element of chance determining which one receives a specific number. When one printNumbers goroutine receives a number, it spends a small amount of time printing that number to the screen, while another goroutine reads the next number from the channel and does the same thing. When a goroutine has finished its work of printing the number and is ready to read another number, it will go back and read the channel again to print the next one. If there are no more numbers to be read from the channel, it will start to block until the next number can be read. Once generateNumbers has finished and close() is called on the channel, all three of the printNumbers goroutines will finish their range loops and exit. When all three goroutines have exited and called Done on the WaitGroup, the WaitGroup’s count will reach zero and the program will exit. You can also experiment with increasing or decreasing the amount of goroutines or numbers being generated to see how that affects the output.\nWhen using goroutines, avoid starting too many. In theory, a program could have hundreds or even thousands of goroutines. However, depending on the computer the program is running on, it could actually be slower to have a higher number of goroutines. With a high number of goroutines, there’s a chance it could run into resource starvation. Every time Go runs part of a goroutine, it requires a little bit of extra time to start running again, in addition to the time needed to run the code in the next function. Due to the extra time it takes, it’s possible for the computer to take longer to switch between running each goroutine than to actually run the goroutine itself. When this happens, it’s called resource starvation because the program and its goroutines aren’t getting the resources they need to run, or are getting very few. In these cases, it may be faster to lower the number of parts in the program running concurrently because it will lower the time it takes to switch between them, and give more time to running the program itself. Remembering how many cores the program is running on can be a good starting point for deciding how many goroutines you want to use.\nUsing a combination of goroutines and channels makes it possible to create very powerful programs capable of scaling from running on small desktop computers up to massive servers. As you saw in this section, channels can be used to communicate between as few as a couple of goroutines to potentially thousands of goroutines with minimal changes. If you take this into consideration when writing your programs, you’ll be able to take advantage of the concurrency available in Go to provide your users a better overall experience.\nConclusion # In this tutorial, you created a program using the go keyword to start concurrently-running goroutines that printed out numbers as they run. Once that program was running, you created a new channel of int values using make(chan int), then used the channel to generate numbers in one goroutine and send them to another goroutine to be printed to the screen. Finally, you started multiple “printing” goroutines at the same time as an example of how channels and goroutines can be used to speed up your programs on multi-core computers.\nIf you’re interested in learning more about concurrency in Go, the Effective Go document created by the Go team goes into much more detail. The Concurrency is not parallelism Go blog post is also an interesting follow-up about the relationship between concurrency and parallelism, two terms that are sometimes mistakenly conflated to mean the same thing.\nThis tutorial is also part of the DigitalOcean How to Code in Go series. The series covers a number of Go topics, from installing Go for the first time to how to use the language itself.\n"},{"id":44,"href":"/How-To-Code-in-Go/docs/45-How_to_Add_Extra_Information_to_Errors_in_Go/","title":"45 How to Add Extra Information to Errors in Go","section":"Docs","content":" How to Add Extra Information to Errors in Go # Introduction # When a function in Go fails, the function will return a value using the error interface to allow the caller to handle that failure. In many cases, developers will use the fmt.Errorf function in the fmt package to return these values. Prior to Go 1.13, though, a downside of using this function is that you would lose information about any errors that may have caused the error to be returned. To solve this, developers would either use packages to provide a way to “wrap” errors inside other errors or create custom errors by implementing the Error() string method on one of their struct error types. Sometimes it can be tedious to create these struct types if you have a number of errors that don’t need to be handled explicitly by the callers, though, so in Go 1.13, the language added features to make it easier to handle these cases.\nOne feature is the ability to wrap errors using the fmt.Errorf function with an error value that can be unwrapped later to access the wrapped errors. This builds the error-wrapping functionality into the Go standard library, so there’s no longer any need to use a third-party library.\nAdditionally, the functions errors.Is and errors.As make it easier to determine if a specific error is wrapped anywhere inside a given error, and will also give you access to that specific error directly without needing to unwrap all the errors yourself.\nIn this tutorial, you’ll create a program that uses these functions to include additional information in errors returned from your functions, and then create your own custom error struct that supports the wrapping and unwrapping functionality.\nPrerequisites # To follow this tutorial, you will need:\nGo version 1.13 or greater installed. To set this up, follow the How To Install Go tutorial for your operating system. (Optional) Reading Handling Errors in Go may be helpful in this tutorial for a more in-depth explanation of error handling, but this tutorial will also cover some of the same topics at a higher level. (Optional) This tutorial expands upon the Creating Custom Errors in Go tutorial with features added to Go since the original tutorial. Reading the previous tutorial is helpful, but is not strictly required. Returning and Handling Errors in Go # When an error occurs in a program, it’s good practice to handle those errors so your users never see them — but to handle the errors, you need to know about them first. In Go, you can handle errors in your program by returning information about the error from your functions using a special interface type, the error interface. Using the error interface allows any Go type to be returned as an error value as long as that type has an Error() string method defined. The Go standard library provides functionality to create errors for these return values, such as the fmt.Errorf function.\nIn this section, you’ll create a program with a function that uses fmt.Errorf to return an error, and you will also add an error handler to check for the errors that the function could return. (If you’d like more information on handling errors in Go, please see the tutorial, Handling Errors in Go.)\nMany developers have a directory to keep current projects. In this tutorial, you’ll use a directory named projects.\nTo begin, make the projects directory and navigate to it:\nmkdir projects cd projects From the projects directory, create a new errtutorial directory to keep the new program in:\nmkdir errtutorial Next, navigate into the new directory with the cd command:\ncd errtutorial Once you’re in the errtutorial directory, use the go mod init command to create a new module named errtutorial:\ngo mod init errtutorial After creating the Go module, open a file named main.go in the errtutorial directory using nano, or your favorite editor:\nnano main.go Next, you will write a program. The program will loop over the numbers 1 through 3 and try to determine if those numbers are valid or not using a function called validateValue. If the number is determined to be invalid, the program will use the fmt.Errorf function to generate an error value that is returned from the function. The fmt.Errorf function allows you to create an error value where the error message is the message you provide to the function. It works similarly to fmt.Printf, but instead of printing the message to the screen it returns it as an error instead.\nThen, in the main function, the error value will be checked to see if it’s a nil value or not. If it is a nil value, the function succeeded and the valid! message is printed. If it’s not, the error received is printed instead.\nTo begin your program, add the following code into your main.go file:\nprojects/errtutorial/main.go\npackage main import ( \u0026#34;fmt\u0026#34; ) func validateValue(number int) error { if number == 1 { return fmt.Errorf(\u0026#34;that\u0026#39;s odd\u0026#34;) } else if number == 2 { return fmt.Errorf(\u0026#34;uh oh\u0026#34;) } return nil } func main() { for num := 1; num \u0026lt;= 3; num++ { fmt.Printf(\u0026#34;validating %d... \u0026#34;, num) err := validateValue(num) if err != nil { fmt.Println(\u0026#34;there was an error:\u0026#34;, err) } else { fmt.Println(\u0026#34;valid!\u0026#34;) } } } The validateValue function from the program takes a number and then returns an error based on whether it was determined to be a valid value or not. In this program, the number 1 is invalid and returns the error that's odd. The number 2 is invalid and returns the error uh oh. The validateValue function uses the fmt.Errorf function to generate the error value being returned. The fmt.Errorf function is convenient for returning errors because it allows you to format an error message using formatting similar to fmt.Printf or fmt.Sprintf without needing to then pass that string to errors.New.\nIn the main function, the for loop will start by iterating over each number from 1 to 3 and will store the value in the num variable. Inside the loop body, a call to fmt.Printf will print the number the program is currently validating. Then, it will call the validateValue function and pass in num, the current number being validated, and store the error result in the err variable. Lastly, if err is not nil it means an error occured during validation and the error message is printed using fmt.Println. The else clause of the error check will print \u0026quot;valid!\u0026quot; when an error wasn’t encountered.\nAfter saving your changes, run your program using the go run command with main.go as the argument from the errtutorial directory:\ngo run main.go The output from running the program will show that validation was run for each number and number 1 and number 2 returned their appropriate errors:\nOutputvalidating 1... there was an error: that\u0026#39;s odd validating 2... there was an error: uh oh validating 3... valid! When you look at the output from the program, you’ll see the program tried to validate all three numbers. The first time it says the validateValue function returned the that's odd error, which would be expected for the value of 1. The next value, 2, also shows it returned an error, but it was the uh oh error this time . Finally, the 3 value returns nil for the error value, meaning there wasn’t an error and the number is valid. The way the validateValue function is written, the nil error value would be returned for any values that aren’t either 1 or 2.\nIn this section, you used fmt.Errorf to create error values you returned from a function. You also added an error handler to print out the error message when any error is returned from the function. At times, though, it can be useful to know what an error means, not just that an error occurred. In the next section, you’ll learn to customize error handling for specific cases.\nHandling Specific Errors Using Sentinel Errors # When you receive an error value from a function, the most basic error handling is to check if the error value is nil or not. This will tell you if the function had an error, but sometimes you may want to customize error handling for a specific error case. For example, imagine you have code connecting to a remote server, and the only error information you get back is “you had an error”. You may wish to tell whether the error was because the server was unavailable or if your connection credentials were invalid. If you knew the error meant a user’s credentials were wrong, you might want to let the user know right away. But if the error means the server was unavailable, you may want to try reconnecting a few times before letting the user know. Determining the difference between these errors allows you to write more robust and user-friendly programs.\nOne way you could check for a particular type of error might be using the Error method on an error type to get the message from the error and compare that value to the type of error you’re looking for. Imagine that in your program, you want to show a message other than there was an error: uh oh when the error value is uh oh. One approach to handling this case would be to check the value returned from the Error method, like so:\nif err.Error() == \u0026#34;uh oh\u0026#34; { // Handle \u0026#39;uh oh\u0026#39; error. fmt.Println(\u0026#34;oh no!\u0026#34;) } Checking the string value of err.Error() to see if it’s the value uh oh, as in the code above, would work in this case. But the code would not work if the uh oh error string is slightly different elsewhere in the program. Checking errors this way can also lead to significant updates to code if the error’s message itself needs to be updated because every place the error is checked would need to be updated. Take the following code, for example:\nfunc giveMeError() error { return fmt.Errorf(\u0026#34;uh h\u0026#34;) } err := giveMeError() if err.Error() == \u0026#34;uh h\u0026#34; { // \u0026#34;uh h\u0026#34; error code } In this code, the error message includes a typo and is missing the o in uh oh. If this is noticed and fixed at some point, but only after adding this error checking in several places, all those places will need to have their checks updated to err.Error() == \u0026quot;uh oh\u0026quot;. If one is missed, which could be easy because it’s only a single character change, the expected custom error handler will not run because it’s expecting uh h and not uh oh.\nIn cases like these, where you may want to handle a specific error differently than others, it’s common to create a variable whose purpose is to hold an error value. This way, the code can check against that variable instead of a string. Typically, these variables begin with either err or Err in their names to signify they’re errors. If the error is only meant to be used within the package it’s defined in, you would want to use the err prefix. If the error is meant to be used elsewhere, you would instead use the Err prefix to make it an exported value, similar to a function or a struct.\nNow, let’s say you were using one of these error values in the typo example from before:\nvar errUhOh = fmt.Errorf(\u0026#34;uh h\u0026#34;) func giveMeError() error { return errUhOh } err := giveMeError() if err == errUhOh { // \u0026#34;uh oh\u0026#34; error code } In this example, the variable errUhOh is defined as the error value for an “uh oh” error (even though it’s misspelled). The giveMeError function returns the value of errUhOh because it wants to let the caller know that an “uh oh” error happened. Then, the error handling code compares the err value returned from giveMeError against errUhOh to see if an “uh oh” error is the one that happened. Even if the typo is found and fixed, all the code would still be working because the error check is checking against the value of errUhOh, and the value of errUhOh is the fixed version of the error value that giveMeError is returning.\nAn error value that is intended to be checked and compared in this way is known as a sentinel error. A sentinel error is an error that’s designed to be a unique value that can always be compared against for a specific meaning. The errUhOh value above will always have the same meaning, that an “uh oh” error occurred, so a program can rely on comparing an error to errUhOh to determine whether that error occurred.\nThe Go standard library also defines a number of sentinel errors that are available when developing Go programs. One example would be the sql.ErrNoRows error. The sql.ErrNoRows error is returned when a database query doesn’t return any results, so that error can be handled differently from a connection error. Since it’s a sentinel error, it can be compared against in error-checking code to know when a query doesn’t return any rows, and the program can handle that differently than other errors.\nGenerally, when creating a sentinel error value, the errors.New function from the errors package is used instead of the fmt.Errorf function you’ve been using thus far. Using errors.New instead of fmt.Errorf does not make any foundational changes to how the error works, though, and both functions could be used interchangeably most of the time. The biggest difference between the two is the errors.New function will only create an error with a static message and the fmt.Errorf function allows formatting the string with values, similar to fmt.Printf or fmt.Sprintf. Since sentinel errors are fundamental errors with values that don’t change, it’s common to use errors.New to create them.\nNow, update your program to use a sentinel error for the “uh oh” error instead of fmt.Errorf.\nFirst, open the main.go file to add the new errUhOh sentinel error and update the program to use it. The validateValue function is updated to return the sentinel error instead of using fmt.Errorf. The main function is updated to check for the errUhOh sentinel error and print oh no! when it encounters it instead of the there was an error: message it shows for other errors.\nprojects/errtutorial/main.go\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) var ( errUhOh = errors.New(\u0026#34;uh oh\u0026#34;) ) func validateValue(number int) error { if number == 1 { return fmt.Errorf(\u0026#34;that\u0026#39;s odd\u0026#34;) } else if number == 2 { return errUhOh } return nil } func main() { for num := 1; num \u0026lt;= 3; num++ { fmt.Printf(\u0026#34;validating %d... \u0026#34;, num) err := validateValue(num) if err == errUhOh { fmt.Println(\u0026#34;oh no!\u0026#34;) } else if err != nil { fmt.Println(\u0026#34;there was an error:\u0026#34;, err) } else { fmt.Println(\u0026#34;valid!\u0026#34;) } } } Now, save your code and use go run to run your program again:\ngo run main.go This time the output will show the generic error output for the 1 value, but it uses the custom oh no! message when it sees the errUhOh error returned from validateValue for 2:\nOutputvalidating 1... there was an error: that\u0026#39;s odd validating 2... oh no! validating 3... valid! Using sentinel errors inside your error checking makes it easier to handle special error cases. For example, they can help determine whether the file you’re reading is failing because you’ve reached the end of the file, which is signified by the io.EOF sentinel error, or if it’s failing for some other reason.\nIn this section, you created a Go program that uses a sentinel error using errors.New to signify when a specific type of error occurred. Over time as your program grows, though, you may get to the point where you’d like more information included in your error than just the uh oh error value. This error value doesn’t give any context on where the error happened or why it happened, and it can be hard to track down specifics of the error in larger programs. To aid in troubleshooting and to cut down the time for debugging, you can make use of error wrapping to include the specifics you need.\nWrapping and Unwrapping Errors # Wrapping errors means taking one error value and putting another error value inside it, like a wrapped gift. Similar to a wrapped gift, though, you need to unwrap it to know what’s inside. Wrapping an error allows you to include additional information about where the error came from or how it happened without losing the original error value, since it’s inside the wrapper.\nBefore Go 1.13, it was possible to wrap errors since you could create custom error values that included the original error. But you would either have to create your own wrappers or use a library that already did the work for you. In Go 1.13, though, Go added support for wrapping and unwrapping errors as part of the standard library by adding the errors.Unwrap function and the %w verb for the fmt.Errorf function. In this section, you’ll update your program to use the %w verb to wrap errors with more information, and you’ll then use errors.Unwrap to retrieve the wrapped information.\nWrapping Errors with fmt.Errorf # The first feature to examine when wrapping and unwrapping errors is an addition to the existing fmt.Errorf function. In the past, fmt.Errorf was used to create formatted error messages with additional information using verbs such as %s for strings and %v for generic values. Go 1.13 added a new verb with a special case, the %w verb. When the %w verb is included in a format string and an error is provided for the value, the error returned from fmt.Errorf will include the value of the error wrapped in the error being created.\nNow, open the main.go file and update it to include a new function called runValidation. This function will take the number currently being validated and run any validation needed on that number. In this case, it only needs to run the validateValue function. If it encounters an error validating the value it will wrap the error using fmt.Errorf and the %w verb to show there was a run error that occurred, then return that new error. You should also update the main function so instead of calling validateValue directly it calls runValidation instead:\nprojects/errtutorial/main.go\n... var ( errUhOh = errors.New(\u0026#34;uh oh\u0026#34;) ) func runValidation(number int) error { err := validateValue(number) if err != nil { return fmt.Errorf(\u0026#34;run error: %w\u0026#34;, err) } return nil } ... func main() { for num := 1; num \u0026lt;= 3; num++ { fmt.Printf(\u0026#34;validating %d... \u0026#34;, num) err := runValidation(num) if err == errUhOh { fmt.Println(\u0026#34;oh no!\u0026#34;) } else if err != nil { fmt.Println(\u0026#34;there was an error:\u0026#34;, err) } else { fmt.Println(\u0026#34;valid!\u0026#34;) } } } Once you’ve saved your updates, run the updated program using go run:\ngo run main.go The output will look similar to this:\nOutput validating 1... there was an error: run error: that\u0026#39;s odd validating 2... there was an error: run error: uh oh validating 3... valid! There are a few things to look at in this output. First, you’ll see the error message being printed for the value 1 now includes run error: that's odd in the error message. This shows the error was wrapped by runValidation’s fmt.Errorf and that the value of the error being wrapped, that's odd, is included in the error message.\nNext, though, there’s a problem. The special error handling that was added for the errUhOh error isn’t running. If you look at the line validating the 2 input, you’ll see it shows the default error message of there was an error: run error: uh oh instead of the expected oh no! message. You know the validateValue function is still returning the uh oh error because you can see it at the end of the wrapped error, but the error detection of errUhOh is no longer working. This happens because the error being returned by runValidation is no longer errUhOh, it’s the wrapped error created by fmt.Errorf. When the if statement tries to compare the err variable to errUhOh, it returns false because err isn’t equal to errUhOh any more, it’s equal to the error that’s wrapping errUhOh. To fix the errUhOh error checking, you’ll need to retrieve the error from inside the wrapper, using the errors.Unwrap function.\nUnwrapping Errors with errors.Unwrap # In addition to the %w verb being added in Go 1.13, a few new functions were added to the Go errors package. One of these, the errors.Unwrap function, takes an error as a parameter and, if the error passed in is an error wrapper, it will return the wrapped error. If the error provided isn’t a wrapper, the function will return nil.\nNow, open the main.go file again and, using errors.Unwrap, update the errUhOh error check to handle the case where errUhOh is wrapped inside an error wrapper:\nprojects/errtutorial/main.go\nfunc main() { for num := 1; num \u0026lt;= 3; num++ { fmt.Printf(\u0026#34;validating %d... \u0026#34;, num) err := runValidation(num) if err == errUhOh || errors.Unwrap(err) == errUhOh { fmt.Println(\u0026#34;oh no!\u0026#34;) } else if err != nil { fmt.Println(\u0026#34;there was an error:\u0026#34;, err) } else { fmt.Println(\u0026#34;valid!\u0026#34;) } } } After saving the edits, run the program again:\ngo run main.go The output will look similar to this:\nOutputvalidating 1... there was an error: run error: that\u0026#39;s odd validating 2... oh no! validating 3... valid! Now, in the output, you’ll see the oh no! error handling for the 2 input value is back. The additional errors.Unwrap function call you added to the if statement allows it to detect errUhOh both when err itself is an errUhOh value as well as if err is an error that is directly wrapping errUhOh.\nIn this section, you used the %w verb added to fmt.Errorf to wrap the errUhOh error inside another error and give it additional information. Then, you used errors.Unwrap to access the errorUhOh error that is wrapped inside another error. Including errors inside other errors as string values is OK for humans reading error messages, but sometimes you’ll want to include additional information with the error wrapper to aid the program in handling the error, such as the status code in an HTTP request error. When this happens, you can create a new custom error to return.\nCustom Wrapped Errors # Since Go’s only rule for the error interface is that it includes an Error method, it’s possible to turn many Go types into a custom error. One way is by defining a struct type with extra information about the error, and then also including an Error method.\nFor a validation error, it may be useful to know which value actually caused the error. Next, let’s create a new ValueError struct that contains a field for the Value that caused the error and an Err field that contains the actual validation error. Custom error types commonly use the Error suffix on the end of the type name to signify it’s a type that conforms to the error interface.\nOpen your main.go file and add the new ValueError error struct, as well as a newValueError function to create instances of the error. You will also need to create a method called Error for ValueError so the struct will be considered an error. This Error method should return the value you want to be displayed whenever the error is converted to a string. In this case, it will use fmt.Sprintf to return a string that shows value error: and then the wrapped error. Also, update the validateValue function so instead of returning just the basic error, it uses the newValueError function to return a custom error:\nprojects/errtutorial/main.go\n... var ( errUhOh = fmt.Errorf(\u0026#34;uh oh\u0026#34;) ) type ValueError struct { Value int Err error } func newValueError(value int, err error) *ValueError { return \u0026amp;ValueError{ Value: value, Err: err, } } func (ve *ValueError) Error() string { return fmt.Sprintf(\u0026#34;value error: %s\u0026#34;, ve.Err) } ... func validateValue(number int) error { if number == 1 { return newValueError(number, fmt.Errorf(\u0026#34;that\u0026#39;s odd\u0026#34;)) } else if number == 2 { return newValueError(number, errUhOh) } return nil } ... Once your updates are saved, run the program again with go run:\ngo run main.go The output will look similar to this:\nOutputvalidating 1... there was an error: run error: value error: that\u0026#39;s odd validating 2... there was an error: run error: value error: uh oh validating 3... valid! You’ll see that the output now shows the errors are wrapped inside of ValueError by the value error: before them in the output. However, the uh oh error detection is broken again because errUhOh is now inside two layers of wrappers, ValueError and the fmt.Errorf wrapper from runValidation. The code code only uses errors.Unwrap once on the error, so this results in the first errors.Unwrap(err) now only returning a *ValueError and not errUhOh.\nOne way to fix this would be to update the errUhOh check to add an additional error check that calls errors.Unwrap() twice to unwrap both layers. To add this, open your main.go file and update your main function to include this change:\nprojects/errtutorial/main.go\n... func main() { for num := 1; num \u0026lt;= 3; num++ { fmt.Printf(\u0026#34;validating %d... \u0026#34;, num) err := runValidation(num) if err == errUhOh || errors.Unwrap(err) == errUhOh || errors.Unwrap(errors.Unwrap(err)) == errUhOh { fmt.Println(\u0026#34;oh no!\u0026#34;) } else if err != nil { fmt.Println(\u0026#34;there was an error:\u0026#34;, err) } else { fmt.Println(\u0026#34;valid!\u0026#34;) } } } Now, save your main.go file and use go run to run your program again:\ngo run main.go The output will look similar to this:\nOutputvalidating 1... there was an error: run error: value error: that\u0026#39;s odd validating 2... there was an error: run error: value error: uh oh validating 3... valid! You’ll see that, uh oh, the errUhOh special error handling is still not working. The line validating the 2 input where we’d expect to see the special error handling oh no! output still shows the default there was an error: run error: ... error output. This happens because the errors.Unwrap function doesn’t know how to unwrap the ValueError custom error type. In order for a custom error to be unwrapped, it needs to have its own Unwrap method that returns the inner error as an error value. When creating errors using fmt.Errorf with the %w verb earlier, Go was actually creating an error for you that already has an Unwrap method added, so you didn’t need to do it yourself. Now that you’re using your own custom function, though, you need to add your own.\nTo finally fix the errUhOh error case, open main.go and add an Unwrap method to ValueError that returns Err, the field the inner wrapped error is stored in:\nprojects/errtutorial/main.go\n... func (ve *ValueError) Error() string { return fmt.Sprintf(\u0026#34;value error: %s\u0026#34;, ve.Err) } func (ve *ValueError) Unwrap() error { return ve.Err } ... Then, once you’ve saved the new Unwrap method, run your program:\ngo run main.go The output will look similar to this:\nOutputvalidating 1... there was an error: run error: value error: that\u0026#39;s odd validating 2... oh no! validating 3... valid! The output shows the oh no! error handling for the errUhOh error is working again because errors.Unwrap is now able to also unwrap ValueError.\nIn this section you created a new, custom ValueError error to provide yourself or your users with information about the validation process as part of the error message. You also added support for error unwrapping to your ValueError so errors.Unwrap can be used to access the wrapped error.\nThe error handling is getting a bit clunky and hard to maintain, though. Every time there’s a new layer of wrapping you’ve had to add another errors.Unwrap to the error checking to handle it. Thankfully, the errors.Is and errors.As functions in the errors package are available to make working with wrapped errors easier.\nWorking with Wrapped Errors # If you needed to add a new errors.Unwrap function call for every potential layer of error wrapping your program had, it would get very long and difficult to maintain. For this reason, two additional functions were also added to the errors package in the Go 1.13 release. Both of these functions make it easier to work with errors by allowing you to interact with errors no matter how deeply they’re wrapped inside other errors. The errors.Is function allows you to check if a specific sentinel error value is anywhere inside a wrapped error. The errors.As function allows you to get a reference to a certain type of error anywhere inside a wrapped error.\nChecking an Error Value with errors.Is # Using errors.Is to check for a specific error makes the errUhOh special error handling much shorter because it handles all the nested error unwrapping you were doing manually. The function takes two error parameters, the first being the error you actually received and the second parameter being the error you want to check against.\nTo clean up the errUhOh error handling, open your main.go file and update the errUhOh check in the main function to use errors.Is instead:\nprojects/errtutorial/main.go\n... func main() { for num := 1; num \u0026lt;= 3; num++ { fmt.Printf(\u0026#34;validating %d... \u0026#34;, num) err := runValidation(num) if errors.Is(err, errUhOh) { fmt.Println(\u0026#34;oh no!\u0026#34;) } else if err != nil { fmt.Println(\u0026#34;there was an error:\u0026#34;, err) } else { fmt.Println(\u0026#34;valid!\u0026#34;) } } } Then, save your code and run the program again using go run:\ngo run main.go The output will look similar to this:\nOutputvalidating 1... there was an error: run error: value error: that\u0026#39;s odd validating 2... oh no! validating 3... valid! The output shows the oh no! error message, which means that even though there’s only one error check for errUhOh, it will still be found in the error chain. errors.Is takes advantage of an error type’s Unwrap method to keep digging deeper into a chain of errors until it either finds the error value you’re looking for, a sentinel error, or encounters an Unwrap method that returns a nil value.\nUsing errors.Is is the recommended way to check for specific errors now that error wrapping exists as a feature in Go. Not only can it be used for your own error values, but it can also be used for other error values such as the sql.ErrNoRows error mentioned earlier in this tutorial.\nRetrieving an Error Type with errors.As # The last function added to the errors package in Go 1.13 is the errors.As function. This function is used when you want to get a reference to a certain type of error to interact with it in more detail. For example, the ValueError custom error you added earlier gives access to the actual value being validated in the Value field of the error, but you can only access it if you have a reference to that error first. This is where errors.As comes in. You can give errors.As an error, similar to errors.Is, and a variable for a type of error. It will then go through the error chain to see if any of the wrapped errors match the type provided. If one matches, the variable passed in for the error type will be set with the error errors.As found, and the function will return true. If no error types match, it will return false.\nUsing errors.As you can now take advantage of the ValueError type to show additional error information in your error handler. Open your main.go file one last time and update the main function to add a new error handling case for ValueError-type errors that prints out value error, the invalid number, and the validation error:\nprojects/errtutorial/main.go\n... func main() { for num := 1; num \u0026lt;= 3; num++ { fmt.Printf(\u0026#34;validating %d... \u0026#34;, num) err := runValidation(num) var valueErr *ValueError if errors.Is(err, errUhOh) { fmt.Println(\u0026#34;oh no!\u0026#34;) } else if errors.As(err, \u0026amp;valueErr) { fmt.Printf(\u0026#34;value error (%d): %v\\n\u0026#34;, valueErr.Value, valueErr.Err) } else if err != nil { fmt.Println(\u0026#34;there was an error:\u0026#34;, err) } else { fmt.Println(\u0026#34;valid!\u0026#34;) } } } In the code above, you declared a new valueErr variable and used errors.As to get a reference to the ValueError if it’s wrapped inside the err value. By getting access to the error as a ValueError, you’re then able to access any additional fields the type provides, such as the actual value that failed validation. This could be helpful if the validation logic happens deeper inside the program and you don’t normally have access to the values to give users hints on where something might have gone wrong. Another example of where this could be helpful is if you’re doing network programming and run into a net.DNSError. By getting a reference to the error, you are able to see if the error was the result of not being able to connect, or if the error was caused by being able to connect, but your resource was not found. Once you know this, you can handle the error in different ways.\nTo see errors.As in action, save your file and run the program using go run:\ngo run main.go The output will look similar to this:\nOutputvalidating 1... value error (1): that\u0026#39;s odd validating 2... oh no! validating 3... valid! This time in the output you won’t see the default there was an error: ... message, because all the errors are being handled by other error handlers. The output for validating 1 shows that the errors.As error check returned true because the value error ... error message is being displayed. Since the errors.As function returned true, the valueErr variable is set to be a ValueError and can be used to print out the value that failed validation by accessing valueErr.Value.\nFor the 2 value, the output also shows that even though the errUhOh is also wrapped inside a ValueError wrapper, the oh no! special error handler is still executed. This is because the special error handler using errors.Is for errUhOh comes first in the collection of if statements handling the errors. Since this handler returns true before the errors.As even runs, the special oh no! handler is the one executed. If the errors.As in your code came before the errors.Is, the oh no! error message would become the same value error ... as the 1 value, except in this case it would print value error (2): uh oh.\nIn this section, you updated your program to use the errors.Is function to remove a lot of additional calls to errors.Unwrap and make your error handling code more robust and future-proof. You also used the errors.As function to check if any of the wrapped errors is a ValueError, and then used fields on the value if one was found.\nConclusion # In this tutorial, you wrapped an error using the %w format verb and unwrapped an error using errors.Unwrap. You also created a custom error type that supports errors.Unwrap in your own code. Finally, you used your custom error type to explore the new helper functions errors.Is and errors.As.\nUsing these new error functions makes it easier to include deeper information about the errors you create or work with. It also future proofs your code to ensure your error checking continues to work even if errors become deeply nested going forward.\nIf you’d like to find more details about how to use the new error features, the Go blog has a post about Working with Errors in Go 1.13. The documentation for the errors package package also includes more information.\nThis tutorial is also part of the DigitalOcean How to Code in Go series. The series covers a number of Go topics, from installing Go for the first time to how to use the language itself.\n"},{"id":45,"href":"/How-To-Code-in-Go/docs/46-How_To_Use_Dates_and_Times_in_Go/","title":"46 How to Use Dates and Times in Go","section":"Docs","content":" How To Use Dates and Times in Go # Introduction # Software is designed to make it easier to get work done, and for many people, that includes interacting with dates and times. Date and time values show up everywhere in modern software. For example, keeping track of when a car needs service and letting the owner know, keeping track of changes in a database to create an audit log, or just comparing one time to another to determine how long a process took. Therefore, retrieving the current time, manipulating time values to extract information from them, and displaying them to users in an easy-to-understand format are essential properties of an application.\nIn this tutorial, you will create a Go program to get the current local time of your computer, then print it to the screen in a format that is easier for people to read. Next, you will interpret a string to extract the date and time information. You will also translate the date and time values between two time zones, as well as add or subtract time values to determine the interval between two times.\nPrerequisites # To follow this tutorial, you will need:\nGo version 1.16 or greater installed. To set this up, follow the How To Install Go tutorial for your operating system. Getting the Current Time # In this section, you will get the current time using Go’s time package. The time package in Go’s standard library provides a variety of date- and time-related functions, and can be used to represent a specific point in time using the time.Time type. In addition to a time and date, it can also hold information about the time zone the represented date and time are in.\nTo begin creating a program to explore the time package, you’ll need to create a directory for the files. This directory can be created anywhere you’d like on your computer, but many developers tend to have a directory for their projects. In this tutorial, you’ll use a directory named projects.\nMake the projects directory and navigate to it:\nmkdir projects cd projects From the projects directory, run mkdir to create a datetime directory and then use cd to navigate to it:\nmkdir datetime cd datetime Once you have your project directory created, open a main.go file using nano, or your preferred editor:\nnano main.go In the main.go file, add a main function that will get the current time and print it out:\nprojects/datetime/main.go\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { currentTime := time.Now() fmt.Println(\u0026#34;The time is\u0026#34;, currentTime) } In this program, the time.Now function from the time package is used to get the current local time as a time.Time value, and then stores it in the currentTime variable. Once it’s stored in the variable, the fmt.Println function prints currentTime to the screen using time.Time’s default string output format.\nRun the program using go run with the main.go file:\ngo run main.go The output showing your current date and time will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT m=+0.000066626 The output will show your current date and time, which will differ from the example. Additionally, the time zone you see (-0500 CDT in this output) will likely be different, since time.Now() returns the time in the local time zone.\nYou may also notice an m= value in your output. This value is the monotonic clock, and is used internally by Go when measuring differences in time. The monotonic clock is designed to compensate for any potential changes to the date and time of a computer’s system clock while a program is running. By using the monotonic clock, a time.Now value compared to a time.Now value five minutes later will still end up with the correct result (a five-minute interval), even if the system clock for the computer is changed an hour forward or backward during that five-minute interval. You don’t need to understand it thoroughly for the code or examples in this tutorial, but if you’d like to learn more about monotonic clocks and how Go uses them, the Monotonic Clocks section in the time package documentation provides additional details.\nNow, while you do have the current time displayed, it might not be useful for users. It may not be the format you’re looking for, or it may include more parts of the date or time than you want to display.\nFortunately, the time.Time type includes various methods to get specific parts of the date or time you want. For example, if you only wanted to know the year portion of the currentTime variable, you could use the Year method, or get the current hour using the Hour method.\nOpen your main.go file again and add a few of the time.Time methods to your output to see what they produce:\nprojects/datetime/main.go\n... func main() { currentTime := time.Now() fmt.Println(\u0026#34;The time is\u0026#34;, currentTime) fmt.Println(\u0026#34;The year is\u0026#34;, currentTime.Year()) fmt.Println(\u0026#34;The month is\u0026#34;, currentTime.Month()) fmt.Println(\u0026#34;The day is\u0026#34;, currentTime.Day()) fmt.Println(\u0026#34;The hour is\u0026#34;, currentTime.Hour()) fmt.Println(\u0026#34;The minute is\u0026#34;, currentTime.Hour()) fmt.Println(\u0026#34;The second is\u0026#34;, currentTime.Second()) } Next, run your program again using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT m=+0.000066626 The year is 2021 The month is August The day is 15 The hour is 14 The minute is 14 The second is 45 Like the previous output, your current date and time will be different from the example, but the format should be similar. This time in the output, you’ll see the full date and time printed as it was before, but you also have a list of the year, month, day of the month, hour, minute, and second. Note that instead of the month printing as a number (like it does in the full date), it appears as the English string August. This is because the Month method returns the month as a time.Month type instead of just a number, and that type is designed to print out the full English name when it’s printed as a string.\nNow, update the main.go file in your program again and replace the various function outputs with a single function call to fmt.Printf, so you can print the current date and time in a format that’s closer to what you may want to display to a user:\nprojects/datetime/main.go\n... func main() { currentTime := time.Now() fmt.Println(\u0026#34;The time is\u0026#34;, currentTime) fmt.Printf(\u0026#34;%d-%d-%d %d:%d:%d\\n\u0026#34;, currentTime.Year(), currentTime.Month(), currentTime.Day(), currentTime.Hour(), currentTime.Hour(), currentTime.Second()) } Once you’ve saved your updates to the main.go file, run it using the go run command as you did before:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT m=+0.000066626 2021-8-15 14:14:45 This time your output may be much closer to what you’d like, but there are still a few things that could be tweaked about the output. The month is now showing up in number format again, because the fmt.Printf format used %d to tell the time.Month type it should use a number and not a string, but it’s only showing up as a single digit. If you want to display two digits, you could change the fmt.Printf format to say that, but what if you also wanted to show a 12-hour time instead of a 24-hour time as shown in the output above? Using the fmt.Printf method, you would have to do your own math to calculate it. Printing dates and times using fmt.Printf is possible, but as you can see, it can eventually become cumbersome. Doing it this way, you could either end up with a large number of lines for each part you want to display, or you’d need to do a number of your own calculations to determine what to display.\nIn this section, you created a new program to get the current time using time.Now. Once you had the current time, you then used various functions, such as Year and Hour on the time.Time type to print out information about the current time. It did start to become a lot of work to display it in a custom format, though. To make this type of common work easier, many programming languages, Go included, provide a special way to format dates and times, similar to how fmt.Printf can be used to format a string.\nPrinting and Formatting Specific Dates # In addition to the Year, Hour, and other data-related methods the time.Time type provides, it also provides a method called Format. The Format method allows you to provide a layout string, similar to how you would provide fmt.Printf or fmt.Sprintf a format, that will tell the Format method how you’d like the date and time printed out. In this section, you will replicate the time output you added in the last section, but in a much more concise manner using the Format method.\nBefore you use the Format method, though, it will be easier to see how Format affects the output of a date and time if it’s not changing every time you run the program. Up until now, you were getting the current time using time.Now, so each time you ran it a different number would show up. The Go time package provides another useful function, the time.Date function, which will allow you to specify a specific date and time for the time.Time to represent.\nTo begin using time.Date instead of time.Now in your program, open the main.go file again and update it to replace time.Now with time.Date:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.Local) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) } The parameters to the time.Date function include the year, month, day of the month, hour, minute, and second of the date and time you want a time.Time for. The first of the last two parameters accounts for nanoseconds, and the last parameter is the time zone to create the time for. Using time zones themselves are covered later in this tutorial.\nAfter saving your updates, run your program using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT The output you see should now be much closer to the output above because you’re using a specific local date and time instead of the current one when you run the program. (Depending on the time zone your computer is set to, the time zone may show up differently, though.) The output format still looks similar to what you saw before because it’s still using the default time.Time format. Now that you have a standard date and time to work with, you can use it to start tweaking how the time is formatted when displayed using the Format method.\nCustomizing Date Strings Using the Format Method # Many other programming languages include a similar way to format dates and times to be displayed, but the way Go constructs the layout of those formats may be slightly different than what you’re used to if you’ve used them in other languages. In other languages, the date formatting uses a style similar to how Printf works in Go, with a % character followed by a letter representing the part of the date or time to insert. For example, a 4-digit year might be represented by %Y. In Go, though, these parts of a date or time are represented by characters that represent a specific date. To include a 4-digit year in a Go date format, you would actually include 2006 in the string itself. The benefit of this type of layout is that what you see in the code actually represents what you’ll see in the output. When you’re able to see a representation of your output, it makes it easier to double-check that your format matches what you’re looking for, and also makes it easier for other developers to understand the output of a program without running the program first.\nThe specific date Go uses for date and time layouts in string formatting is 01/02 03:04:05PM '06 -0700. If you look at each component of the date and time, you’ll see that they increase by one for each part. The month comes first at 01, followed by the day of the month at 02, then the hour at 03, the minute at 04, the second at 05, the year at 06 (or 2006) and, finally, the time zone at 07. Remembering this order will make it easier to create date and time formats in the future. Examples of the options available for formatting can also be found in Go’s documentation of the time package.\nNow, use this new Format method to replicate and clean up the date format you printed in the last section. It required several lines and function calls to display, and using the Format method should make it much easier and cleaner to duplicate.\nOpen the main.go file and add a new fmt.Println call and pass it theTime with a date formatted using the Format method:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.Local) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) fmt.Println(theTime.Format(\u0026#34;2006-1-2 15:4:5\u0026#34;)) } If you look at the layout being used for the format, you’ll see it’s using the same time from above to specify how the date and time should be formatted (January 2, 2006). One thing to notice is that the hour uses 15 instead of 03 like the previous example. This shows that you’d like the hour displayed in 24-hour format instead of 12-hour format.\nTo see the output from this new format, save your program and run it using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT 2021-8-15 14:30:45 The output you see now will be similar to the output from the end of the last section, but it was much simpler to accomplish. All you needed to include was a single line of code and a layout string. The Format function does the rest for you.\nDepending on the date or time you’re displaying, using a variable-length format like the one you ended up with when printing out numbers directly can potentially be hard to read for yourself, your users, or other code trying to read the value. Using 1 for the month format would result in March being displayed as 3, while October would use two characters and show up as 10. Now, open main.go and add an additional line to your program with another, more structured layout. In this layout, include a 0 prefix on the components and update the hour to use a 12-hour format:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.Local) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) fmt.Println(theTime.Format(\u0026#34;2006-1-2 15:4:5\u0026#34;)) fmt.Println(theTime.Format(\u0026#34;2006-01-02 03:04:05 pm\u0026#34;)) } After saving your code, run the program again using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT 2021-8-15 14:30:45 2021-08-15 02:30:45 pm You’ll see that by adding a 0 prefix to the numbers in the layout string, the 8 for the month in the new output becomes 08 to match the layout. The hour, which is now in the 12-hour format, also has its own 0 prefix. In the end, though, what you end up seeing in the output mirrors the format you see in the code, so it’s easier to tweak the format if you need to.\nMany times, formatted dates are intended to be interpreted by other programs, and it can become a burden to re-create those formats every time you want to use them. In some cases, you can use a pre-defined format.\nUsing a Pre-Defined Format # There are many commonly used date formats, such as timestamps for log messages, and re-creating those every time you want to use them could end up being a hassle. For some of these cases, the time package includes pre-defined formats you can use.\nOne of the formats available and used often is the one defined in RFC 3339. An RFC is a document used to define how standards on the internet work, and other RFCs can then build upon each other. There is an RFC that defines how HTTP works (RFC 2616), for example, and others that build on top of that to further define HTTP. So, in the case of RFC 3339, the RFC defines a standard format to use for timestamps on the internet. The format is well-known and well-supported around the internet, so chances of seeing it elsewhere are high.\nEach of the pre-defined time formats in the time package are represented by a const string named after the format they represent. The RFC 3339 format happens to have two formats available, one called time.RFC3339 and another called time.RFC3339Nano. The difference between the formats is that the time.RFC3339Nano version includes nanoseconds in the format.\nNow, open your main.go file again and update your program to use the time.RFC3339Nano format for its output:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.Local) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) fmt.Println(theTime.Format(time.RFC3339Nano)) } Since the pre-defined formats are string values with the desired format, you just need to replace the format you’d usually use with one of them.\nTo see the output, run your program with go run again:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT 2021-08-15T14:30:45.0000001-05:00 The RFC 3339 format is good to use if you need to save a time value as a string somewhere. It can be read by many other programming languages and applications, and is about as compact as a date and time can be in a flexible string format.\nIn this section, you updated your program to use the Format method to print out a date and time. Using this flexible layout also allowed your code to look similar to the final output. Lastly, you used one of the pre-defined layout strings to print out a date and time using a well-supported format. In the next section, you’ll update your program to convert that same string value back into a time.Time value that you can work with.\nParsing Dates and Times in Strings # Often when developing applications, you’ll come across dates represented as string values that you’ll need to interpret in some way. Sometimes, you’ll need to know the date portion of the value, other times you might need to know the time portion, and yet others you might need the whole value. In addition to using the Format method to create string values from time.Time values, the Go time package provides a time.Parse function to convert a string into a time.Time value. The time.Parse function works similar to the Format method, in that it takes the expected date and time layout as well as the string value as parameters.\nNow, open the main.go file in your program and update it to use the time.Parse function to parse a timeString into a time.Time variable:\nprojects/datetime/main.go\n... func main() { timeString := \u0026#34;2021-08-15 02:30:45\u0026#34; theTime, err := time.Parse(\u0026#34;2006-01-02 03:04:05\u0026#34;, timeString) if err != nil { fmt.Println(\u0026#34;Could not parse time:\u0026#34;, err) } fmt.Println(\u0026#34;The time is\u0026#34;, theTime) fmt.Println(theTime.Format(time.RFC3339Nano)) } Unlike the Format method, the time.Parse method also returns a potential error value in case the string value passed in does not match the layout provided as the first parameter. If you look at the layout used, you’ll see that the layout given to time.Parse uses the same 1 for month, 2 for day of month, etc, that is used in the Format method.\nAfter saving your updates, you can run your updated program using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 02:30:45 +0000 UTC 2021-08-15T02:30:45Z There are a couple of things to notice in this output. One is that the time zone being parsed from timeString is using the default time zone, which is a +0 offset and known as Coordinated Universal Time (UTC). Since neither the time value nor the layout includes the time zone, the time.Parse function doesn’t know which time zone to associate it with. If you need it at some point, though, the time package does include a time.ParseInLocation function so you can provide the location to use. The other part to notice is in the RFC 3339 output. The output is using the time.RFC3339Nano layout, but the output doesn’t include any nanoseconds. This is because the time.Parse function is not parsing any nanoseconds, so the value is set to the default of 0. When nanoseconds are 0, the time.RFC3339Nano format will not include nanoseconds in the output.\nThe time.Parse method can also use any of the pre-defined time layouts provided in the time package when parsing a string value. To see this in practice, open your main.go file and update the timeString value to match the output from time.RFC3339Nano earlier, and update the time.Parse parameter to match:\nprojects/datetime/main.go\n... func main() { timeString := \u0026#34;2021-08-15T14:30:45.0000001-05:00\u0026#34; theTime, err := time.Parse(time.RFC3339Nano, timeString) if err != nil { fmt.Println(\u0026#34;Could not parse time:\u0026#34;, err) } fmt.Println(\u0026#34;The time is\u0026#34;, theTime) fmt.Println(theTime.Format(time.RFC3339Nano)) } Once you have the code updated, you can save your program and run it again using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT 2021-08-15T14:30:45.0000001-05:00 This time, the output from the Format method shows that time.Parse was able to parse both the time zone and the nanoseconds from timeString.\nIn this section, you used the time.Parse function to parse an arbitrarily formatted date and time string value as well as a pre-defined layout. Thus far, though, you haven’t interacted with the various time zones you’ve seen. Another set of features Go provides for the time.Time type is the ability to convert between different time zones, as you’ll see in the next section.\nWorking with Time Zones # When developing an application with users across the world, or even across only a few time zones, a common practice is to store dates and times using Coordinated Universal Time (UTC) and then convert to a user’s local time when required. This allows the data to be stored in a consistent format and makes calculations between them easier, since conversion is needed only when displaying the date and time to a user.\nIn earlier sections of this tutorial, you created a program that worked primarily on times based in your own local time zone. To save your time.Time values as UTC, you’ll first need to convert them to UTC. You will do this using the UTC method, which will return a copy of the time you call it on, but in UTC.\nNote: This section converts times between your computer’s local time zone and UTC. If the computer you’re using has the local time zone set to one that matches UTC, you’ll notice that converting between UTC and back again won’t show a difference in the times.\nNow, open your main.go file to update your program to use the UTC method on theTime to return the UTC version of the time:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.Local) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) fmt.Println(theTime.Format(time.RFC3339Nano)) utcTime := theTime.UTC() fmt.Println(\u0026#34;The UTC time is\u0026#34;, utcTime) fmt.Println(utcTime.Format(time.RFC3339Nano)) } This time your program creates theTime as a time.Time value in your local time zone, prints it out in two different formats, then uses the UTC method to translate that time from your local time to UTC time.\nTo see the output from the program, you can run it using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT 2021-08-15T14:30:45.0000001-05:00 The UTC time is 2021-08-15 19:30:45.0000001 +0000 UTC 2021-08-15T19:30:45.0000001Z Your output will vary depending on your local time zone, but in the output above, you’ll see that the first time that’s printed out is in CDT (North American Central Daylight Time), which is -5 hours from UTC. Once the UTC method is called and the UTC time prints, you can see the hour in the time goes from 14 to 19, because converting the time to UTC added five hours.\nIt’s also possible to convert a UTC time back to a local time using the Local method on a time.Time in the same way. Open your main.go file again and update it to add a call to the Local method on utcTime to convert it back to your local time zone:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.Local) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) fmt.Println(theTime.Format(time.RFC3339Nano)) utcTime := theTime.UTC() fmt.Println(\u0026#34;The UTC time is\u0026#34;, utcTime) fmt.Println(utcTime.Format(time.RFC3339Nano)) localTime := utcTime.Local() fmt.Println(\u0026#34;The Local time is\u0026#34;, localTime) fmt.Println(localTime.Format(time.RFC3339Nano)) } Once your file is saved, run your program using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 -0500 CDT 2021-08-15T14:30:45.0000001-05:00 The UTC time is 2021-08-15 19:30:45.0000001 +0000 UTC 2021-08-15T19:30:45.0000001Z The Local time is 2021-08-15 14:30:45.0000001 -0500 CDT 2021-08-15T14:30:45.0000001-05:00 You’ll see that the UTC time has been converted back to your local time zone. In the output above, the UTC conversion back to CDT means that five hours has been subtracted from the UTC, changing the hour from 19 to 14.\nIn this section, you updated your program to convert dates and times between your local time zone and the standard UTC time zone using the UTC method, then back again using the Local method.\nOnce you have your date and time values available, there are a number of additional features the Go time package provides that can be useful in your applications. One of these features is determining whether a given time is before or after another.\nComparing Two Times # Comparing two dates with each other can be deceptively difficult at times, due to all the variables that need to be considered when comparing them. For example, needing to take time zones into account, or the fact that months have a different number of days from each other. The time package provides a few methods to make this easier.\nThe time package provides two methods to make these comparisons easier: the Before and After methods, available on the time.Time type. These methods both accept a single time value and return either true or false depending on whether the time they’re being called on is before or after the time being provided.\nTo see an example of these functions in action, open your main.go file and update it to include two different dates, then use Before and After to compare those dates to see the output:\nprojects/datetime/main.go\n... func main() { firstTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.UTC) fmt.Println(\u0026#34;The first time is\u0026#34;, firstTime) secondTime := time.Date(2021, 12, 25, 16, 40, 55, 200, time.UTC) fmt.Println(\u0026#34;The second time is\u0026#34;, secondTime) fmt.Println(\u0026#34;First time before second?\u0026#34;, firstTime.Before(secondTime)) fmt.Println(\u0026#34;First time after second?\u0026#34;, firstTime.After(secondTime)) fmt.Println(\u0026#34;Second time before first?\u0026#34;, secondTime.Before(firstTime)) fmt.Println(\u0026#34;Second time after first?\u0026#34;, secondTime.After(firstTime)) } Once you have your file updated, save it and run it using go run:\ngo run main.go The output will look similar to this:\nOutputThe first time is 2021-08-15 14:30:45.0000001 +0000 UTC The second time is 2021-12-25 16:40:55.0000002 +0000 UTC First time before second? true First time after second? false Second time before first? false Second time after first? true Since the code is using explicit dates in the UTC time zone, your output should match the output above. You’ll see that when using the Before method on firstTime and providing it secondTime to compare to, it’s saying that it’s true that 2021-08-15 is before 2021-12-25. When using the After method of firstTime and providing secondTime, it says it’s false that 2021-08-15 is after 2021-12-25. Changing the order to call the methods on secondTime shows the opposite results, as expected.\nAnother way to compare two dates and times with the time package is the Sub method. The Sub method will subtract one date from another and return a value using a new type, the time.Duration. Unlike a time.Time value, which represents an absolute point in time, a time.Duration value represents a difference in time. For example, “in one hour” would be a duration because it means something different based on the current time of day, but “at noon” represents a specific, absolute time. Go uses the time.Duration type in a number of places, such as when you’d want to define how long a function should wait before returning an error or here, where you need to know how much time is between one time and another.\nNow, update your main.go file to use the Sub method on the firstTime and secondTime values and print out the results:\nprojects/datetime/main.go\n... func main() { firstTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.UTC) fmt.Println(\u0026#34;The first time is\u0026#34;, firstTime) secondTime := time.Date(2021, 12, 25, 16, 40, 55, 200, time.UTC) fmt.Println(\u0026#34;The second time is\u0026#34;, secondTime) fmt.Println(\u0026#34;Duration between first and second time is\u0026#34;, firstTime.Sub(secondTime)) fmt.Println(\u0026#34;Duration between second and first time is\u0026#34;, secondTime.Sub(firstTime)) Save your file and then run it using go run:\ngo run main.go The output will look similar to this:\nOutputThe first time is 2021-08-15 14:30:45.0000001 +0000 UTC The second time is 2021-12-25 16:40:55.0000002 +0000 UTC Duration between first and second time is -3170h10m10.0000001s Duration between second and first time is 3170h10m10.0000001s The output above says there are 3,170 hours, 10 minutes, 10 seconds, and 100 nanoseconds between the two dates, and there are a few things to note about the output. The first is that the duration between the first and second times is a negative value. This says the second time is after the first, and would be similar to if you subtracted 5 from 0 and got -5. The second thing to note is that a duration’s largest unit of measure is an hour, so it doesn’t break it down into days or months. Since the number of days in a month is not consistent and a “day” could have a different meaning during a switch for daylight saving time, an hour is the most accurate measurement that wouldn’t fluctuate.\nIn this section, you updated your program to compare two times using three different methods. First, you used the Before and After methods to determine if a time is before or after another time, then you used Sub to see how long it is between two times. Getting the duration between two times isn’t the only way the time package uses time.Duration, though. You are also able to use it to add or remove time from a time.Time value, as you’ll see in the next section.\nAdding or Subtracting Times # When writing an application, one common operation using dates and times is determining a past or future time based on another time. It could be used for functionality, such as determining when a subscription will come up for renewal next, or if it’s been a certain amount of time since some value was checked. Either way, the Go time package provides a way to handle it. To find another date based on a date you already know, though, you’ll need to be able to define your own time.Duration values.\nCreating a time.Duration value is similar to how you might write a duration on paper, just with multiplication for the unit of time. For example, to create a time.Duration to represent an hour, you would define it using the time.Hour value multiplied by the number of hours you want the time.Duration to represent:\noneHour := 1 * time.Hour twoHours := 2 * time.Hour tenHours := 10 * time.Hour Declaring smaller time units is handled in a similar way, except using time.Minute, time.Second, and so on:\ntenMinutes := 10 * time.Minute fiveSeconds := 5 * time.Second One duration can also be added to another duration to get the sum of the durations. To see this in action, open your main.go file and update it to declare a toAdd duration variable and add different durations to it:\nprojects/datetime/main.go\n... func main() { toAdd := 1 * time.Hour fmt.Println(\u0026#34;1:\u0026#34;, toAdd) toAdd += 1 * time.Minute fmt.Println(\u0026#34;2:\u0026#34;, toAdd) toAdd += 1 * time.Second fmt.Println(\u0026#34;3:\u0026#34;, toAdd) } Once you have your updates finished, save the file and run your program using go run:\ngo run main.go The output will look similar to this:\nOutput1: 1h0m0s 2: 1h1m0s 3: 1h1m1s When you look at the output, you’ll se the first duration printed is for one hour, corresponding to the 1 * time.Hour in your code. Next, you added 1 * time.Minute to the toAdd value, which shows up as the one hour, one minute value. Finally, you added 1 * time.Second to toAdd, which resulted in a time.Duration value of one hour, one minute and one second.\nIt’s also possible to combine adding the durations together in one statement, or subtracting a duration from another:\noneHourOneMinute := 1 * time.Hour + 1 * time.Minute tenMinutes := 1 * time.Hour - 50 * time.Minute Next, open your main.go file and update your program to use a combination like this to subtract one minute and one second from toAdd:\n... func main() { ... toAdd += 1 * time.Second fmt.Println(\u0026#34;3:\u0026#34;, toAdd) toAdd -= 1*time.Minute + 1*time.Second fmt.Println(\u0026#34;4:\u0026#34;, toAdd) } projects/datetime/main.go\nAfter saving your code, you can run the program using go run:\ngo run main.go The output will look similar to this:\nOutput1: 1h0m0s 2: 1h1m0s 3: 1h1m1s 4: 1h0m0s The new fourth line added to the output shows the new code you included to subtract the sum of 1 * time.Minute and 1 * time.Second worked correctly, resulting in the original one-hour value again.\nUsing these durations paired with the Add method of the time.Time type allows you to take a time value you already have and determine the time at some other arbitrary point before or after that time. To see an example of this running, open your main.go file and update it to set the toAdd value to 24 hours, or 24 * time.Hour. Then, use the Add method on a time.Time value to see what the time would be 24 hours after that point:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.UTC) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) toAdd := 24 * time.Hour fmt.Println(\u0026#34;Adding\u0026#34;, toAdd) newTime := theTime.Add(toAdd) fmt.Println(\u0026#34;The new time is\u0026#34;, newTime) } After saving your file, run your program using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 +0000 UTC Adding 24h0m0s The new time is 2021-08-16 14:30:45.0000001 +0000 UTC Looking at the output, you’ll see that adding 24 hours to 2021-08-15 results in the new date of 2021-08-16.\nTo subtract time, you would also use the Add method, which is slightly counter-intuitive. Since the Sub method is used to get the difference in time between two dates, you subtract time from the time.Time value by using Add with a negative value.\nOnce again, to see this running in your program, open your main.go file and update it to change the 24-hour toAdd value to a negative value:\nprojects/datetime/main.go\n... func main() { theTime := time.Date(2021, 8, 15, 14, 30, 45, 100, time.UTC) fmt.Println(\u0026#34;The time is\u0026#34;, theTime) toAdd := -24 * time.Hour fmt.Println(\u0026#34;Adding\u0026#34;, toAdd) newTime := theTime.Add(toAdd) fmt.Println(\u0026#34;The new time is\u0026#34;, newTime) } After saving your file, run your program one more time using go run:\ngo run main.go The output will look similar to this:\nOutputThe time is 2021-08-15 14:30:45.0000001 +0000 UTC Adding -24h0m0s The new time is 2021-08-14 14:30:45.0000001 +0000 UTC This time in the output you’ll see that instead of adding 24 hours to the original time, the new date is 24 hours before the original time.\nIn this section, you used time.Hour, time.Minute, and time.Second to create time.Duration values of varying degrees. You also used the time.Duration values with the Add method to get a new time.Time value both before and after the original value. By combining time.Now, the Add method, and Before or After methods, you’ll have access to powerful date and time functionality for your applications.\nConclusion # In this tutorial, you used time.Now to retrieve a time.Time value for the current local time on your computer, then used the Year, Month, Hour, and other methods to access specific information about that time. Then, you used the Format method to print the time using a custom format and a pre-defined format. Next, you used the time.Parse function to interpret a string value with a time in it and extract the time value from it. Once you had the time value, you used the UTC and Local methods to translate the time between UTC and your local time zone. After that, you used the Sub method to get the duration between two different times before using the Add method to find the time relative to a different time value.\nUsing the various functions and methods described in this tutorial will go a long way in your applications, but the Go time package also includes a number of other features if you’re interested.\nThis tutorial is also part of the DigitalOcean How to Code in Go series. The series covers a number of Go topics, from installing Go for the first time to how to use the language itself.\n"}]