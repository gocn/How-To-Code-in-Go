<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在 Go 中创建自定义错误 # 介绍 # GO 标准库提供了errors.Newandfmt.Errorf 这两种方法来在创建错误。但是这两种方法并不能满足你的用户或者后期调试时提供更加复杂的错误信息或者报告发生了什么。为了传递这种更复杂的错误信息并获得更多功能，我们可以实现标准库 error 接口类型。
error 接口定义如下：
type error interface { Error() string } 内置 软件包将 error 定义为具有单个 Error() 方法的接口，该接口将错误消息字符串作为返回。通过实现此方法，我们可以将定义的任何类型转换为自己的错误。
让我们尝试运行以下示例以查看 error 接口的实现：
package main import ( &#34;fmt&#34; &#34;os&#34; ) // 定义一个 MyError 的接口体 type MyError struct{} // 实现 error 接口的 Error 方法 func (m *MyError) Error() string { return &#34;boom&#34; } // 定义 sayHello 函数 // 函数返回类型为 string 和 error func sayHello() (string, error) { // 由于 *MyError 实现了 error 接口 // 所以 &MyError{} 可以作为 error 对象返回 return &#34;&#34;, &MyError{} } func main() { s, err := sayHello() if err !"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="在 Go 中创建自定义错误 # 介绍 # GO 标准库提供了errors.Newandfmt.Errorf 这两种方法来在创建错误。但是这两种方法并不能满足你的用户或者后期调试时提供更加复杂的错误信息或者报告发生了什么。为了传递这种更复杂的错误信息并获得更多功能，我们可以实现标准库 error 接口类型。
error 接口定义如下：
type error interface { Error() string } 内置 软件包将 error 定义为具有单个 Error() 方法的接口，该接口将错误消息字符串作为返回。通过实现此方法，我们可以将定义的任何类型转换为自己的错误。
让我们尝试运行以下示例以查看 error 接口的实现：
package main import ( &#34;fmt&#34; &#34;os&#34; ) // 定义一个 MyError 的接口体 type MyError struct{} // 实现 error 接口的 Error 方法 func (m *MyError) Error() string { return &#34;boom&#34; } // 定义 sayHello 函数 // 函数返回类型为 string 和 error func sayHello() (string, error) { // 由于 *MyError 实现了 error 接口 // 所以 &MyError{} 可以作为 error 对象返回 return &#34;&#34;, &MyError{} } func main() { s, err := sayHello() if err !"><meta property="og:type" content="article"><meta property="og:url" content="https://gocn.github.io/How-To-Code-in-Go/docs/18-Creating_Custom_Errors_in_Go_DigitalOcean/"><meta property="article:section" content="docs"><title>18 Creating Custom Errors in Go Digital Ocean | How To Code in Go</title><link rel=manifest href=/How-To-Code-in-Go/manifest.json><link rel=icon href=/How-To-Code-in-Go/favicon.png type=image/x-icon><link rel=stylesheet href=/How-To-Code-in-Go/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/How-To-Code-in-Go/flexsearch.min.js></script>
<script defer src=/How-To-Code-in-Go/zh.search.min.2cef17e458d113aaf1f002ffbd3994b6a5ea63c26ee7424573fe23509278939e.js integrity="sha256-LO8X5FjRE6rx8AL/vTmUtqXqY8Ju50JFc/4jUJJ4k54=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/How-To-Code-in-Go/><span>How To Code in Go</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><p><strong>开始学习</strong></p><ul><li><a href=/How-To-Code-in-Go/docs/01-How_To_Install_Go_and_Set_Up_a_Local-Programming_Environment_on_Ubuntu_18.04_DigitalOcean/>1. 如何在 Ubuntu 18.04 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/02-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_macOS_DigitalOcean/>2. 如何在 macOS 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/03-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_Windows_10_DigitalOcean/>3. 如何在 Windows 10 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/04-How_To_Write_Your_First_Program_in_Go_DigitalOcean/>4. 如何用 Go 编写你的第一个程序</a></li><li><a href=/How-To-Code-in-Go/docs/05-Understanding_the_GOPATH/>5. 理解 GOPATH</a></li><li><a href=/How-To-Code-in-Go/docs/06-How_To_Write_Comments_in_Go/>6. 如何在 Go 中写注释</a></li><li><a href=/How-To-Code-in-Go/docs/07-Understanding_Data_Types_in_Go/>7. 理解 Go 的数据类型</a></li><li><a href=/How-To-Code-in-Go/docs/08-An_Introduction_to_Working_with_Strings_in_Go/>8. Go 中处理字符串的介绍</a></li><li><a href=/How-To-Code-in-Go/docs/09-How_To_Format_Strings_in_Go/>9. 如何在 Go 中格式化字符串</a></li><li><a href=/How-To-Code-in-Go/docs/10-An_Introduction_to_the_Strings_Package_in_Go/>10. 介绍 Go 中的 Strings 包</a></li><li><a href=/How-To-Code-in-Go/docs/11-How_To_Use_Variables_and_Constants_in_Go/>11. 如何在 Go 中使用变量和常量</a></li><li><a href=/How-To-Code-in-Go/docs/12-How_To_Convert_Data_Types_in_Go/>12. 如何在 Go 中转换数据类型</a></li><li><a href=/How-To-Code-in-Go/docs/13-How_To_Do_Math_in_Go_with_Operators/>13. 如何用运算符在 Go 中做数学计算</a></li><li><a href=/How-To-Code-in-Go/docs/14-Understanding_Boolean_Logic_in_Go/>14. 理解 Go 中的布尔逻辑</a></li><li><a href=/How-To-Code-in-Go/docs/15-Understanding_Maps_in_Go/>15. 理解 Go 中的 Map</a></li><li><a href=/How-To-Code-in-Go/docs/16-Understanding_Arrays_and_Slices_in_Go/>16. 理解 Go 中的数组和切片</a></li><li><a href=/How-To-Code-in-Go/docs/17-Handling_Errors_in_Go_DigitalOcean/>17. 在 Go 中处理错误</a></li><li><a href=/How-To-Code-in-Go/docs/18-Creating_Custom_Errors_in_Go_DigitalOcean/ class=active>18. 在 Go 中创建自定义错误</a></li><li><a href=/How-To-Code-in-Go/docs/19-Handling_Panics_in_Go-_DigitalOcean/>19 在 Go 中处理恐慌</a></li><li><a href=/How-To-Code-in-Go/docs/20-Importing_Packages_in_Go_DigitalOcean/>20. 在 Go 中导入包</a></li><li><a href=/How-To-Code-in-Go/docs/21-How_To_Write_Packages_in_Go/>21. 如何在 Go 中编写包</a></li><li><a href=/How-To-Code-in-Go/docs/22-Understanding_Package_Visibility_in_Go/>22. 理解 Go 中包的可见性</a></li><li><a href=/How-To-Code-in-Go/docs/23-How_To_Write_Conditional_Statements_in_Go/>23. 如何在 Go 中编写条件语句</a></li><li><a href=/How-To-Code-in-Go/docs/24-How_To_Write_Switch_Statements_in_Go/>24. 如何在 Go 中编写 Switch 语句</a></li><li><a href=/How-To-Code-in-Go/docs/25-How_To_Construct_For_Loops_in_Go/>25. 如何在 Go 中构造 for 循环</a></li><li><a href=/How-To-Code-in-Go/docs/26-Using_Break_and_Continue_Statements_When_Working_with_Loops_in_Go/>26. 在循环中使用 Break 和 Continue</a></li><li><a href=/How-To-Code-in-Go/docs/27-How_To_Define_and_Call_Functions_in_Go/>27. 如何在 Go 中定义并调用函数</a></li><li><a href=/How-To-Code-in-Go/docs/28-How_To_Use_Variadic_Functions_in_Go/>28. 如何在 Go 中使用可变参数函数</a></li><li><a href=/How-To-Code-in-Go/docs/29-Understanding_defer_in_Go/>29. 理解 Go 中的 defer</a></li><li><a href=/How-To-Code-in-Go/docs/30-Understanding_init_in_Go/>30. 理解 Go 中的 init</a></li><li><a href=/How-To-Code-in-Go/docs/31-Customizing_Go_Binaries_with_Build_Tags/>31. 用构建标签定制 Go 二进制文件</a></li><li><a href=/How-To-Code-in-Go/docs/32-Understanding_Pointers_in_Go/>32. 理解 Go 中的指针</a></li><li><a href=/How-To-Code-in-Go/docs/33-Defining_Structs_in_Go/>33. 在 Go 中定义结构体</a></li><li><a href=/How-To-Code-in-Go/docs/34-Defining_Methods_in_Go/>34. 在 Go 中定义方法</a></li><li><a href=/How-To-Code-in-Go/docs/35-How_To_Build_and_Install_Go_Programs/>35. 如何构建和安装 Go 程序</a></li><li><a href=/How-To-Code-in-Go/docs/36-How_To_Use_Struct_Tags_in_Go/>36. 如何在 Go 中使用结构体标签</a></li><li><a href=/How-To-Code-in-Go/docs/37-How_To_Use_Interfaces_in_Go/>37. 如何在 Go 使用 interface</a></li><li><a href=/How-To-Code-in-Go/docs/38-Building_Go_Applications_for_Different_Operating_Systems_and_Architectures/>38. 在不同的操作系统和架构编译 Go 应用</a></li><li><a href=/How-To-Code-in-Go/docs/39-Using_ldflags_to_Set_Version_Information_for_Go_Applications/>39. 用 ldflags 设置 Go 应用程序的版本信息</a></li><li><a href=/How-To-Code-in-Go/docs/40-How_To_Use_the_Flag_Package_in_Go/>40. 在 Go 里面如何使用 Flag 包</a></li></ul></li><li><p><strong>附录：资源</strong></p></li><li><p><a href=https://github.com/gocn/How-To-Code-in-Go><strong>Fork on Github</strong></a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/How-To-Code-in-Go/svg/menu.svg class=book-icon alt=Menu></label>
<strong>18 Creating Custom Errors in Go Digital Ocean</strong>
<label for=toc-control><img src=/How-To-Code-in-Go/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#自定义错误收集详细信息>自定义错误收集详细信息</a></li><li><a href=#类型断言和自定义错误>类型断言和自定义错误</a></li><li><a href=#包装错误>包装错误</a></li><li><a href=#总结>总结</a></li></ul></nav></aside></header><article class=markdown><h1 id=在-go-中创建自定义错误>在 Go 中创建自定义错误
<a class=anchor href=#%e5%9c%a8-go-%e4%b8%ad%e5%88%9b%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89%e9%94%99%e8%af%af>#</a></h1><h2 id=介绍>介绍
<a class=anchor href=#%e4%bb%8b%e7%bb%8d>#</a></h2><p>GO 标准库提供了<a href=https://gocn.github.io/How-To-Code-in-Go/docs/17-Handling_Errors_in_Go_DigitalOcean/#%E5%88%9B%E5%BB%BA%E9%94%99%E8%AF%AF><code>errors.New</code>and<code>fmt.Errorf</code></a> 这两种方法来在创建错误。但是这两种方法并不能满足你的用户或者后期调试时提供更加复杂的错误信息或者报告发生了什么。为了传递这种更复杂的错误信息并获得更多功能，我们可以实现标准库 <code>error</code> 接口类型。</p><p><code>error</code> 接口定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>error</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://golang.org/pkg/builtin/><code>内置</code></a> 软件包将 <code>error</code> 定义为具有单个 <code>Error()</code> 方法的接口，该接口将错误消息字符串作为返回。通过实现此方法，我们可以将定义的任何类型转换为自己的错误。</p><p>让我们尝试运行以下示例以查看 <code>error</code> 接口的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义一个 MyError 的接口体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyError</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 实现 error 接口的 Error 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;boom&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义 sayHello 函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 函数返回类型为 string 和 error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sayHello</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 由于 *MyError 实现了 error 接口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 所以 &amp;MyError{} 可以作为 error 对象返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>MyError</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sayHello</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;unexpected error: err:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;The string:&#34;</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们将看到以下输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>unexpected error: err: boom
</span></span><span style=display:flex><span>exit status <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>在这里，我们创建了一个新的空结构类型 <code>MyError</code>，并在其上定义了 <code>Error()</code> 方法。<code>Error()</code> 方法返回字符串 <code>"Boom"</code>。</p><p>在 <code>main()</code> 中，我们调用 <code>sayhello</code> 函数，该函数返回一个空字符串和一个新 <code>MyError</code> 实例。由于 <code>sayhello</code> 将始终返回错误，因此在<code>main()</code> 中的 <code>if</code> 语句主体内的 <code>fmt.Println</code> 调用将始终执行。我们使用 <code>fmt.Println</code> 来打印短前缀字符串 <code>"unexpected error:"</code>以及在保存<code>MyError</code> 实例中的在 <code>err</code> 变量。</p><blockquote><p>值得注意的是，我们不必直接调用 <code>Error()</code>，因为 <code>fmt</code> 包能够自动检测到已经实现了 <code>error</code> 接口。它 <a href=https://en.wikipedia.org/wiki/Transparency_%28human%E2%80%93computer_interaction%29>透明</a> 地调用 <code>Error()</code> 来获取字符串 <code>"hoom"</code>，并将其与前缀字符串 <code>"unexpected error: err:"</code> 相连。</p></blockquote><h2 id=自定义错误收集详细信息>自定义错误收集详细信息
<a class=anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e9%94%99%e8%af%af%e6%94%b6%e9%9b%86%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af>#</a></h2><p>有时，自定义错误是捕获详细错误信息的最有效的方式。例如，假设我们要捕获 HTTP 请求产生的错误的状态代码；运行以下程序以查看 <code>error</code> 的实现，使我们能够清晰捕获该信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RequestError</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>StatusCode</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RequestError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;status %d: err %v&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>StatusCode</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doRequest</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>RequestError</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>StatusCode</span>: <span style=color:#ae81ff>503</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Err</span>:        <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unavailable&#34;</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>doRequest</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;success!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们将看到以下输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>status 503: err unavailable
</span></span><span style=display:flex><span>exit status <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>在此示例中，我们创建了创建一个错误的 <code>RequestError</code> 的新实例, 其中包含一个状态码和使用标准库提供的 <code>errors.New</code> 函数创建的 <code>err</code>。之后，如前所述，我们使用 <code>fmt.Println</code> 打印了错误信息。</p><p>在 <code>RequestError</code> 的 <code>Error()</code> 方法中，我们使用创建 <code>error</code> 对象时提供的信息和 <code>fmt.Sprintf</code> 函数构造字符串。</p><h2 id=类型断言和自定义错误>类型断言和自定义错误
<a class=anchor href=#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e9%94%99%e8%af%af>#</a></h2><p><code>error</code> 接口仅公开一种方法，但是为了正确处理错误, 我们可能需要访问 <code>error</code> 实现类型的其他方法。例如，我们可能有几个暂时的自定义错误实现，可以通过 <code>Temporary()</code> 方法的存在来重述。</p><p>接口为类型提供的更广泛的方法集提中供了一个狭窄的视图，因此，我们必须使用类型断言来更改视图正在显示的方法，或完全删除它。</p><p>下面的示例增加了前面显示的 <code>RequestError</code> 具有 <code>Temporary()</code> 方法，该方法将指示调用者是否应重试请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RequestError</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>StatusCode</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RequestError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Err</span>.<span style=color:#a6e22e>Error</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RequestError</span>) <span style=color:#a6e22e>Temporary</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果状态码是 503 返回 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>StatusCode</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusServiceUnavailable</span> <span style=color:#75715e>// 503
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>doRequest</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>RequestError</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>StatusCode</span>: <span style=color:#ae81ff>503</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Err</span>:        <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unavailable&#34;</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>doRequest</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 进行类型断言
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>re</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>RequestError</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果类型断言成功
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>re</span>.<span style=color:#a6e22e>Temporary</span>() {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;This request can be tried again&#34;</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;This request cannot be tried again&#34;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;success!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们将看到以下输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>unavailable
</span></span><span style=display:flex><span>This request can be tried again
</span></span><span style=display:flex><span>exit status <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>在 <code>main()</code> 中，我们调用 <code>doRequest()</code> 将错误接口返回给我们。我们首先打印由 <code>Error()</code> 方法返回的错误消息。接下来，我们尝试通过使用类型的断言 <code>re, ok := err.(*RequestError)</code>。如果类型断言成功，我们然后使用 <code>Temporary()</code> 方法来查看此错误是否是临时错误。由于<code>doRequest()</code> 设置的状态代码为 <code>503</code>，它匹配 <code>HTTP.Statusserviceunavailable</code>，因此将返回 <code>true</code>，并且要打印<code>"This request can be tried again"</code> 的原因。实际上，我们将提出另一个请求，而不是打印消息。</p><h2 id=包装错误>包装错误
<a class=anchor href=#%e5%8c%85%e8%a3%85%e9%94%99%e8%af%af>#</a></h2><p>通常，错误是从程序的外部产生(例如：数据库，网络连接等)。这些错误提供的错误消息不能够帮助任何人找到错误的根源。有必要在错误消息开始时，将错误与额外信息包装，将为成功调试提供一些必要的上下文。</p><p>下面的示例说明了我们如何将一些上下文信息附加到从其他功能中返回的其他隐性错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义一个错误的包装类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WrappedError</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 上下文信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Context</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 具体错误内容
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Err</span>     <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WrappedError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s: %v&#34;</span>, <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>, <span style=color:#a6e22e>info</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>WrappedError</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>WrappedError</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Context</span>: <span style=color:#a6e22e>info</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Err</span>:     <span style=color:#a6e22e>err</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;boom!&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;main&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们将看到以下输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Output</span>
</span></span><span style=display:flex><span>main: boom!
</span></span></code></pre></div><p><code>WrappedError</code> 是一个具有两个字段的结构：字符串类型的 <code>context</code> 字段和 <code>error</code>, 这让 <code>WrappedError</code> 提供了更多信息。当调用 <code>Error()</code> 方法时，我们再次使用 <code>fmt.Sprintf</code> 打印上下文消息和 <code>error</code>(<code>fmt.Sprintf</code> 也会隐式调用 <code>err</code> 的 <code>Error()</code> 方法)。</p><p>在 <code>main()</code> 中，我们使用 <code>errors.New</code> 创建一个错误，然后我们使用定义的 <code>Wrap</code> 函数包装该错误。这使我们可以指出此错误是在 <code>"main"</code> 中生成的。另外，由于我们的 <code>WrappedError</code> 也是一个 <code>error</code>，因此我们也可以包装其它的<code>WrappedError</code> - 这将使我们看到链条来帮助我们追踪错误源。在标准库的一点帮助下，我们甚至可以在错误中嵌入完整的堆栈跟踪。</p><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><p>由于 <code>error</code> 接口只提供一种方法，我们已经看到，在为不同情况提供不同类型的错误方面，我们有很大的灵活性。这可以包含所有内容，从传达多个信息作为错误的一部分到实现 <a href=https://en.wikipedia.org/wiki/Exponential_backoff>指数退回</a>。尽管表面上的错误处理机制似乎很简单，但我们可以使用这些自定义错误来处理常见和不常见情况。</p><p>GO 有另一种传达意外行为的机制，panic。在错误处理系列的下一篇文章中，我们将检查恐慌 - 它们是什么以及如何处理它们。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#自定义错误收集详细信息>自定义错误收集详细信息</a></li><li><a href=#类型断言和自定义错误>类型断言和自定义错误</a></li><li><a href=#包装错误>包装错误</a></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></main></body></html>