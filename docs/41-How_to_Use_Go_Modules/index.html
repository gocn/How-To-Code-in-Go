<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="如何使用 Go 模块 # 简介 # 在 1.13 版本，Go 的作者增加了一种管理 Go 项目依赖库的新方法，称之为 Go 模块。Go 模块的加入是为了满足日益增长的需求，使开发者更容易维护其依赖的各种版本，同时也为开发者在计算机上组织项目的方式上，增加了更多的灵活性。Go 模块通常由一个项目或库组成，并包含一系列的 Go 包，然后一起发布。Go 模块解决了原始系统 GOPATH 的许多问题，它允许用户将项目代码放在他们选择的目录中，并为每个模块指定依赖的版本。
在本教程中，你将创建你自己的公共 Go module，并为你的新模块添加一个包。此外，你还将把别人的公共模块添加到你自己的项目中，以及把该模块的一个特定版本添加到你的项目中。
前期准备 # 要遵循本教程，你将需要：
安装1.16 或更高版本的 Go。如何安装 Go ，请根据你的操作系统遵循 如何安装Go 教程。 熟悉用 Go 编写软件包。要了解更多，请遵循 如何用 Go 编写包 教程。 创建一个新的模块 # 乍看之下，Go模块与 Go包 有些相似。一个模块有许多实现包的功能的 Go 代码文件，但它在根部还有两个额外的重要文件：go.mod 文件和 go.sum 文件。这些文件包含了 go 工具用来跟踪你的模块配置的信息，通常由工具维护，所以你不需要维护。
首先要做的是决定模块所处的目录。随着 Go 模块的引入，Go 项目有可能位于文件系统的任何地方，而不仅仅是 Go 定义的特定目录。你可能已经有了一个存放项目的目录，但在本教程中，你将创建一个名为 projects 的目录，新模块将被称为 mymodule。你可以通过 IDE 或者命令行来创建 projects 目录。
如果你使用的是命令行，首先新建 projects目录并进入其中：
mkdir projects cd projects 接下来，你将创建模块目录本身。通常，模块的顶层目录名称与模块名称相同，这使得模块配置的信息更容易被追踪。在你的 projects 目录下，运行以下命令来创建 mymodule 目录："><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="如何使用 Go 模块 # 简介 # 在 1.13 版本，Go 的作者增加了一种管理 Go 项目依赖库的新方法，称之为 Go 模块。Go 模块的加入是为了满足日益增长的需求，使开发者更容易维护其依赖的各种版本，同时也为开发者在计算机上组织项目的方式上，增加了更多的灵活性。Go 模块通常由一个项目或库组成，并包含一系列的 Go 包，然后一起发布。Go 模块解决了原始系统 GOPATH 的许多问题，它允许用户将项目代码放在他们选择的目录中，并为每个模块指定依赖的版本。
在本教程中，你将创建你自己的公共 Go module，并为你的新模块添加一个包。此外，你还将把别人的公共模块添加到你自己的项目中，以及把该模块的一个特定版本添加到你的项目中。
前期准备 # 要遵循本教程，你将需要：
安装1.16 或更高版本的 Go。如何安装 Go ，请根据你的操作系统遵循 如何安装Go 教程。 熟悉用 Go 编写软件包。要了解更多，请遵循 如何用 Go 编写包 教程。 创建一个新的模块 # 乍看之下，Go模块与 Go包 有些相似。一个模块有许多实现包的功能的 Go 代码文件，但它在根部还有两个额外的重要文件：go.mod 文件和 go.sum 文件。这些文件包含了 go 工具用来跟踪你的模块配置的信息，通常由工具维护，所以你不需要维护。
首先要做的是决定模块所处的目录。随着 Go 模块的引入，Go 项目有可能位于文件系统的任何地方，而不仅仅是 Go 定义的特定目录。你可能已经有了一个存放项目的目录，但在本教程中，你将创建一个名为 projects 的目录，新模块将被称为 mymodule。你可以通过 IDE 或者命令行来创建 projects 目录。
如果你使用的是命令行，首先新建 projects目录并进入其中：
mkdir projects cd projects 接下来，你将创建模块目录本身。通常，模块的顶层目录名称与模块名称相同，这使得模块配置的信息更容易被追踪。在你的 projects 目录下，运行以下命令来创建 mymodule 目录："><meta property="og:type" content="article"><meta property="og:url" content="https://gocn.github.io/How-To-Code-in-Go/docs/41-How_to_Use_Go_Modules/"><meta property="article:section" content="docs"><title>41 How to Use Go Modules | How To Code in Go</title><link rel=manifest href=/How-To-Code-in-Go/manifest.json><link rel=icon href=/How-To-Code-in-Go/favicon.png type=image/x-icon><link rel=stylesheet href=/How-To-Code-in-Go/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/How-To-Code-in-Go/flexsearch.min.js></script>
<script defer src=/How-To-Code-in-Go/zh.search.min.2ccdafc211784f64f63652981924d269b4ff643413814bfc0d5743573b76ade7.js integrity="sha256-LM2vwhF4T2T2NlKYGSTSabT/ZDQTgUv8DVdDVzt2rec=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/How-To-Code-in-Go/><span>How To Code in Go</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><p><strong>开始学习</strong></p><ul><li><a href=/How-To-Code-in-Go/docs/01-How_To_Install_Go_and_Set_Up_a_Local-Programming_Environment_on_Ubuntu_18.04_DigitalOcean/>1. 如何在 Ubuntu 18.04 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/02-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_macOS_DigitalOcean/>2. 如何在 macOS 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/03-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_Windows_10_DigitalOcean/>3. 如何在 Windows 10 上安装 Go 和设置本地编程环境</a></li><li><a href=/How-To-Code-in-Go/docs/04-How_To_Write_Your_First_Program_in_Go_DigitalOcean/>4. 如何用 Go 编写你的第一个程序</a></li><li><a href=/How-To-Code-in-Go/docs/05-Understanding_the_GOPATH/>5. 理解 GOPATH</a></li><li><a href=/How-To-Code-in-Go/docs/06-How_To_Write_Comments_in_Go/>6. 如何在 Go 中写注释</a></li><li><a href=/How-To-Code-in-Go/docs/07-Understanding_Data_Types_in_Go/>7. 理解 Go 的数据类型</a></li><li><a href=/How-To-Code-in-Go/docs/08-An_Introduction_to_Working_with_Strings_in_Go/>8. Go 中处理字符串的介绍</a></li><li><a href=/How-To-Code-in-Go/docs/09-How_To_Format_Strings_in_Go/>9. 如何在 Go 中格式化字符串</a></li><li><a href=/How-To-Code-in-Go/docs/10-An_Introduction_to_the_Strings_Package_in_Go/>10. 介绍 Go 中的 Strings 包</a></li><li><a href=/How-To-Code-in-Go/docs/11-How_To_Use_Variables_and_Constants_in_Go/>11. 如何在 Go 中使用变量和常量</a></li><li><a href=/How-To-Code-in-Go/docs/12-How_To_Convert_Data_Types_in_Go/>12. 如何在 Go 中转换数据类型</a></li><li><a href=/How-To-Code-in-Go/docs/13-How_To_Do_Math_in_Go_with_Operators/>13. 如何用运算符在 Go 中做数学计算</a></li><li><a href=/How-To-Code-in-Go/docs/14-Understanding_Boolean_Logic_in_Go/>14. 理解 Go 中的布尔逻辑</a></li><li><a href=/How-To-Code-in-Go/docs/15-Understanding_Maps_in_Go/>15. 理解 Go 中的 Map</a></li><li><a href=/How-To-Code-in-Go/docs/16-Understanding_Arrays_and_Slices_in_Go/>16. 理解 Go 中的数组和切片</a></li><li><a href=/How-To-Code-in-Go/docs/17-Handling_Errors_in_Go_DigitalOcean/>17. 在 Go 中处理错误</a></li><li><a href=/How-To-Code-in-Go/docs/18-Creating_Custom_Errors_in_Go_DigitalOcean/>18. 在 Go 中创建自定义错误</a></li><li><a href=/How-To-Code-in-Go/docs/19-Handling_Panics_in_Go-_DigitalOcean/>19 在 Go 中处理恐慌</a></li><li><a href=/How-To-Code-in-Go/docs/20-Importing_Packages_in_Go_DigitalOcean/>20. 在 Go 中导入包</a></li><li><a href=/How-To-Code-in-Go/docs/21-How_To_Write_Packages_in_Go/>21. 如何在 Go 中编写包</a></li><li><a href=/How-To-Code-in-Go/docs/22-Understanding_Package_Visibility_in_Go/>22. 理解 Go 中包的可见性</a></li><li><a href=/How-To-Code-in-Go/docs/23-How_To_Write_Conditional_Statements_in_Go/>23. 如何在 Go 中编写条件语句</a></li><li><a href=/How-To-Code-in-Go/docs/24-How_To_Write_Switch_Statements_in_Go/>24. 如何在 Go 中编写 Switch 语句</a></li><li><a href=/How-To-Code-in-Go/docs/25-How_To_Construct_For_Loops_in_Go/>25. 如何在 Go 中构造 for 循环</a></li><li><a href=/How-To-Code-in-Go/docs/26-Using_Break_and_Continue_Statements_When_Working_with_Loops_in_Go/>26. 在循环中使用 Break 和 Continue</a></li><li><a href=/How-To-Code-in-Go/docs/27-How_To_Define_and_Call_Functions_in_Go/>27. 如何在 Go 中定义并调用函数</a></li><li><a href=/How-To-Code-in-Go/docs/28-How_To_Use_Variadic_Functions_in_Go/>28. 如何在 Go 中使用可变参数函数</a></li><li><a href=/How-To-Code-in-Go/docs/29-Understanding_defer_in_Go/>29. 理解 Go 中的 defer</a></li><li><a href=/How-To-Code-in-Go/docs/30-Understanding_init_in_Go/>30. 理解 Go 中的 init</a></li><li><a href=/How-To-Code-in-Go/docs/31-Customizing_Go_Binaries_with_Build_Tags/>31. 用构建标签定制 Go 二进制文件</a></li><li><a href=/How-To-Code-in-Go/docs/32-Understanding_Pointers_in_Go/>32. 理解 Go 中的指针</a></li><li><a href=/How-To-Code-in-Go/docs/33-Defining_Structs_in_Go/>33. 在 Go 中定义结构体</a></li><li><a href=/How-To-Code-in-Go/docs/34-Defining_Methods_in_Go/>34. 在 Go 中定义方法</a></li><li><a href=/How-To-Code-in-Go/docs/35-How_To_Build_and_Install_Go_Programs/>35. 如何构建和安装 Go 程序</a></li><li><a href=/How-To-Code-in-Go/docs/36-How_To_Use_Struct_Tags_in_Go/>36. 如何在 Go 中使用结构体标签</a></li><li><a href=/How-To-Code-in-Go/docs/37-How_To_Use_Interfaces_in_Go/>37. 如何在 Go 使用 interface</a></li><li><a href=/How-To-Code-in-Go/docs/38-Building_Go_Applications_for_Different_Operating_Systems_and_Architectures/>38. 在不同的操作系统和架构编译 Go 应用</a></li><li><a href=/How-To-Code-in-Go/docs/39-Using_ldflags_to_Set_Version_Information_for_Go_Applications/>39. 用 ldflags 设置 Go 应用程序的版本信息</a></li><li><a href=/How-To-Code-in-Go/docs/40-How_To_Use_the_Flag_Package_in_Go/>40. 在 Go 里面如何使用 Flag 包</a></li><li><a href=/How-To-Code-in-Go/docs/41-How_to_Use_Go_Modules/ class=active>41. 如何使用 Go 模块</a></li><li><a href=/How-To-Code-in-Go/docs/42-How_to_Distribute_Go_Modules/>42. 如何分发 Go 模块</a></li><li><a href=/How-To-Code-in-Go/docs/43-How_to_Use_a_Private_Go_Module_in_Your_Own_Project/>43. 如何在自己的项目中使用私有的Go模块</a></li></ul></li><li><p><strong>附录：资源</strong></p></li><li><p><a href=https://github.com/gocn/How-To-Code-in-Go><strong>Fork on Github</strong></a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/How-To-Code-in-Go/svg/menu.svg class=book-icon alt=Menu></label>
<strong>41 How to Use Go Modules</strong>
<label for=toc-control><img src=/How-To-Code-in-Go/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#前期准备>前期准备</a></li><li><a href=#创建一个新的模块>创建一个新的模块</a></li><li><a href=#了解-gomod-文件>了解 <code>go.mod</code> 文件</a></li><li><a href=#在你的模块中添加go代码>在你的模块中添加Go代码</a></li><li><a href=#为你的模块添加一个包>为你的模块添加一个包</a></li><li><a href=#添加一个远程模块作为依赖>添加一个远程模块作为依赖</a></li><li><a href=#使用一个模块的特定版本>使用一个模块的特定版本</a></li><li><a href=#总结>总结</a></li></ul></nav></aside></header><article class=markdown><h1 id=如何使用-go-模块>如何使用 Go 模块
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-go-%e6%a8%a1%e5%9d%97>#</a></h1><h2 id=简介>简介
<a class=anchor href=#%e7%ae%80%e4%bb%8b>#</a></h2><p>在 1.13 版本，Go 的作者增加了一种管理 Go 项目依赖库的新方法，称之为 <a href=https://golang.org/ref/mod>Go 模块</a>。Go 模块的加入是为了满足日益增长的需求，使开发者更容易维护其依赖的各种版本，同时也为开发者在计算机上组织项目的方式上，增加了更多的灵活性。Go 模块通常由一个项目或库组成，并包含一系列的 Go 包，然后一起发布。Go 模块解决了原始系统 <a href=https://golang.org/doc/gopath_code><code>GOPATH</code></a> 的许多问题，它允许用户将项目代码放在他们选择的目录中，并为每个模块指定依赖的版本。</p><p>在本教程中，你将创建你自己的公共 Go module，并为你的新模块添加一个包。此外，你还将把别人的公共模块添加到你自己的项目中，以及把该模块的一个特定版本添加到你的项目中。</p><h2 id=前期准备>前期准备
<a class=anchor href=#%e5%89%8d%e6%9c%9f%e5%87%86%e5%a4%87>#</a></h2><p>要遵循本教程，你将需要：</p><ul><li>安装1.16 或更高版本的 Go。如何安装 Go ，请根据你的操作系统遵循 <a href=https://gocn.github.io/How-To-Code-in-Go/docs/01-How_To_Install_Go_and_Set_Up_a_Local-Programming_Environment_on_Ubuntu_18.04_DigitalOcean/>如何安装Go</a> 教程。</li><li>熟悉用 Go 编写软件包。要了解更多，请遵循 <a href=https://gocn.github.io/How-To-Code-in-Go/docs/21-How_To_Write_Packages_in_Go/>如何用 Go 编写包</a> 教程。</li></ul><h2 id=创建一个新的模块>创建一个新的模块
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84%e6%a8%a1%e5%9d%97>#</a></h2><p>乍看之下，Go模块与 <a href=https://gocn.github.io/How-To-Code-in-Go/docs/21-How_To_Write_Packages_in_Go/>Go包</a> 有些相似。一个模块有许多实现包的功能的 Go 代码文件，但它在根部还有两个额外的重要文件：<code>go.mod</code> 文件和 <code>go.sum</code> 文件。这些文件包含了 <code>go</code> 工具用来跟踪你的模块配置的信息，通常由工具维护，所以你不需要维护。</p><p>首先要做的是决定模块所处的目录。随着 Go 模块的引入，Go 项目有可能位于文件系统的任何地方，而不仅仅是 Go 定义的特定目录。你可能已经有了一个存放项目的目录，但在本教程中，你将创建一个名为 <code>projects</code> 的目录，新模块将被称为 <code>mymodule</code>。你可以通过 IDE 或者命令行来创建 <code>projects</code> 目录。</p><p>如果你使用的是命令行，首先新建 <code>projects</code>目录并进入其中：</p><pre tabindex=0><code>mkdir projects
cd projects
</code></pre><p>接下来，你将创建模块目录本身。通常，模块的顶层目录名称与模块名称相同，这使得模块配置的信息更容易被追踪。在你的 <code>projects</code> 目录下，运行以下命令来创建 <code>mymodule</code> 目录：</p><pre tabindex=0><code>mkdir mymodule
</code></pre><p>一旦你创建了模块目录，目录结构将看起来像这样：</p><pre tabindex=0><code>└── projects
    └── mymodule
</code></pre><p>下一步是在 <code>mymodule</code> 目录下创建一个 <code>go.mod</code> 文件来定义 Go 模块本身。要做到这一点，你要使用 <code>go</code> 工具的 <code>mod init</code> 命令，并向它提供模块的名称，在这个例子中是 <code>mymodule</code>。现在通过在 <code>mymodule</code> 目录下运行 <code>go mod init</code> 来创建模块，并向它提供模块的名称 <code>mymodule</code>：</p><pre tabindex=0><code>go mod init mymodule
</code></pre><p>该命令在创建模块时将返回以下输出：</p><pre tabindex=0><code>Output
go: creating new go.mod: module mymodule
</code></pre><p>随着模块的创建，你的目录结构现在看起来会是这样：</p><pre tabindex=0><code>└── projects
    └── mymodule
        └── go.mod
</code></pre><p>现在你已经创建了一个模块，让我们看一下 <code>go.mod</code> 文件的内容，看看 <code>go mod init</code> 命令做了什么。</p><h2 id=了解-gomod-文件>了解 <code>go.mod</code> 文件
<a class=anchor href=#%e4%ba%86%e8%a7%a3-gomod-%e6%96%87%e4%bb%b6>#</a></h2><p>当你用 <code>go</code> 工具运行命令时，<code>go.mod</code> 文件是一个非常重要的部分。它是包含模块名称和你自己模块所依赖的其他模块的版本的文件。它还可以包含其他指令，如 <a href=https://golang.org/ref/mod#go-mod-file-replace><code>replace</code></a>，这对同时进行多个模块的开发很有帮助。</p><p>在 <code>mymodule</code> 目录下，用 <code>nano</code> 或你喜欢的文本编辑器打开 <code>go.mod</code> 文件：</p><pre tabindex=0><code>nano go.mod
</code></pre><p>内容将看起来与此类似，这并不重要：</p><p>projects/mymodule/go.mod</p><pre tabindex=0><code>module mymodule

go 1.16
</code></pre><p>第一行，<code>module</code> 指令，告诉 Go 你的模块名称，这样当它在包中寻找 <code>import</code> 路径时，它就不会在其他地方寻找 <code>mymodule</code>。<code>mymodule</code> 的值来自你传递给 <code>go mod init</code> 的参数：</p><pre tabindex=0><code>module mymodule
</code></pre><p>文件中的另外一行，即 <code>go</code> 指令，告诉 Go 模块所针对的语言版本。在本例中，由于该模块是用 Go 1.16 创建的，所以 <code>go</code> 指令显示为 <code>1.16</code> ：</p><pre tabindex=0><code>go 1.16
</code></pre><p>随着更多的信息被添加到模块中，这个文件将被扩展，但现在看看它是个好主意，看看它是如何随着依赖关系的进一步添加而变化的。</p><p>现在你已经用 <code>go mod init</code> 创建了一个 Go 模块，并查看了初始 <code>go.mod</code> 文件的内容，但你的模块还没有做任何事情。现在是时候让你的模块更进一步，添加一些代码了。</p><h2 id=在你的模块中添加go代码>在你的模块中添加Go代码
<a class=anchor href=#%e5%9c%a8%e4%bd%a0%e7%9a%84%e6%a8%a1%e5%9d%97%e4%b8%ad%e6%b7%bb%e5%8a%a0go%e4%bb%a3%e7%a0%81>#</a></h2><p>为了确保模块被正确创建，并添加代码以便你能运行你的第一个 Go 模块，你将在 <code>mymodule</code> 目录下创建一个 <code>main.go</code> 文件。<code>main.go</code> 文件在 Go 程序中通常用来表示程序的起始点。该文件的名称并不像里面的 <code>main</code> 函数那么重要，但两者的匹配使其更容易被找到。在本教程中，<code>main</code> 函数在运行时将打印出 <code>Hello, Modules!</code>。</p><p>要创建这个文件，用 <code>nano</code> 或你喜欢的文本编辑器打开 <code>main.go</code> 文件：</p><pre tabindex=0><code>nano main.go
</code></pre><p>在 <code>main.go</code> 文件中，添加以下代码来定义你的 <code>main</code> 包，导入 <code>fmt</code> 包，然后在 <code>main</code> 函数中打印出 <code>Hello, Modules!</code>信息：</p><p>projects/mymodule/main.go</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello, Modules!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Go 中，每个目录都被视为自己的包，每个文件都有自己的 <code>package</code> 声明行。在你刚刚创建的 <code>main.go</code> 文件中，<code>包</code> 被命名为 <code>main</code>。通常情况下，你可以以任何方式命名包，但 <code>main</code> 包在 Go 中是很特别的。当 Go 看到一个包被命名为 <code>main</code> 时，它知道这个包应该被视为二进制文件，应该被编译成可执行文件，而不是一个旨在用于其他程序的库。</p><p>在定义了 <code>包</code> 之后，<code>import</code> 声明说要导入 <a href=https://pkg.go.dev/fmt><code>fmt</code></a> 包，所以你可以使用它的 <code>Println</code> 函数将 <code>"Hello, Modules!"</code> 信息打印到屏幕上。</p><p>最后，定义了 <code>main</code> 函数。<code>main</code> 函数是 Go 的另一个特例，与<code>main</code>包有关。当 Go 看到一个名为 <code>main</code> 的包内有一个名为 <code>main</code> 的函数时，它知道 <code>main</code> 函数是它应该运行的第一个函数。这被称为程序的入口点。</p><p>一旦你创建了 <code>main.go</code> 文件，该模块的目录结构将类似于这样：</p><pre tabindex=0><code>└── projects
    └── mymodule
        └── go.mod
        └── main.go
</code></pre><p>如果你熟悉使用 Go 和 <a href=https://www.digitalocean.com/community/tutorials/understanding-the-gopath><code>GOPATH</code></a> ，运行模块中的代码就类似于从 <code>GOPATH</code> 中的一个目录中进行。（如果你不熟悉 <code>GOPATH</code> 也不用担心，因为使用模块可以代替它的使用。）</p><p>在 Go 中运行可执行程序有两种常见的方法：用 <code>go build</code> 构建二进制文件或用 <code>go run</code> 运行文件。在本教程中，你将使用 <code>go run</code> 直接运行模块，而不是构建二进制文件，后者必须单独运行。</p><p>用 <code>go run</code> 运行你创建的 <code>main.go</code> 文件：</p><pre tabindex=0><code>go run main.go
</code></pre><p>运行该命令将打印代码中定义的 <code>Hello, Modules!</code> 文本：</p><pre tabindex=0><code>Output
Hello, Modules!
</code></pre><p>在这一节中，你为你的模块添加了一个 <code>main.go</code> 文件，其中的初始 <code>main</code> 函数打印出 <code>Hello, Modules!</code>。在这一点上，你的程序还没有从 Go 模块中获益—它可以是你电脑上任何地方的一个文件，用 <code>go run</code> 来运行。Go 模块的第一个真正好处是能够在任何目录下为你的项目添加依赖，而不仅仅是 <code>GOPATH</code> 目录结构。你还可以向你的模块添加包。在下一节中，你将通过在模块中创建一个额外的包来扩展你的模块。</p><h2 id=为你的模块添加一个包>为你的模块添加一个包
<a class=anchor href=#%e4%b8%ba%e4%bd%a0%e7%9a%84%e6%a8%a1%e5%9d%97%e6%b7%bb%e5%8a%a0%e4%b8%80%e4%b8%aa%e5%8c%85>#</a></h2><p>类似于标准的 Go 包，一个模块可以包含任何数量的包和子包，也可以完全不包含。在这个例子中，你将在 <code>mymodule</code> 目录下创建一个名为 <code>mypackage</code> 的包。</p><p>通过在 <code>mymodule</code> 目录下运行 <code>mkdir</code> 命令并加上 <code>mypackage</code> 参数来创建这个新包：</p><pre tabindex=0><code>mkdir mypackage
</code></pre><p>这将创建新的目录 <code>mypackage</code> 作为 <code>mymodule</code> 目录的一个子包：</p><pre tabindex=0><code>└── projects
    └── mymodule
        └── mypackage
        └── main.go
        └── go.mod
</code></pre><p>使用 <code>cd</code> 命令将当前目录改为新的 <code>mypackage</code> 目录，然后使用 <code>nano</code> ，或你喜欢的文本编辑器，创建一个 <code>mypackage.go</code> 文件。这个文件可以有任何名字，但使用与软件包相同的名字可以更容易找到软件包的主文件：</p><pre tabindex=0><code>cd mypackage
nano mypackage.go
</code></pre><p>在 <code>mypackage.go</code> 文件中，添加一个名为 <code>PrintHello</code> 的函数，当被调用时，将打印 <code>Hello, Modules! This is mypackage speaking!</code> ：</p><p>projects/mymodule/mypackage/mypackage.go</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>mypackage</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PrintHello</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello, Modules! This is mypackage speaking!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于你希望 <code>PrintHello</code> 函数可以从另一个包中使用，函数名称中的大写字母 <code>P</code> 很重要。大写字母意味着该函数是导出的，对任何外部程序都是可用的。关于 Go 中包的可见性的更多信息，<a href=https://www.digitalocean.com/community/tutorials/understanding-package-visibility-in-go>Understanding Package Visibility in Go</a> 包括更多细节。</p><p>现在你已经创建了带有导出函数的 <code>mypackage</code> 包，你将需要从 <code>mymodule</code> 包中 <code>导入</code> 它来使用它。这与你导入其他包的方法类似，比如之前的 <code>fmt</code> 包，只是这次你要在导入路径的开头加入你的模块名称。从 <code>mymodule</code> 目录下打开你的 <code>main.go</code> 文件，通过添加下面高亮的行来添加对 <code>PrintHello</code> 的调用：</p><p>projects/mymodule/main.go</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;mymodule/mypackage&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello, Modules!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mypackage</span>.<span style=color:#a6e22e>PrintHello</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果你仔细看一下 <code>import</code> 语句，你会看到新的导入以 <code>mymodule</code> 开始，也就是你在 <code>go.mod</code> 文件中设置的模块名称。后面是路径分隔符和你要导入的包，本例中是<code>mypackage</code>：</p><pre tabindex=0><code>&#34;mymodule/mypackage&#34;
</code></pre><p>在未来，如果你在 <code>mypackage</code> 内添加包，你也会以类似的方式将它们添加到导入路径的末尾。例如，如果你在 <code>mypackage</code> 内有另一个叫 <code>extrapackage</code> 的包，你对该包的导入路径将是 <code>mymodule/mypackage/extrapackage</code>。</p><p>像以前一样，用<code>go run</code> 和 <code>main.go</code> 从 <code>mymodule</code> 目录中运行你的更新模块：</p><pre tabindex=0><code>go run main.go
</code></pre><p>当你再次运行该模块时，你会看到先前的 &ldquo;Hello, Modules!&ldquo;信息，以及新的 <code>mypackage</code> 的 <code>PrintHello</code> 函数打印的新信息：</p><pre tabindex=0><code>Output
Hello, Modules!
Hello, Modules! This is mypackage speaking!
</code></pre><p>你现在通过创建一个名为 <code>mypackage</code> 的目录和 <code>PrintHello</code> 函数，为你的初始模块添加了一个新包。随着你的模块功能的扩展，在你的模块中开始使用其他人的模块可能会很有用。在下一节中，你将添加一个远程模块作为你的模块的依赖。</p><h2 id=添加一个远程模块作为依赖>添加一个远程模块作为依赖
<a class=anchor href=#%e6%b7%bb%e5%8a%a0%e4%b8%80%e4%b8%aa%e8%bf%9c%e7%a8%8b%e6%a8%a1%e5%9d%97%e4%bd%9c%e4%b8%ba%e4%be%9d%e8%b5%96>#</a></h2><p>Go 模块是通过版本控制库（通常是Git库）发布的。当你想添加一个新的模块作为自己的依赖时，你会使用仓库的路径作为你想使用的模块的引用方式。当 Go 看到这些模块的导入路径时，它可以根据这个仓库的路径推断出在哪里可以远程找到它。</p><p>在这个例子中，你要在你的模块中加入对 <a href=https://github.com/spf13/cobra><code>github.com/spf13/cobra</code></a> 库的依赖。Cobra 是一个常用来创建控制台应用程序的库，但我们不会在本教程中讨论这个问题。</p><p>与你创建 <code>mymodule</code> 模块时类似，你将再次使用 <code>go</code> 工具。然而，这一次，你将在 <code>mymodule</code> 目录下运行 <code>go get</code> 命令。运行 <code>go get</code> 并提供你想添加的模块。在这种情况下，你会得到 <code>github.com/spf13/cobra</code> ：</p><pre tabindex=0><code>go get github.com/spf13/cobra
</code></pre><p>当你运行这个命令时，<code>go</code> 工具将从你指定的路径查找 Cobra 仓库，并通过查看仓库的分支和标签来确定哪个版本的 Cobra 是最新的。然后，它将下载该版本，并通过在 <code>go.mod</code> 文件中添加模块名称和版本来跟踪它所选择的版本，以供将来参考。</p><p>现在，打开 <code>mymodule</code> 目录下的 <code>go.mod</code> 文件，看看当你添加新的依赖时，<code>go</code> 工具如何更新 <code>go.mod</code> 文件。下面的例子可能会有变化，这取决于当前已经发布的 Cobra 版本或你使用的 Go 工具的版本，但整体的变化结构应该是相似的：</p><p>projects/mymodule/go.mod</p><pre tabindex=0><code>module mymodule

go 1.16

require (
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/spf13/cobra v1.2.1 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
)
</code></pre><p>增加了一个使用 <code>require</code> 指令的新部分。这个指令告诉 Go 你想要哪个模块，比如 <code>github.com/spf13/cobra</code>，以及你添加的模块的版本。有时 <code>require</code> 指令也会包括一个<code>//间接</code>注释。这个注释表示，在添加 <code>require</code> 指令时，该模块没有在该模块的任何源文件中被直接引用。文件中还增加了一些额外的 <code>require</code> 行。这些行是 Cobra 所依赖的其他模块，Go 工具认为这些模块也应该被引用。</p><p>你可能还注意到，在运行 <code>go run</code> 命令后，在 <code>mymodule</code> 目录下创建了一个新的文件，<code>go.sum</code> 。这是 Go 模块的另一个重要文件，包含了 Go 用来记录依赖关系的具体哈希值和版本的信息。这确保了依赖关系的一致性，即使它们被安装在不同的机器上。</p><p>一旦你下载了依赖关系，你要用一些最小的 Cobra 代码更新你的 <code>main.go</code> 文件，以使用新的依赖关系。用下面的Cobra 代码更新 <code>mymodule</code> 目录下的 <code>main.go</code> 文件，以使用新的依赖性：</p><p>projects/mymodule/main.go</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/spf13/cobra&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;mymodule/mypackage&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cobra</span>.<span style=color:#a6e22e>Command</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Run</span>: <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>cmd</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>cobra</span>.<span style=color:#a6e22e>Command</span>, <span style=color:#a6e22e>args</span> []<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello, Modules!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mypackage</span>.<span style=color:#a6e22e>PrintHello</span>()
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Calling cmd.Execute()!&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Execute</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这段代码创建了一个 <code>cobra.Command</code> 结构，其中的 <code>Run</code> 函数包含你现有的 &ldquo;Hello&rdquo; 语句，然后将通过调用 <code>cmd.Execute()</code> 来执行。现在，运行更新后的代码：</p><pre tabindex=0><code>go run main.go
</code></pre><p>你会看到下面的输出，它看起来与你之前看到的相似。不过这一次，它使用了你的新的依赖关系，如 <code>Calling cmd.Execute()!</code> 一行所示：</p><pre tabindex=0><code>Output
Calling cmd.Execute()!
Hello, Modules!
Hello, Modules! This is mypackage speaking!
</code></pre><p>使用 <code>go get</code> 来添加远程依赖的最新版本，例如这里的 <code>github.com/sp13/cobra</code> ，使你的依赖更容易保持最新的错误修复。然而，有时你可能更愿意使用一个特定版本的模块、一个版本库标签或一个版本库分支。在下一节中，你将使用 <code>go get</code> 来引用这些版本，当你想要这个选项时。</p><h2 id=使用一个模块的特定版本>使用一个模块的特定版本
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97%e7%9a%84%e7%89%b9%e5%ae%9a%e7%89%88%e6%9c%ac>#</a></h2><p>由于 Go 模块是从版本控制库中发布的，它们可以使用版本控制功能，如标签、分支、甚至 commits 。你可以在你的依赖关系中使用<code>@</code>符号在模块路径的末尾加上你想使用的版本来引用这些。早些时候，当你安装最新版本的Cobra 时，你正在利用这种能力，但你不需要在命令中明确添加它。<code>go</code> 工具知道，如果没有用<code>@</code>提供特定的版本，它应该使用特殊的版本 <code>latest</code> 。<code>latest</code> 版本实际上并不在版本库中，就像 <code>my-tag</code> 或 <code>my-branch</code> 可能是一样。它作为一个辅助工具内置于 <code>go</code> 工具中，所以你不需要自己去搜索最新的版本。</p><p>例如，当你最初添加你的依赖关系时，你也可以使用下面的命令获得同样的结果：</p><pre tabindex=0><code>go get github.com/spf13/cobra@latest
</code></pre><p>现在，想象有一个你使用的模块，目前正在开发中。在这个例子中，称它为 <code>your_domain/sammy/awesome</code> 。这个 <code>awesome</code> 模块正在增加一个新的功能，工作在一个叫做 <code>new-feature</code> 的分支中进行。要把这个分支作为你自己的模块的依赖项，你可以向 <code>go get</code> 提供模块的路径，后面是<code>@</code>符号，再后面是分支的名称：</p><pre tabindex=0><code>go get your_domain/sammy/awesome@new-feature
</code></pre><p>运行这个命令会使 <code>go</code> 连接到 <code>your_domain/sammy/awesome</code> 仓库，下载 <code>new-feature</code> 分支的当前最新提交，并将该信息添加到 <code>go.mod</code> 文件。</p><p>不过，分支并不是唯一可以使用<code>@</code>选项的方式。这个语法可以用于标签，甚至是版本库的特定提交。例如，有时你正在使用的库的最新版本可能有一个坏的提交。在这种情况下，引用破损提交之前的提交可能会很有用。</p><p>以你的模块所依赖的 Cobra 为例，假设你需要引用 <code>github.com/spf13/cobra</code> 的 <code>07445ea</code> 提交，因为它有一些你需要的修改，而你因为某些原因不能使用其他版本。在这种情况下，你可以在<code>@</code>符号后面提供提交哈希值，就像对分支或标签一样。在你的 <code>mymodule</code>目 录下运行<code>go get</code>命令，输入模块和版本来下载新版本：</p><pre tabindex=0><code>go get github.com/spf13/cobra@07445ea
</code></pre><p>如果你再次打开你模块的 <code>go.mod</code> 文件，你会看到 <code>go get</code> 已经更新了 <code>github.com/spf13/cobra</code> 的<code>require</code>行，引用你指定的提交：</p><p>projects/mymodule/go.mod</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>module</span> <span style=color:#a6e22e>mymodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#ae81ff>1.16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>require</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>inconshreveable</span><span style=color:#f92672>/</span><span style=color:#a6e22e>mousetrap</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.0.0</span> <span style=color:#75715e>// indirect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>spf13</span><span style=color:#f92672>/</span><span style=color:#a6e22e>cobra</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.1.2</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0.20210209210842</span><span style=color:#f92672>-</span><span style=color:#ae81ff>07445</span><span style=color:#a6e22e>ea179fc</span> <span style=color:#75715e>// indirect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>spf13</span><span style=color:#f92672>/</span><span style=color:#a6e22e>pflag</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.0.5</span> <span style=color:#75715e>// indirect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><p>由于提交是一个特定的时间点，与标签或分支不同，Go在 <code>require</code> 指令中包含了额外的信息，以确保它在未来使用正确的版本。如果你仔细看一下版本，你会发现它确实包括你提供的提交散列。<code>v1.1.2-0.20210209210842-07445ea179fc</code>.</p><p>Go 模块也使用这个功能来支持发布不同版本的模块。当 Go 模块发布新版本时，一个新的标签会被添加到版本库中，并以版本号作为标签。如果你想使用一个特定的版本，你可以查看版本库中的标签列表，找到你要找的版本。如果你已经知道版本，你可能不需要在标签中搜索，因为版本标签的命名是一致的。</p><p>再以 Cobra 为例，假设你想使用 Cobra 1.1.1 版本。你可以查看 Cobra 仓库，发现它有一个名为 <code>v1.1.1</code> 的标签，还有其他标签。要使用这个标记的版本，你可以在 <code>go get</code> 命令中使用 <code>@</code> 符号，就像你使用一个非版本标记或分支。现在，通过运行以 <code>v1.1.1</code> 为版本的 <code>go get</code> 命令，更新你的模块以使用 Cobra 1.1.1：</p><pre tabindex=0><code>go get github.com/spf13/cobra@v1.1.1
</code></pre><p>现在，如果你打开你的模块的 <code>go.mod</code> 文件，你会看到 <code>go get</code> 已经更新了 <code>github.com/spf13/cobra</code> 的<code>require</code> 行，引用你提供的版本：</p><p>projects/mymodule/go.mod</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>module</span> <span style=color:#a6e22e>mymodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#ae81ff>1.16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>require</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>inconshreveable</span><span style=color:#f92672>/</span><span style=color:#a6e22e>mousetrap</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.0.0</span> <span style=color:#75715e>// indirect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>spf13</span><span style=color:#f92672>/</span><span style=color:#a6e22e>cobra</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.1.1</span> <span style=color:#75715e>// indirect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>com</span><span style=color:#f92672>/</span><span style=color:#a6e22e>spf13</span><span style=color:#f92672>/</span><span style=color:#a6e22e>pflag</span> <span style=color:#a6e22e>v1</span><span style=color:#ae81ff>.0.5</span> <span style=color:#75715e>// indirect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><p>最后，如果你正在使用一个特定版本的库，例如 <code>07445ea</code> 提交或早期的 <code>v1.1.1</code> ，但你确定你宁愿开始使用最新版本，可以通过使用特殊的 <code>latest</code> 版本来实现。要将你的模块更新到最新版本的 Cobra，请再次运行 <code>go get</code>，输入模块路径和 <code>latest</code> 版本：</p><pre tabindex=0><code>go get github.com/spf13/cobra@latest
</code></pre><p>一旦这个命令完成，<code>go.mod</code> 文件将更新为你引用特定版本的 Cobra 之前的样子。根据你的 Go 版本和当前最新的Cobra 版本，你的输出可能会略有不同，但你仍然应该看到 <code>require</code> 部分的 <code>github.com/spf13/cobra</code> 行再次更新为最新版本：</p><pre tabindex=0><code>module mymodule

go 1.16

require (
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/spf13/cobra v1.2.1 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
)
</code></pre><p><code>go get</code> 命令是一个强大的工具，你可以用它来管理 <code>go.mod</code> 文件中的依赖关系，而不需要手动编辑它。正如你在本节中看到的，在模块名称中使用 <code>@</code> 字符可以让你使用模块的特定版本，从发布版本到特定的版本库提交。它甚至可以用来回到你的依赖的 <code>latest</code> 版本。使用这些选项的组合将使你能够确保你的程序在未来的稳定性。</p><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><p>在本教程中，你创建了一个带有子包的 Go 模块，并在你的模块中使用该包。你还将另一个模块作为依赖关系添加到你的模块中，并探索了如何以各种方式引用模块版本。</p><p>关于 Go 模块的更多信息，Go 项目有<a href=https://blog.golang.org/using-go-modules>一系列博文</a>介绍 Go 工具如何与模块互动和理解模块。Go 项目还在 <a href=https://golang.org/ref/mod>Go模块参考</a> 中为 Go 模块提供了非常详细的技术参考。</p><p>本教程也是 <a href=https://www.digitalocean.com/>DigitalOcean</a><a href=https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go>How to Code in Go</a> 系列教程的一部分。该系列涵盖了许多 Go 主题，从首次安装 Go 到如何使用语言本身。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#前期准备>前期准备</a></li><li><a href=#创建一个新的模块>创建一个新的模块</a></li><li><a href=#了解-gomod-文件>了解 <code>go.mod</code> 文件</a></li><li><a href=#在你的模块中添加go代码>在你的模块中添加Go代码</a></li><li><a href=#为你的模块添加一个包>为你的模块添加一个包</a></li><li><a href=#添加一个远程模块作为依赖>添加一个远程模块作为依赖</a></li><li><a href=#使用一个模块的特定版本>使用一个模块的特定版本</a></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></main></body></html>